项目文件夹架构:
CardKing/
.trae/
    rule/
        project_rules.md
    scripts/
        dump_project.py
src/
    components/
        BankGameMobile.vue
        BankGamePC.vue
        BluffGame.vue
        BluffGameMobile.vue
        MainMenu.vue
        MarbleGame.vue
        ResultDisplay.vue
        SetGameMobile.vue
        SetGamePC.vue
        TripleCardBattleMobile.vue
        TripleCardBattlePC.vue
    store/
        bankGameStore.js
        bluffGameStore.js
        gameStore.js
        marbleGameStore.js
        setGameStore.js
    utils/
        marbleGame/
            AIPlayer.js
            GameState.js
            index.js
            InputManager.js
            PhysicsManager.js
            SceneManager.js
        AIPlayer.js
        BluffAI.js
        Card.js
        constants.js
        Deck.js
        deviceDetector.js
        RuleEvaluator.js
        setCardRenderer.js
    App.vue
    main.js
    style.css
说明书/
    吹牛皮游戏需求规格说明书.txt
    弹珠游戏开发计划.txt
    弹珠游戏需求规格说明书.md
    形色牌说明书.md
    打包代码.md
    游戏需求规格说明书.txt
.gitattributes
.gitignore
index.html
package-lock.json
package.json
project_rules.md
vite.config.js

============================================================
文件内容:

--- .gitattributes ---
# Auto detect text files and perform LF normalization
* text=auto

--- .gitignore ---
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

.git/
参考界面/


# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

--- .trae/rule/project_rules.md ---
# UI 规则
角色设定：你是使用颗粒/噪点质感的设计师，要在保持清晰度的前提下，用微粒让画面更有温度与胶片感。

场景定位：品牌故事、复古/摄影/手作相关页面，或需要消除大面积渐变 banding 的场景。

视觉设计理念：在背景或大块色面上叠加低透明度噪点（8–18%），控制颗粒细腻度；文字区保持对比与干净填充，避免噪点过密。

材质与质感：可用 SVG noise、canvas 噪点或细砂纸贴图；搭配柔和阴影与简单几何；颜色偏低饱和或中性色以突出颗粒。

交互体验：Hover/Active 主要作用于边框亮度或阴影，不改变噪点密度以避免闪烁。动效平缓，保持胶片稳定感。

整体氛围：温润、带摄影胶片气息，画面不生硬但仍可读。

---

--- .trae/scripts/dump_project.py ---
#!/usr/bin/env python3
"""
dump_project.py - 抽取项目文件夹架构和所有文件内容。
支持忽略规则（类似 .gitignore）。
"""

import os
import sys
import argparse
import fnmatch
from pathlib import Path

# 尝试导入 pathspec（推荐，但非必需）
try:
    from pathspec import PathSpec
    from pathspec.patterns import GitWildMatchPattern
    HAS_PATHSPEC = True
except ImportError:
    HAS_PATHSPEC = False


class SimpleIgnoreMatcher:
    """简单的忽略规则匹配器（不支持 ** 和否定模式）"""

    def __init__(self, lines):
        self.patterns = []  # 每个元素为 (pattern, dir_only)
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            if line.startswith('!'):
                # 忽略否定模式（简单版本不支持）
                continue
            dir_only = line.endswith('/')
            if dir_only:
                line = line[:-1]
            self.patterns.append((line, dir_only))

    def match(self, rel_path, is_dir=False):
        """
        rel_path: 相对于根目录的路径（使用正斜杠）
        is_dir  : 是否为目录
        返回 True 表示应忽略
        """
        for pattern, dir_only in self.patterns:
            if dir_only and not is_dir:
                continue
            # 处理以 / 开头的模式（锚定到根目录）
            if pattern.startswith('/'):
                p = pattern[1:]
                if fnmatch.fnmatch(rel_path, p):
                    return True
            elif '/' in pattern:
                # 模式包含 /，匹配完整路径
                if fnmatch.fnmatch(rel_path, pattern):
                    return True
            else:
                # 模式不含 /，仅匹配文件名部分
                basename = os.path.basename(rel_path)
                if fnmatch.fnmatch(basename, pattern):
                    return True
        return False


def load_ignore_matcher(ignore_file):
    """加载忽略规则，返回匹配器对象"""
    if not os.path.isfile(ignore_file):
        return None
    with open(ignore_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    if HAS_PATHSPEC:
        # 使用 pathspec 库精确解析 gitignore 规则
        return PathSpec.from_lines(GitWildMatchPattern, lines)
    else:
        return SimpleIgnoreMatcher(lines)


def should_ignore(matcher, rel_path, is_dir=False):
    """判断相对路径是否应忽略"""
    if matcher is None:
        return False
    if HAS_PATHSPEC:
        # pathspec 需要为目录添加尾部斜杠，以便匹配以 '/' 结尾的模式
        match_path = rel_path + '/' if is_dir else rel_path
        return matcher.match_file(match_path)
    else:
        return matcher.match(rel_path, is_dir)


def build_tree(root_path, rel_path, matcher, follow_links, file_paths):
    """
    递归构建目录树，并收集所有应包含的文件路径。
    返回树节点列表，每个节点为 (type, name, [children])。
    """
    full_path = os.path.join(root_path, rel_path) if rel_path else root_path
    entries = []
    try:
        with os.scandir(full_path) as it:
            for entry in it:
                name = entry.name
                if rel_path:
                    rel_entry = os.path.join(rel_path, name).replace(os.sep, '/')
                else:
                    rel_entry = name

                if entry.is_dir(follow_symlinks=follow_links):
                    if should_ignore(matcher, rel_entry, is_dir=True):
                        continue
                    sub_tree = build_tree(root_path, rel_entry, matcher,
                                          follow_links, file_paths)
                    entries.append(('dir', name, sub_tree))
                else:
                    if should_ignore(matcher, rel_entry, is_dir=False):
                        continue
                    entries.append(('file', name))
                    file_paths.append(rel_entry)
    except PermissionError:
        entries.append(('error', '权限不足无法访问', None))
    except OSError as e:
        entries.append(('error', f'访问错误: {e}', None))

    # 排序：目录在前，文件在后，均按名称不区分大小写排序
    entries.sort(key=lambda x: (x[0] != 'dir', x[1].lower()))
    return entries


def generate_tree(start_path, matcher, follow_links=False):
    """生成树形文本行列表和文件相对路径列表"""
    start_path = os.path.abspath(start_path)
    root_name = os.path.basename(start_path) or start_path

    file_paths = []
    tree_data = build_tree(start_path, '', matcher, follow_links, file_paths)

    # 将树数据转换为文本行
    tree_lines = []

    def _print_tree(data, indent=''):
        for entry in data:
            if entry[0] == 'dir':
                tree_lines.append(f"{indent}{entry[1]}/")
                _print_tree(entry[2], indent + '    ')
            elif entry[0] == 'file':
                tree_lines.append(f"{indent}{entry[1]}")
            else:
                tree_lines.append(f"{indent}<{entry[1]}>")

    _print_tree(tree_data)
    tree_lines.insert(0, f"{root_name}/")
    return tree_lines, file_paths


def read_file_content(rel_path, root):
    """尝试以 UTF-8 读取文件内容，失败时返回 None 表示二进制文件"""
    full_path = os.path.join(root, rel_path)
    try:
        with open(full_path, 'r', encoding='utf-8') as f:
            return f.read()
    except UnicodeDecodeError:
        return None
    except Exception as e:
        return f"<读取文件时出错: {e}>"


def main():
    parser = argparse.ArgumentParser(
        description="抽取项目文件夹架构和文件内容（支持忽略规则）")
    parser.add_argument('path', nargs='?', default='.',
                        help="项目根目录 (默认当前目录)")
    parser.add_argument('-o', '--output', help="输出文件路径 (默认输出到控制台)")
    parser.add_argument('-i', '--ignore-file',
                        help="忽略文件路径 (默认在根目录下查找 .gitignore)")
    parser.add_argument('--no-ignore', action='store_true',
                        help="不使用任何忽略文件")
    parser.add_argument('--follow-links', action='store_true',
                        help="跟随符号链接")
    args = parser.parse_args()

    root = os.path.abspath(args.path)
    if not os.path.isdir(root):
        print(f"错误: {root} 不是有效的目录", file=sys.stderr)
        sys.exit(1)

    matcher = None
    if not args.no_ignore:
        ignore_file = args.ignore_file
        if ignore_file is None:
            # 默认查找根目录下的 .gitignore
            gitignore = os.path.join(root, '.gitignore')
            if os.path.isfile(gitignore):
                ignore_file = gitignore
        if ignore_file and os.path.isfile(ignore_file):
            matcher = load_ignore_matcher(ignore_file)
            if matcher is None:
                print(f"警告: 忽略文件 {ignore_file} 为空或无法加载",
                      file=sys.stderr)
        elif ignore_file:
            print(f"警告: 忽略文件 {ignore_file} 不存在", file=sys.stderr)

    if not HAS_PATHSPEC and matcher is not None:
        print("提示: 未安装 pathspec 库，将使用内置简单匹配器（不支持 ** 和否定模式）",
              file=sys.stderr)

    print(f"正在处理目录: {root}", file=sys.stderr)

    tree_lines, file_paths = generate_tree(root, matcher, args.follow_links)

    # 构建输出内容
    output_lines = []
    output_lines.append("项目文件夹架构:")
    output_lines.extend(tree_lines)
    output_lines.append("\n" + "=" * 60)
    output_lines.append("文件内容:")
    output_lines.append("")

    for rel_path in file_paths:
        output_lines.append(f"--- {rel_path} ---")
        content = read_file_content(rel_path, root)
        if content is None:
            output_lines.append("<二进制文件，内容未显示>")
        else:
            output_lines.append(content.rstrip())
        output_lines.append("")  # 空行分隔

    output_text = "\n".join(output_lines)

    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            f.write(output_text)
        print(f"输出已写入 {args.output}", file=sys.stderr)
    else:
        print(output_text)


if __name__ == '__main__':
    main()

--- index.html ---
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="三卡对决" />
    <meta name="theme-color" content="#0a0a0c" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta name="description" content="三卡对决 - 一款策略性扑克牌游戏" />
    <meta name="keywords" content="三卡对决,扑克游戏,卡牌游戏,Card King" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <title>三卡对决 - Card King</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        background: #0a0a0c;
        overflow-x: hidden;
      }
      @media (min-width: 769px) {
        html, body {
          background: linear-gradient(135deg, #1a472a 0%, #2d5a3f 50%, #1a472a 100%);
        }
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

--- package-lock.json ---
{
  "name": "labs",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "labs",
      "version": "1.0.0",
      "dependencies": {
        "@vueuse/core": "^14.2.1",
        "cannon-es": "^0.20.0",
        "three": "^0.183.1",
        "vue": "^3.4.0"
      },
      "devDependencies": {
        "@vitejs/plugin-vue": "^5.0.0",
        "vite": "^5.0.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmmirror.com/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.28.5",
      "resolved": "https://registry.npmmirror.com/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.29.0",
      "resolved": "https://registry.npmmirror.com/@babel/parser/-/parser-7.29.0.tgz",
      "integrity": "sha512-IyDgFV5GeDUVX4YdF/3CPULtVGSXXMLh1xVIgdCgxApktqnQV0r7/8Nqthg+8YLGaAtdyIlo2qIdZrbCv4+7ww==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.29.0"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.29.0",
      "resolved": "https://registry.npmmirror.com/@babel/types/-/types-7.29.0.tgz",
      "integrity": "sha512-LwdZHpScM4Qz8Xw2iKSzS+cfglZzJGvofQICy7W7v4caru4EaAmyUuO6BGrbyQ2mYV11W0U8j5mBhd14dd3B0A==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
      "integrity": "sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/android-arm/-/android-arm-0.21.5.tgz",
      "integrity": "sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz",
      "integrity": "sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/android-x64/-/android-x64-0.21.5.tgz",
      "integrity": "sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz",
      "integrity": "sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz",
      "integrity": "sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz",
      "integrity": "sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz",
      "integrity": "sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz",
      "integrity": "sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz",
      "integrity": "sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz",
      "integrity": "sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz",
      "integrity": "sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz",
      "integrity": "sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz",
      "integrity": "sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz",
      "integrity": "sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz",
      "integrity": "sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz",
      "integrity": "sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz",
      "integrity": "sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz",
      "integrity": "sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz",
      "integrity": "sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz",
      "integrity": "sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz",
      "integrity": "sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz",
      "integrity": "sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmmirror.com/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "license": "MIT"
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.58.0.tgz",
      "integrity": "sha512-mr0tmS/4FoVk1cnaeN244A/wjvGDNItZKR8hRhnmCzygyRXYtKF5jVDSIILR1U97CTzAYmbgIj/Dukg62ggG5w==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.58.0.tgz",
      "integrity": "sha512-+s++dbp+/RTte62mQD9wLSbiMTV+xr/PeRJEc/sFZFSBRlHPNPVaf5FXlzAL77Mr8FtSfQqCN+I598M8U41ccQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.58.0.tgz",
      "integrity": "sha512-MFWBwTcYs0jZbINQBXHfSrpSQJq3IUOakcKPzfeSznONop14Pxuqa0Kg19GD0rNBMPQI2tFtu3UzapZpH0Uc1Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.58.0.tgz",
      "integrity": "sha512-yiKJY7pj9c9JwzuKYLFaDZw5gma3fI9bkPEIyofvVfsPqjCWPglSHdpdwXpKGvDeYDms3Qal8qGMEHZ1M/4Udg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.58.0.tgz",
      "integrity": "sha512-x97kCoBh5MOevpn/CNK9W1x8BEzO238541BGWBc315uOlN0AD/ifZ1msg+ZQB05Ux+VF6EcYqpiagfLJ8U3LvQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.58.0.tgz",
      "integrity": "sha512-Aa8jPoZ6IQAG2eIrcXPpjRcMjROMFxCt1UYPZZtCxRV68WkuSigYtQ/7Zwrcr2IvtNJo7T2JfDXyMLxq5L4Jlg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.58.0.tgz",
      "integrity": "sha512-Ob8YgT5kD/lSIYW2Rcngs5kNB/44Q2RzBSPz9brf2WEtcGR7/f/E9HeHn1wYaAwKBni+bdXEwgHvUd0x12lQSA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.58.0.tgz",
      "integrity": "sha512-K+RI5oP1ceqoadvNt1FecL17Qtw/n9BgRSzxif3rTL2QlIu88ccvY+Y9nnHe/cmT5zbH9+bpiJuG1mGHRVwF4Q==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.58.0.tgz",
      "integrity": "sha512-T+17JAsCKUjmbopcKepJjHWHXSjeW7O5PL7lEFaeQmiVyw4kkc5/lyYKzrv6ElWRX/MrEWfPiJWqbTvfIvjM1Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.58.0.tgz",
      "integrity": "sha512-cCePktb9+6R9itIJdeCFF9txPU7pQeEHB5AbHu/MKsfH/k70ZtOeq1k4YAtBv9Z7mmKI5/wOLYjQ+B9QdxR6LA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.58.0.tgz",
      "integrity": "sha512-iekUaLkfliAsDl4/xSdoCJ1gnnIXvoNz85C8U8+ZxknM5pBStfZjeXgB8lXobDQvvPRCN8FPmmuTtH+z95HTmg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-loong64-musl/-/rollup-linux-loong64-musl-4.58.0.tgz",
      "integrity": "sha512-68ofRgJNl/jYJbxFjCKE7IwhbfxOl1muPN4KbIqAIe32lm22KmU7E8OPvyy68HTNkI2iV/c8y2kSPSm2mW/Q9Q==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.58.0.tgz",
      "integrity": "sha512-dpz8vT0i+JqUKuSNPCP5SYyIV2Lh0sNL1+FhM7eLC457d5B9/BC3kDPp5BBftMmTNsBarcPcoz5UGSsnCiw4XQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-ppc64-musl/-/rollup-linux-ppc64-musl-4.58.0.tgz",
      "integrity": "sha512-4gdkkf9UJ7tafnweBCR/mk4jf3Jfl0cKX9Np80t5i78kjIH0ZdezUv/JDI2VtruE5lunfACqftJ8dIMGN4oHew==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.58.0.tgz",
      "integrity": "sha512-YFS4vPnOkDTD/JriUeeZurFYoJhPf9GQQEF/v4lltp3mVcBmnsAdjEWhr2cjUCZzZNzxCG0HZOvJU44UGHSdzw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.58.0.tgz",
      "integrity": "sha512-x2xgZlFne+QVNKV8b4wwaCS8pwq3y14zedZ5DqLzjdRITvreBk//4Knbcvm7+lWmms9V9qFp60MtUd0/t/PXPw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.58.0.tgz",
      "integrity": "sha512-jIhrujyn4UnWF8S+DHSkAkDEO3hLX0cjzxJZPLF80xFyzyUIYgSMRcYQ3+uqEoyDD2beGq7Dj7edi8OnJcS/hg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.58.0.tgz",
      "integrity": "sha512-+410Srdoh78MKSJxTQ+hZ/Mx+ajd6RjjPwBPNd0R3J9FtL6ZA0GqiiyNjCO9In0IzZkCNrpGymSfn+kgyPQocg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.58.0.tgz",
      "integrity": "sha512-ZjMyby5SICi227y1MTR3VYBpFTdZs823Rs/hpakufleBoufoOIB6jtm9FEoxn/cgO7l6PM2rCEl5Kre5vX0QrQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openbsd-x64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-openbsd-x64/-/rollup-openbsd-x64-4.58.0.tgz",
      "integrity": "sha512-ds4iwfYkSQ0k1nb8LTcyXw//ToHOnNTJtceySpL3fa7tc/AsE+UpUFphW126A6fKBGJD5dhRvg8zw1rvoGFxmw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.58.0.tgz",
      "integrity": "sha512-fd/zpJniln4ICdPkjWFhZYeY/bpnaN9pGa6ko+5WD38I0tTqk9lXMgXZg09MNdhpARngmxiCg0B0XUamNw/5BQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.58.0.tgz",
      "integrity": "sha512-YpG8dUOip7DCz3nr/JUfPbIUo+2d/dy++5bFzgi4ugOGBIox+qMbbqt/JoORwvI/C9Kn2tz6+Bieoqd5+B1CjA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.58.0.tgz",
      "integrity": "sha512-b9DI8jpFQVh4hIXFr0/+N/TzLdpBIoPzjt0Rt4xJbW3mzguV3mduR9cNgiuFcuL/TeORejJhCWiAXe3E/6PxWA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.58.0.tgz",
      "integrity": "sha512-CSrVpmoRJFN06LL9xhkitkwUcTZtIotYAF5p6XOR2zW0Zz5mzb3IPpcoPhB02frzMHFNo1reQ9xSF5fFm3hUsQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.58.0.tgz",
      "integrity": "sha512-QFsBgQNTnh5K0t/sBsjJLq24YVqEIVkGpfN2VHsnN90soZyhaiA9UUHufcctVNL4ypJY0wrwad0wslx2KJQ1/w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmmirror.com/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/web-bluetooth": {
      "version": "0.0.21",
      "resolved": "https://registry.npmmirror.com/@types/web-bluetooth/-/web-bluetooth-0.0.21.tgz",
      "integrity": "sha512-oIQLCGWtcFZy2JW77j9k8nHzAOpqMHLQejDA48XXMWH6tjCQHz5RCFz1bzsmROyL6PUm+LLnUiI4BCn221inxA==",
      "license": "MIT"
    },
    "node_modules/@vitejs/plugin-vue": {
      "version": "5.2.4",
      "resolved": "https://registry.npmmirror.com/@vitejs/plugin-vue/-/plugin-vue-5.2.4.tgz",
      "integrity": "sha512-7Yx/SXSOcQq5HiiV3orevHUFn+pmMB4cgbEkDYgnkUWb0WfeQ/wa2yFv6D5ICiCQOVpjA7vYDXrC7AGO8yjDHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "peerDependencies": {
        "vite": "^5.0.0 || ^6.0.0",
        "vue": "^3.2.25"
      }
    },
    "node_modules/@vue/compiler-core": {
      "version": "3.5.28",
      "resolved": "https://registry.npmmirror.com/@vue/compiler-core/-/compiler-core-3.5.28.tgz",
      "integrity": "sha512-kviccYxTgoE8n6OCw96BNdYlBg2GOWfBuOW4Vqwrt7mSKWKwFVvI8egdTltqRgITGPsTFYtKYfxIG8ptX2PJHQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.29.0",
        "@vue/shared": "3.5.28",
        "entities": "^7.0.1",
        "estree-walker": "^2.0.2",
        "source-map-js": "^1.2.1"
      }
    },
    "node_modules/@vue/compiler-dom": {
      "version": "3.5.28",
      "resolved": "https://registry.npmmirror.com/@vue/compiler-dom/-/compiler-dom-3.5.28.tgz",
      "integrity": "sha512-/1ZepxAb159jKR1btkefDP+J2xuWL5V3WtleRmxaT+K2Aqiek/Ab/+Ebrw2pPj0sdHO8ViAyyJWfhXXOP/+LQA==",
      "license": "MIT",
      "dependencies": {
        "@vue/compiler-core": "3.5.28",
        "@vue/shared": "3.5.28"
      }
    },
    "node_modules/@vue/compiler-sfc": {
      "version": "3.5.28",
      "resolved": "https://registry.npmmirror.com/@vue/compiler-sfc/-/compiler-sfc-3.5.28.tgz",
      "integrity": "sha512-6TnKMiNkd6u6VeVDhZn/07KhEZuBSn43Wd2No5zaP5s3xm8IqFTHBj84HJah4UepSUJTro5SoqqlOY22FKY96g==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.29.0",
        "@vue/compiler-core": "3.5.28",
        "@vue/compiler-dom": "3.5.28",
        "@vue/compiler-ssr": "3.5.28",
        "@vue/shared": "3.5.28",
        "estree-walker": "^2.0.2",
        "magic-string": "^0.30.21",
        "postcss": "^8.5.6",
        "source-map-js": "^1.2.1"
      }
    },
    "node_modules/@vue/compiler-ssr": {
      "version": "3.5.28",
      "resolved": "https://registry.npmmirror.com/@vue/compiler-ssr/-/compiler-ssr-3.5.28.tgz",
      "integrity": "sha512-JCq//9w1qmC6UGLWJX7RXzrGpKkroubey/ZFqTpvEIDJEKGgntuDMqkuWiZvzTzTA5h2qZvFBFHY7fAAa9475g==",
      "license": "MIT",
      "dependencies": {
        "@vue/compiler-dom": "3.5.28",
        "@vue/shared": "3.5.28"
      }
    },
    "node_modules/@vue/reactivity": {
      "version": "3.5.28",
      "resolved": "https://registry.npmmirror.com/@vue/reactivity/-/reactivity-3.5.28.tgz",
      "integrity": "sha512-gr5hEsxvn+RNyu9/9o1WtdYdwDjg5FgjUSBEkZWqgTKlo/fvwZ2+8W6AfKsc9YN2k/+iHYdS9vZYAhpi10kNaw==",
      "license": "MIT",
      "dependencies": {
        "@vue/shared": "3.5.28"
      }
    },
    "node_modules/@vue/runtime-core": {
      "version": "3.5.28",
      "resolved": "https://registry.npmmirror.com/@vue/runtime-core/-/runtime-core-3.5.28.tgz",
      "integrity": "sha512-POVHTdbgnrBBIpnbYU4y7pOMNlPn2QVxVzkvEA2pEgvzbelQq4ZOUxbp2oiyo+BOtiYlm8Q44wShHJoBvDPAjQ==",
      "license": "MIT",
      "dependencies": {
        "@vue/reactivity": "3.5.28",
        "@vue/shared": "3.5.28"
      }
    },
    "node_modules/@vue/runtime-dom": {
      "version": "3.5.28",
      "resolved": "https://registry.npmmirror.com/@vue/runtime-dom/-/runtime-dom-3.5.28.tgz",
      "integrity": "sha512-4SXxSF8SXYMuhAIkT+eBRqOkWEfPu6nhccrzrkioA6l0boiq7sp18HCOov9qWJA5HML61kW8p/cB4MmBiG9dSA==",
      "license": "MIT",
      "dependencies": {
        "@vue/reactivity": "3.5.28",
        "@vue/runtime-core": "3.5.28",
        "@vue/shared": "3.5.28",
        "csstype": "^3.2.3"
      }
    },
    "node_modules/@vue/server-renderer": {
      "version": "3.5.28",
      "resolved": "https://registry.npmmirror.com/@vue/server-renderer/-/server-renderer-3.5.28.tgz",
      "integrity": "sha512-pf+5ECKGj8fX95bNincbzJ6yp6nyzuLDhYZCeFxUNp8EBrQpPpQaLX3nNCp49+UbgbPun3CeVE+5CXVV1Xydfg==",
      "license": "MIT",
      "dependencies": {
        "@vue/compiler-ssr": "3.5.28",
        "@vue/shared": "3.5.28"
      },
      "peerDependencies": {
        "vue": "3.5.28"
      }
    },
    "node_modules/@vue/shared": {
      "version": "3.5.28",
      "resolved": "https://registry.npmmirror.com/@vue/shared/-/shared-3.5.28.tgz",
      "integrity": "sha512-cfWa1fCGBxrvaHRhvV3Is0MgmrbSCxYTXCSCau2I0a1Xw1N1pHAvkWCiXPRAqjvToILvguNyEwjevUqAuBQWvQ==",
      "license": "MIT"
    },
    "node_modules/@vueuse/core": {
      "version": "14.2.1",
      "resolved": "https://registry.npmmirror.com/@vueuse/core/-/core-14.2.1.tgz",
      "integrity": "sha512-3vwDzV+GDUNpdegRY6kzpLm4Igptq+GA0QkJ3W61Iv27YWwW/ufSlOfgQIpN6FZRMG0mkaz4gglJRtq5SeJyIQ==",
      "license": "MIT",
      "dependencies": {
        "@types/web-bluetooth": "^0.0.21",
        "@vueuse/metadata": "14.2.1",
        "@vueuse/shared": "14.2.1"
      },
      "funding": {
        "url": "https://github.com/sponsors/antfu"
      },
      "peerDependencies": {
        "vue": "^3.5.0"
      }
    },
    "node_modules/@vueuse/metadata": {
      "version": "14.2.1",
      "resolved": "https://registry.npmmirror.com/@vueuse/metadata/-/metadata-14.2.1.tgz",
      "integrity": "sha512-1ButlVtj5Sb/HDtIy1HFr1VqCP4G6Ypqt5MAo0lCgjokrk2mvQKsK2uuy0vqu/Ks+sHfuHo0B9Y9jn9xKdjZsw==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/antfu"
      }
    },
    "node_modules/@vueuse/shared": {
      "version": "14.2.1",
      "resolved": "https://registry.npmmirror.com/@vueuse/shared/-/shared-14.2.1.tgz",
      "integrity": "sha512-shTJncjV9JTI4oVNyF1FQonetYAiTBd+Qj7cY89SWbXSkx7gyhrgtEdF2ZAVWS1S3SHlaROO6F2IesJxQEkZBw==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/antfu"
      },
      "peerDependencies": {
        "vue": "^3.5.0"
      }
    },
    "node_modules/cannon-es": {
      "version": "0.20.0",
      "resolved": "https://registry.npmmirror.com/cannon-es/-/cannon-es-0.20.0.tgz",
      "integrity": "sha512-eZhWTZIkFOnMAJOgfXJa9+b3kVlvG+FX4mdkpePev/w/rP5V8NRquGyEozcjPfEoXUlb+p7d9SUcmDSn14prOA==",
      "license": "MIT"
    },
    "node_modules/csstype": {
      "version": "3.2.3",
      "resolved": "https://registry.npmmirror.com/csstype/-/csstype-3.2.3.tgz",
      "integrity": "sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==",
      "license": "MIT"
    },
    "node_modules/entities": {
      "version": "7.0.1",
      "resolved": "https://registry.npmmirror.com/entities/-/entities-7.0.1.tgz",
      "integrity": "sha512-TWrgLOFUQTH994YUyl1yT4uyavY5nNB5muff+RtWaqNVCAK408b5ZnnbNAUEWLTCpum9w6arT70i1XdQ4UeOPA==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.12"
      },
      "funding": {
        "url": "https://github.com/fb55/entities?sponsor=1"
      }
    },
    "node_modules/esbuild": {
      "version": "0.21.5",
      "resolved": "https://registry.npmmirror.com/esbuild/-/esbuild-0.21.5.tgz",
      "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/estree-walker": {
      "version": "2.0.2",
      "resolved": "https://registry.npmmirror.com/estree-walker/-/estree-walker-2.0.2.tgz",
      "integrity": "sha512-Rfkk/Mp/DL7JVje3u18FxFujQlTNR2q6QfMSMB7AvCBx91NGj/ba3kCfza0f6dVDbw7YlRf/nDrn7pQrCCyQ/w==",
      "license": "MIT"
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmmirror.com/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmmirror.com/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmmirror.com/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmmirror.com/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmmirror.com/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/rollup": {
      "version": "4.58.0",
      "resolved": "https://registry.npmmirror.com/rollup/-/rollup-4.58.0.tgz",
      "integrity": "sha512-wbT0mBmWbIvvq8NeEYWWvevvxnOyhKChir47S66WCxw1SXqhw7ssIYejnQEVt7XYQpsj2y8F9PM+Cr3SNEa0gw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.58.0",
        "@rollup/rollup-android-arm64": "4.58.0",
        "@rollup/rollup-darwin-arm64": "4.58.0",
        "@rollup/rollup-darwin-x64": "4.58.0",
        "@rollup/rollup-freebsd-arm64": "4.58.0",
        "@rollup/rollup-freebsd-x64": "4.58.0",
        "@rollup/rollup-linux-arm-gnueabihf": "4.58.0",
        "@rollup/rollup-linux-arm-musleabihf": "4.58.0",
        "@rollup/rollup-linux-arm64-gnu": "4.58.0",
        "@rollup/rollup-linux-arm64-musl": "4.58.0",
        "@rollup/rollup-linux-loong64-gnu": "4.58.0",
        "@rollup/rollup-linux-loong64-musl": "4.58.0",
        "@rollup/rollup-linux-ppc64-gnu": "4.58.0",
        "@rollup/rollup-linux-ppc64-musl": "4.58.0",
        "@rollup/rollup-linux-riscv64-gnu": "4.58.0",
        "@rollup/rollup-linux-riscv64-musl": "4.58.0",
        "@rollup/rollup-linux-s390x-gnu": "4.58.0",
        "@rollup/rollup-linux-x64-gnu": "4.58.0",
        "@rollup/rollup-linux-x64-musl": "4.58.0",
        "@rollup/rollup-openbsd-x64": "4.58.0",
        "@rollup/rollup-openharmony-arm64": "4.58.0",
        "@rollup/rollup-win32-arm64-msvc": "4.58.0",
        "@rollup/rollup-win32-ia32-msvc": "4.58.0",
        "@rollup/rollup-win32-x64-gnu": "4.58.0",
        "@rollup/rollup-win32-x64-msvc": "4.58.0",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmmirror.com/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/three": {
      "version": "0.183.1",
      "resolved": "https://registry.npmmirror.com/three/-/three-0.183.1.tgz",
      "integrity": "sha512-Psv6bbd3d/M/01MT2zZ+VmD0Vj2dbWTNhfe4CuSg7w5TuW96M3NOyCVuh9SZQ05CpGmD7NEcJhZw4GVjhCYxfQ==",
      "license": "MIT"
    },
    "node_modules/vite": {
      "version": "5.4.21",
      "resolved": "https://registry.npmmirror.com/vite/-/vite-5.4.21.tgz",
      "integrity": "sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/vue": {
      "version": "3.5.28",
      "resolved": "https://registry.npmmirror.com/vue/-/vue-3.5.28.tgz",
      "integrity": "sha512-BRdrNfeoccSoIZeIhyPBfvWSLFP4q8J3u8Ju8Ug5vu3LdD+yTM13Sg4sKtljxozbnuMu1NB1X5HBHRYUzFocKg==",
      "license": "MIT",
      "dependencies": {
        "@vue/compiler-dom": "3.5.28",
        "@vue/compiler-sfc": "3.5.28",
        "@vue/runtime-dom": "3.5.28",
        "@vue/server-renderer": "3.5.28",
        "@vue/shared": "3.5.28"
      },
      "peerDependencies": {
        "typescript": "*"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    }
  }
}

--- package.json ---
{
  "name": "labs",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vueuse/core": "^14.2.1",
    "cannon-es": "^0.20.0",
    "three": "^0.183.1",
    "vue": "^3.4.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.0",
    "vite": "^5.0.0"
  }
}

--- project_rules.md ---
1. 项目概述
项目名称：card-king（中文名：三卡对决）
引擎：Godot 4.x（GDScript）
平台：Windows / macOS / Linux（优先桌面），可扩展至 HTML5
游戏类型：2D 单人扑克策略游戏，玩家与电脑对手进行多轮对决
2. 游戏目标
在可配置的轮次（默认5轮）结束后，累计积分最高的玩家获胜。
玩家需通过合理分配手牌，在三种扑克小游戏（单张比大小、24点和、比三张）的每个小组中争取更高名次，从而最大化总分。
3. 玩家配置
人类玩家：1名
电脑对手数量：可配置 1~3 名，即总玩家数可为 2~4 人
每轮每位玩家获得 12 张手牌（从一副去掉大小王的 52 张扑克中抽取）
4. 游戏流程（每轮）
4.1 发牌
牌堆：一副标准扑克（52张，无大小王）
每轮开始前彻底洗牌
根据当前玩家总数 N，为每位玩家发放 12 张牌。剩余牌（52 - N×12）本轮弃用
4.2 分组阶段
每位玩家需将 12 张牌分成 两份（每份 6 张），每份内部分为三个小组：
1张牌组（单张组）
2张牌组（24点组）
3张牌组（比三张组）
每位玩家共形成 6 个小组，各小组牌数固定，不可更改
分组要求：
每个小组的牌数必须严格符合规定（1、2、3张）
所有手牌必须用完，不得剩余
小组之间牌不可重复
4.3 比较阶段
所有玩家完成分组后，同时亮出各组的牌
对 每一个小组（共6组）独立进行以下比较：
① 单张组
按扑克点数大小排序，从大到小：A > K > Q > J > 10 > 9 > … > 2
点数相同则比较花色，花色大小为: 黑桃 > 红桃 > 梅花 > 方片
② 24点组
按两张牌的点数之和排序，小于等于24点时，和越大排名越高
点数相同，则先比较点数最大的牌的点数，若仍相同则比较点数最大的牌的花色，花色大小为: 黑桃 > 红桃 > 梅花 > 方片
③ 比三张组
按标准比三张牌型大小排序，优先级为：
豹子（三张同点）
同花顺（同花且顺子）
同花（三张同花色）
顺子（点数连续，A可作为1或14，但不可循环，如QKA、A23合法）
对子（两张同点）
散牌（高牌）
若牌型相同，则依次比较单张点数（从大到小）；若仍相同，则比较花色，花色大小为: 黑桃 > 红桃 > 梅花 > 方片
4.4 计分规则
设有 P 名玩家（P = 2,3,4）
每组根据排名分配积分：
第一名获得 P-1 分
第二名获得 P-2 分
……
最后一名 0 分
比三张组 的得分 翻倍（即第一名得 2×(P-1) 分，第二名得 2×(P-2) 分，以此类推）
每组独立计分，立即累加到玩家的 累计总分 中
4.5 轮次循环
完成一轮所有 6 组的比较与计分后，若已进行轮数达到设定值，则游戏结束，显示最终排名；否则进入下一轮（重新洗牌、发牌、分组）
5. 游戏配置（主菜单）
电脑玩家数量：滑动条或下拉框，可选 1、2、3
游戏轮数：滑动条或输入框，范围 1~10，默认 5
“开始游戏”按钮：点击后进入游戏主场景，并应用上述配置
“退出”按钮：退出游戏
6. 用户界面需求
6.1 主菜单
简洁背景，显示游戏标题
配置项区域
开始游戏 / 退出按钮
6.2 游戏主界面
顶部状态栏：显示当前轮次/总轮数，玩家当前总分
玩家手牌区：横向展示 12 张牌（牌面朝上），每张牌可点击或拖拽
分组区：展示 6 个小组槽位，每个槽位标明组类型（单张、24点、比三张）及所属份数（第一份/第二份），槽位内显示已放入的牌的小图标或文字
操作按钮：
“自动分组”：随机将手牌填入所有槽位（用于快速测试或辅助）
“确认分组”：当所有槽位均填满且符合牌数要求时可用，点击后提交玩家分组
电脑状态区：显示每位电脑的头像和当前状态（如“思考中…”或“已准备”）
6.3 结果展示
比较阶段：可以用动画或高亮显示每组胜者
本轮结束后弹出简要报告，列出各组获胜者及得分
游戏结束时显示最终积分榜，并高亮胜利者
7. 人工智能（AI）需求
电脑对手需具备自动分组能力
基础版本：随机分组（将手牌随机排序后按顺序填入各组）
进阶版本（可选）：基于简单策略，例如：
单张组尽量留大牌
24点组尽量选点数大的两张
比三张组尝试凑成同花或顺子等大牌型
AI 决策应在玩家分组期间同步完成，避免明显等待
8. 技术需求
引擎：Godot 4.x
语言：GDScript
分辨率：适配 1280×720 及以上
资源：扑克牌图片，字体、音效可选
9. 非功能需求
可维护性：代码模块化，核心规则（比较、计分）独立为工具类，便于修改
可配置性：游戏轮数、电脑人数可通过全局变量传递
用户体验：操作流畅，反馈清晰，无明显卡顿

二、开发规范
1. 注释规范
所有注释均使用中文
生成的函数、接口、类等均需添加中文注释，包括：
功能描述
参数说明（名称、类型、作用）
返回值说明（类型、含义）
可能抛出的异常或需要注意的事项
复杂逻辑处应添加行内注释，解释算法思路或关键步骤
2. 编码原则
准确理解与执行：开发前需充分理解需求，如有歧义及时与需求方确认；严格执行已确定的功能要求，不擅自添加、删除或修改功能
模块化设计：将系统划分为独立模块（如牌堆、玩家、AI、规则评估、UI控制器等），降低耦合，提高可复用性
优先复用现有模块：在进行新功能开发或问题解决时，应先梳理系统现有功能模块清单，评估能否复用或扩展现有模块，避免重复开发
修改代码时全面检查：修改一处代码时，必须查看关联上下游文件，确保修改不会引入新问题或破坏系统稳定性
单元测试：关键逻辑（如牌型比较、计分规则）应编写测试脚本，确保正确性
3. 命名规范
节点路径：使用英文小写加下划线，如 player_hand_container
脚本文件名：使用大驼峰（PascalCase），如 Game.gd, RuleEvaluator.gd
类名：与文件名一致，大驼峰
变量/函数名：使用小驼峰（camelCase），如 currentRound, calculateScore()
常量：使用全大写加下划线，如 MAX_PLAYERS

# 特别备注
不需要启动

--- src/App.vue ---
<template>
  <div id="app" :class="{ 'is-mobile': isMobile, 'is-desktop': !isMobile }">
    <!-- 弹珠游戏 -->
    <MarbleGame v-if="marbleStore.gamePhase === 'playing'" @back-to-menu="handleBackToMenu" />
    <!-- 扑克抢银行游戏 -->
    <BankGameMobile v-else-if="bankStore.gamePhase !== 'menu' && isMobile" @back-to-menu="handleBackToMenu" />
    <BankGamePC v-else-if="bankStore.gamePhase !== 'menu' && !isMobile" @back-to-menu="handleBackToMenu" />
    <!-- 吹牛皮游戏 -->
    <BluffGameMobile v-else-if="bluffStore.gamePhase !== 'menu' && isMobile" @back-to-menu="handleBackToMenu" />
    <BluffGame v-else-if="bluffStore.gamePhase !== 'menu' && !isMobile" @back-to-menu="handleBackToMenu" />
    <!-- 主菜单 -->
    <MainMenu v-else-if="gameStore.gamePhase === 'menu' && !isSetGameStarted && !isBluffGameStarted && !isBankGameStarted && marbleStore.gamePhase === 'menu'" />
    <!-- 形色牌游戏 -->
    <SetGameMobile v-else-if="isMobile && isSetGameStarted && setStore.gamePhase !== 'gameOver'"
      @back-to-menu="handleBackToMenu" />
    <SetGamePC v-else-if="!isMobile && isSetGameStarted && setStore.gamePhase !== 'gameOver'"
      @back-to-menu="handleBackToMenu" />
    <!-- 三卡对决 -->
    <TripleCardBattleMobile v-else-if="isMobile && gameStore.gamePhase !== 'gameOver' && !isSetGameStarted"
      @back-to-menu="handleBackToMenu" />
    <TripleCardBattlePC v-else-if="!isMobile && gameStore.gamePhase !== 'gameOver' && !isSetGameStarted"
      @back-to-menu="handleBackToMenu" />
    <ResultDisplay v-if="gameStore.gamePhase === 'gameOver' || setStore.gamePhase === 'gameOver'" />
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted, watch, computed } from 'vue'
import MainMenu from './components/MainMenu.vue'
import TripleCardBattlePC from './components/TripleCardBattlePC.vue'
import TripleCardBattleMobile from './components/TripleCardBattleMobile.vue'
import SetGamePC from './components/SetGamePC.vue'
import SetGameMobile from './components/SetGameMobile.vue'
import ResultDisplay from './components/ResultDisplay.vue'
import BluffGame from './components/BluffGame.vue'
import BluffGameMobile from './components/BluffGameMobile.vue'
import BankGamePC from './components/BankGamePC.vue'
import BankGameMobile from './components/BankGameMobile.vue'
import MarbleGame from './components/MarbleGame.vue'
import gameStore from './store/gameStore.js'
import setGameStore from './store/setGameStore.js'
import bluffStore from './store/bluffGameStore.js'
import bankGameStore from './store/bankGameStore.js'
import marbleGameStore from './store/marbleGameStore.js'
import deviceDetector from './utils/deviceDetector.js'

export default {
  name: 'App',
  components: {
    MainMenu,
    TripleCardBattlePC,
    TripleCardBattleMobile,
    SetGamePC,
    SetGameMobile,
    ResultDisplay,
    BluffGame,
    BluffGameMobile,
    BankGamePC,
    BankGameMobile,
    MarbleGame
  },
  setup () {
    const isMobile = ref(false)
    const isSetGameStarted = ref(false)
    const isBluffGameStarted = ref(false)
    const isBankGameStarted = ref(false)

    const setStore = setGameStore
    const bankStore = bankGameStore
    const isSetGame = computed(() => setStore.gamePhase !== 'menu' && setStore.gamePhase !== 'gameOver')

    const checkDevice = () => {
      isMobile.value = deviceDetector.isMobile()
    }

    const handleBackToMenu = () => {
      isBluffGameStarted.value = false
      isSetGameStarted.value = false
      isBankGameStarted.value = false
      bluffStore.backToMenu()
      setStore.backToMenu()
      gameStore.backToMenu()
      bankStore.backToMenu()
      marbleGameStore.backToMenu()
    }

    onMounted(() => {
      checkDevice()
      window.addEventListener('resize', checkDevice)
    })

    onUnmounted(() => {
      window.removeEventListener('resize', checkDevice)
    })

    watch(() => gameStore.gamePhase, (newPhase) => {
      if (newPhase === 'menu') {
        isSetGameStarted.value = false
      }
      console.log('游戏阶段切换:', newPhase, '| 设备类型:', isMobile.value ? '移动端' : 'PC端')
    })

    watch(() => setStore.gamePhase, (newPhase) => {
      if (newPhase === 'playing' || newPhase === 'gameOver') {
        isSetGameStarted.value = true
      } else if (newPhase === 'menu') {
        isSetGameStarted.value = false
      }
    })

    watch(() => bluffStore.gamePhase, (newPhase) => {
      if (newPhase === 'playing' || newPhase === 'gameOver') {
        isBluffGameStarted.value = true
      } else if (newPhase === 'menu') {
        isBluffGameStarted.value = false
      }
    })

    watch(() => bankStore.gamePhase, (newPhase) => {
      if (newPhase === 'playing' || newPhase === 'gameOver') {
        isBankGameStarted.value = true
      } else if (newPhase === 'menu') {
        isBankGameStarted.value = false
      }
    })

    return {
      gameStore,
      setStore,
      bluffStore,
      bankStore,
      marbleStore: marbleGameStore,
      isMobile,
      isSetGameStarted,
      isBluffGameStarted,
      isBankGameStarted,
      handleBackToMenu
    }
  }
}
</script>

<style>
#app.is-mobile {
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

#app.is-mobile * {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}

#app.is-desktop {
  min-width: 1200px;
}
</style>

--- src/components/BankGameMobile.vue ---
<template>
  <div class="bank-game-mobile">
    <!-- 顶部区域 -->
    <header class="mobile-header">
      <button class="mobile-back-btn" @click="backToMenu">
        <span>←</span>
      </button>
      <div class="mobile-title">
        <span class="title-icon">🏦</span>
        <span>扑克抢银行</span>
      </div>
      <button class="mobile-rules-btn" @click="bankStore.showRules = true">
        <span>?</span>
      </button>
    </header>

    <!-- 状态栏 -->
    <div class="mobile-status-bar">
      <div class="status-item">
        <span class="status-label">牌堆</span>
        <span class="status-value">{{ bankStore.deckRemaining }}张</span>
      </div>
      <div class="status-item" v-if="bankStore.requiredPayment > 0">
        <span class="status-label">需支付</span>
        <span class="status-value payment">{{ bankStore.requiredPayment }}</span>
      </div>
      <div class="status-item">
        <span class="status-label">状态</span>
        <span class="status-value" :class="{ 'is-active': isPlayerTurn }">{{ statusText }}</span>
      </div>
    </div>

    <!-- 玩家信息区 -->
    <div class="mobile-players">
      <div v-for="(player, index) in bankStore.players" :key="player.id" class="mobile-player-chip" :class="{
        'is-me': !player.isAI,
        'is-current': currentPlayerIndex === index,
        'is-out': player.isOut,
        'is-paying': isPayingPhase && getPayerIndex() === index
      }">
        <div class="player-avatar">{{ getPlayerInitial(player) }}</div>
        <div class="player-info">
          <div class="player-name">{{ player.name }}</div>
          <div class="player-cards">{{ player.isOut ? '出局' : player.hand.length + '张' }}</div>
        </div>
        <div v-if="!player.isOut" class="player-value">{{ getHandValue(player) }}</div>
      </div>
    </div>

    <!-- 中央游戏区 -->
    <div class="mobile-game-area">
      <!-- 当前摸到的牌 -->
      <div v-if="bankStore.currentDrawnCard" class="drawn-card-display">
        <div class="drawn-label">当前摸牌</div>
        <div class="drawn-card-wrapper">
          <div class="playing-card" :class="getCardColorClass(bankStore.currentDrawnCard)">
            <div class="card-corner top">
              <span>{{ getCardDisplayRank(bankStore.currentDrawnCard) }}</span>
              <span>{{ getSuitSymbol(bankStore.currentDrawnCard.suit) }}</span>
            </div>
            <div class="card-center">{{ getSuitSymbol(bankStore.currentDrawnCard.suit) }}</div>
            <div class="card-corner bottom">
              <span>{{ getCardDisplayRank(bankStore.currentDrawnCard) }}</span>
              <span>{{ getSuitSymbol(bankStore.currentDrawnCard.suit) }}</span>
            </div>
          </div>
          <div class="drawn-value">价值: {{ getCardValue(bankStore.currentDrawnCard) }}</div>
        </div>
      </div>

      <!-- 牌堆和弃牌区 -->
      <div v-else class="piles-area">
        <div class="pile-item">
          <div class="pile-card">
            <div class="card-back"></div>
          </div>
          <div class="pile-label">牌堆 {{ bankStore.deckRemaining }}张</div>
        </div>
        <div class="pile-item">
          <div class="pile-card discard">
            <div class="card-back discard-back"></div>
          </div>
          <div class="pile-label">弃牌 {{ bankStore.discardPile.length }}张</div>
        </div>
      </div>

      <!-- 支付提示 -->
      <div v-if="isPayingPhase && !getPayer().isAI" class="payment-info">
        <div class="payment-title">需要支付 {{ bankStore.requiredPayment }}</div>
        <div class="payment-selected">
          已选: {{ bankStore.getSelectedTotalValue() }}
          <span v-if="bankStore.getSelectedTotalValue() !== bankStore.requiredPayment" class="payment-diff">
            ({{ bankStore.getSelectedTotalValue() > bankStore.requiredPayment ? '超出' : '不足' }})
          </span>
        </div>
      </div>

      <!-- AI思考提示 -->
      <div v-if="isAIThinking" class="ai-thinking">
        <span class="thinking-spinner"></span>
        <span>{{ getCurrentPlayer().name }} 思考中...</span>
      </div>
    </div>

    <!-- 日志区域 -->
    <div class="mobile-logs">
      <div v-for="(log, index) in recentLogs" :key="index" class="log-item">
        {{ log }}
      </div>
    </div>

    <!-- 手牌区域 -->
    <div v-if="playerHand.length > 0 && !bankStore.players[0].isOut" class="mobile-hand">
      <div class="hand-label">我的手牌 ({{ playerHand.length }}张)</div>
      <div class="hand-cards-scroll">
        <div v-for="(card, index) in playerHand" :key="index" class="playing-card" :class="[
          getCardColorClass(card),
          {
            'is-selected': isPayingPhase && bankStore.isCardSelected(card),
            'is-disabled': !isPayingPhase || getPayer().isAI
          }
        ]" @click="handleCardClick(card)">
          <div class="card-value-badge">{{ getCardValue(card) }}</div>
          <div class="card-corner top">
            <span>{{ getCardDisplayRank(card) }}</span>
            <span>{{ getSuitSymbol(card.suit) }}</span>
          </div>
          <div class="card-center">{{ getSuitSymbol(card.suit) }}</div>
          <div class="card-corner bottom">
            <span>{{ getCardDisplayRank(card) }}</span>
            <span>{{ getSuitSymbol(card.suit) }}</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 操作按钮区 -->
    <div class="mobile-actions">
      <!-- 摸牌按钮 -->
      <button v-if="isPlayerTurn && bankStore.gamePhase === 'playing'" class="mobile-btn btn-primary" @click="handleDraw">
        摸牌
      </button>

      <!-- 支付阶段按钮 -->
      <template v-if="isPayingPhase && !getPayer().isAI">
        <button class="mobile-btn btn-primary" :disabled="!bankStore.canPay()" @click="handleConfirmPayment">
          确认支付
        </button>
        <div class="action-row">
          <button class="mobile-btn btn-secondary" @click="handleResetSelection">
            重置
          </button>
          <button class="mobile-btn btn-danger" @click="handleGiveUp">
            放弃
          </button>
        </div>
      </template>
    </div>

    <!-- 规则说明弹窗 -->
    <div class="mobile-modal" v-if="bankStore.showRules" @click.self="bankStore.showRules = false">
      <div class="mobile-modal-content">
        <div class="mobile-modal-header">
          <h3>游戏规则</h3>
          <button class="modal-close" @click="bankStore.showRules = false">×</button>
        </div>
        <div class="mobile-modal-body">
          <div class="rule-section">
            <h4>牌面价值</h4>
            <div class="value-grid">
              <div class="value-item"><span class="cards">5-10</span><span class="value">100</span></div>
              <div class="value-item"><span class="cards">J,Q,K</span><span class="value">500</span></div>
              <div class="value-item"><span class="cards">A</span><span class="value">1000</span></div>
              <div class="value-item"><span class="cards">2</span><span class="value">2000</span></div>
              <div class="value-item"><span class="cards">3</span><span class="value">3000</span></div>
              <div class="value-item"><span class="cards">4</span><span class="value">4000</span></div>
              <div class="value-item"><span class="cards">小王</span><span class="value">5000</span></div>
              <div class="value-item"><span class="cards">大王</span><span class="value">10000</span></div>
            </div>
          </div>
          <div class="rule-section">
            <h4>游戏流程</h4>
            <ol>
              <li>每人初始5张手牌</li>
              <li>当前玩家摸牌</li>
              <li>下家支付等额金额</li>
              <li>可组合多张牌支付</li>
              <li>无法支付者出局</li>
            </ol>
          </div>
        </div>
      </div>
    </div>

    <!-- 游戏设置弹窗 -->
    <div class="mobile-modal" v-if="showSetup" @click.self="preventClose">
      <div class="mobile-modal-content">
        <div class="mobile-modal-header">
          <h3>开始游戏</h3>
        </div>
        <div class="mobile-modal-body">
          <div class="setup-option">
            <label>玩家数量</label>
            <div class="player-count-selector">
              <button :class="{ active: setupPlayerCount === 2 }" @click="setupPlayerCount = 2">2人</button>
              <button :class="{ active: setupPlayerCount === 3 }" @click="setupPlayerCount = 3">3人</button>
            </div>
          </div>
          <button class="mobile-btn btn-primary btn-full" @click="startGame">开始游戏</button>
        </div>
      </div>
    </div>

    <!-- 游戏结束弹窗 -->
    <div class="mobile-modal" v-if="bankStore.gamePhase === 'gameOver'" @click.self="preventClose">
      <div class="mobile-modal-content game-over">
        <div class="game-over-header">
          <div class="winner-icon">👑</div>
          <h3>游戏结束</h3>
          <div class="winner-name">{{ getWinnerText() }}</div>
        </div>
        <div class="mobile-modal-body">
          <div class="final-rankings">
            <div v-for="(player, index) in getSortedPlayers()" :key="player.id" class="rank-item" :class="{
              'is-winner': !player.isOut && player.totalValue === getMaxValue()
            }">
              <span class="rank-num">{{ index + 1 }}</span>
              <span class="rank-name">{{ player.name }}</span>
              <span class="rank-score">{{ player.isOut ? '出局' : player.totalValue }}</span>
            </div>
          </div>
          <div class="game-over-actions">
            <button class="mobile-btn btn-primary" @click="restartGame">重新开始</button>
            <button class="mobile-btn btn-secondary" @click="backToMenu">返回菜单</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, computed, onMounted } from 'vue'
import bankGameStore from '../store/bankGameStore.js'
import { Suit, SUIT_NAMES, RANK_NAMES } from '../utils/constants.js'

export default {
  name: 'BankGameMobile',
  emits: ['back-to-menu'],
  setup(props, { emit }) {
    const bankStore = bankGameStore
    const showSetup = ref(true)
    const setupPlayerCount = ref(2)

    // 计算属性
    const currentPlayerIndex = computed(() => bankStore.currentPlayerIndex)
    const isPlayerTurn = computed(() => {
      return bankStore.gamePhase === 'playing' &&
        bankStore.players.length > 0 &&
        !bankStore.players[0].isOut &&
        bankStore.getCurrentPlayer().id === 'player'
    })

    const isPayingPhase = computed(() => bankStore.gamePhase === 'paying')

    const isAIThinking = computed(() => {
      const currentPlayer = bankStore.getCurrentPlayer()
      const payer = bankStore.getNextActivePlayer()
      return (bankStore.gamePhase === 'playing' && currentPlayer?.isAI) ||
        (bankStore.gamePhase === 'paying' && payer?.isAI)
    })

    const playerHand = computed(() => {
      if (bankStore.players.length === 0) return []
      return bankStore.players[0].hand
    })

    const statusText = computed(() => {
      if (bankStore.gamePhase === 'menu') return '等待'
      if (bankStore.gamePhase === 'gameOver') return '结束'
      if (bankStore.gamePhase === 'paying') {
        const payer = bankStore.getNextActivePlayer()
        return payer?.isAI ? 'AI支付' : '请支付'
      }
      return isPlayerTurn.value ? '你的回合' : 'AI回合'
    })

    const recentLogs = computed(() => {
      return bankStore.logs.slice(0, 5)
    })

    // 方法
    const getPlayerInitial = (player) => {
      return player.name.charAt(0)
    }

    const getPayer = () => {
      const payerIndex = bankStore.getNextActivePlayerIndex()
      return bankStore.players[payerIndex]
    }

    const getPayerIndex = () => {
      return bankStore.getNextActivePlayerIndex()
    }

    const getCurrentPlayer = () => {
      return bankStore.getCurrentPlayer()
    }

    const getHandValue = (player) => {
      return player.hand.reduce((sum, card) => bankStore.getCardValue(card), 0)
    }

    const getCardValue = (card) => {
      return bankStore.getCardValue(card)
    }

    const getCardColorClass = (card) => {
      if (card.suit === Suit.JOKER) return 'card-joker'
      return card.color === 'red' ? 'card-red' : 'card-black'
    }

    const getCardDisplayRank = (card) => {
      if (card.suit === Suit.JOKER) {
        return card.rank === 'SMALL_JOKER' ? '小' : '大'
      }
      return RANK_NAMES[card.rank] || card.rank
    }

    const getSuitSymbol = (suit) => {
      return SUIT_NAMES[suit] || suit
    }

    const handleCardClick = (card) => {
      if (!isPayingPhase.value || getPayer().isAI) return
      if (bankStore.players[0].isOut) return
      bankStore.togglePaymentCard(card)
    }

    const handleDraw = () => {
      if (!isPlayerTurn.value) return
      bankStore.drawCard()
    }

    const handleConfirmPayment = () => {
      if (!bankStore.canPay()) return
      bankStore.confirmPayment()
    }

    const handleResetSelection = () => {
      bankStore.selectedPaymentCards = []
    }

    const handleGiveUp = () => {
      bankStore.giveUp()
    }

    const startGame = () => {
      showSetup.value = false
      bankStore.initGame(setupPlayerCount.value)
    }

    const restartGame = () => {
      bankStore.restart()
    }

    const backToMenu = () => {
      bankStore.backToMenu()
      showSetup.value = true
      emit('back-to-menu')
    }

    const preventClose = () => {
      // 阻止关闭
    }

    const getWinnerText = () => {
      const winners = bankStore.getWinners()
      if (winners.length === 0) return '无'
      if (winners.length === 1) return winners[0].name + ' 获胜'
      return winners.map(w => w.name).join(', ') + ' 平局'
    }

    const getSortedPlayers = () => {
      return [...bankStore.players].sort((a, b) => {
        if (a.isOut && !b.isOut) return 1
        if (!a.isOut && b.isOut) return -1
        if (a.isOut && b.isOut) return 0
        return b.totalValue - a.totalValue
      })
    }

    const getMaxValue = () => {
      const activePlayers = bankStore.players.filter(p => !p.isOut)
      if (activePlayers.length === 0) return 0
      return Math.max(...activePlayers.map(p => p.totalValue))
    }

    onMounted(() => {
      if (bankStore.gamePhase === 'menu') {
        showSetup.value = true
      }
    })

    return {
      bankStore,
      showSetup,
      setupPlayerCount,
      currentPlayerIndex,
      isPlayerTurn,
      isPayingPhase,
      isAIThinking,
      playerHand,
      statusText,
      recentLogs,
      getPlayerInitial,
      getPayer,
      getPayerIndex,
      getCurrentPlayer,
      getHandValue,
      getCardValue,
      getCardColorClass,
      getCardDisplayRank,
      getSuitSymbol,
      handleCardClick,
      handleDraw,
      handleConfirmPayment,
      handleResetSelection,
      handleGiveUp,
      startGame,
      restartGame,
      backToMenu,
      preventClose,
      getWinnerText,
      getSortedPlayers,
      getMaxValue,
    }
  }
}
</script>

<style scoped>
.bank-game-mobile {
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
  color: #fff;
  overflow: hidden;
}

/* 顶部导航 */
.mobile-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: rgba(0, 0, 0, 0.3);
}

.mobile-back-btn,
.mobile-rules-btn {
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  border-radius: 50%;
  color: #fff;
  font-size: 18px;
  cursor: pointer;
}

.mobile-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 16px;
  font-weight: bold;
}

.title-icon {
  font-size: 20px;
}

/* 状态栏 */
.mobile-status-bar {
  display: flex;
  justify-content: space-around;
  padding: 8px 16px;
  background: rgba(0, 0, 0, 0.2);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.status-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

.status-label {
  font-size: 10px;
  color: rgba(255, 255, 255, 0.6);
}

.status-value {
  font-size: 14px;
  font-weight: bold;
  color: #ffd700;
}

.status-value.payment {
  color: #ff6b6b;
}

.status-value.is-active {
  color: #4ade80;
}

/* 玩家信息区 */
.mobile-players {
  display: flex;
  justify-content: center;
  gap: 12px;
  padding: 12px 16px;
  flex-wrap: wrap;
}

.mobile-player-chip {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 20px;
  border: 2px solid transparent;
}

.mobile-player-chip.is-me {
  background: rgba(74, 222, 128, 0.2);
}

.mobile-player-chip.is-current {
  border-color: #ffd700;
  box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
}

.mobile-player-chip.is-out {
  opacity: 0.5;
  background: rgba(255, 0, 0, 0.1);
}

.mobile-player-chip.is-paying {
  border-color: #ff6b6b;
  animation: pulse-red 1s infinite;
}

@keyframes pulse-red {

  0%,
  100% {
    box-shadow: 0 0 0 rgba(255, 107, 107, 0);
  }

  50% {
    box-shadow: 0 0 8px rgba(255, 107, 107, 0.5);
  }
}

.player-avatar {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
}

.player-info {
  display: flex;
  flex-direction: column;
}

.player-name {
  font-size: 12px;
  font-weight: bold;
}

.player-cards {
  font-size: 10px;
  color: rgba(255, 255, 255, 0.7);
}

.player-value {
  font-size: 11px;
  color: #ffd700;
  font-weight: bold;
}

/* 中央游戏区 */
.mobile-game-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 16px;
  gap: 16px;
}

/* 当前摸牌显示 */
.drawn-card-display {
  text-align: center;
}

.drawn-label {
  font-size: 14px;
  color: rgba(255, 255, 255, 0.7);
  margin-bottom: 12px;
}

.drawn-card-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.drawn-value {
  font-size: 16px;
  font-weight: bold;
  color: #ffd700;
}

/* 牌堆区域 */
.piles-area {
  display: flex;
  gap: 40px;
}

.pile-item {
  text-align: center;
}

.pile-card {
  width: 60px;
  height: 84px;
  margin: 0 auto 8px;
}

.card-back {
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 6px;
  border: 2px solid rgba(255, 255, 255, 0.3);
}

.discard-back {
  background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
}

.pile-label {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.7);
}

/* 支付信息 */
.payment-info {
  text-align: center;
  padding: 12px 24px;
  background: rgba(255, 107, 107, 0.2);
  border-radius: 8px;
  border: 1px solid rgba(255, 107, 107, 0.5);
}

.payment-title {
  font-size: 16px;
  font-weight: bold;
  color: #ff6b6b;
  margin-bottom: 4px;
}

.payment-selected {
  font-size: 14px;
  color: rgba(255, 255, 255, 0.8);
}

.payment-diff {
  color: #ffd700;
}

/* AI思考 */
.ai-thinking {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 20px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 20px;
  font-size: 14px;
}

.thinking-spinner {
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top-color: #ffd700;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* 日志 */
.mobile-logs {
  padding: 8px 16px;
  max-height: 80px;
  overflow-y: auto;
}

.log-item {
  font-size: 11px;
  color: rgba(255, 255, 255, 0.6);
  padding: 2px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

/* 手牌区域 */
.mobile-hand {
  padding: 12px 16px;
  background: rgba(0, 0, 0, 0.3);
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.hand-label {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.7);
  margin-bottom: 8px;
}

.hand-cards-scroll {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  padding-bottom: 8px;
  scrollbar-width: none;
}

.hand-cards-scroll::-webkit-scrollbar {
  display: none;
}

/* 扑克牌 */
.playing-card {
  position: relative;
  flex-shrink: 0;
  width: 50px;
  height: 70px;
  background: #fff;
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 3px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  cursor: pointer;
  transition: all 0.2s;
  user-select: none;
}

.playing-card.is-selected {
  transform: translateY(-8px);
  box-shadow: 0 0 0 2px #ffd700, 0 4px 12px rgba(0, 0, 0, 0.4);
}

.playing-card.is-disabled {
  cursor: not-allowed;
  opacity: 0.8;
}

.card-red {
  color: #e74c3c;
}

.card-black {
  color: #2c3e50;
}

.card-joker {
  color: #9b59b6;
  background: linear-gradient(135deg, #fff 0%, #f0e6f7 100%);
}

.card-corner {
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 8px;
  font-weight: bold;
  line-height: 1;
}

.card-corner.bottom {
  transform: rotate(180deg);
}

.card-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 20px;
}

.card-value-badge {
  position: absolute;
  top: -6px;
  right: -6px;
  background: #ffd700;
  color: #000;
  font-size: 8px;
  font-weight: bold;
  padding: 1px 4px;
  border-radius: 8px;
}

/* 操作按钮 */
.mobile-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 12px 16px;
  background: rgba(0, 0, 0, 0.3);
}

.action-row {
  display: flex;
  gap: 8px;
}

.mobile-btn {
  padding: 12px 20px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s;
}

.mobile-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-primary {
  background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);
  color: #000;
}

.btn-secondary {
  flex: 1;
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.3);
}

.btn-danger {
  flex: 1;
  background: rgba(255, 107, 107, 0.2);
  color: #ff6b6b;
  border: 1px solid rgba(255, 107, 107, 0.5);
}

.btn-full {
  width: 100%;
}

/* 弹窗 */
.mobile-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 16px;
}

.mobile-modal-content {
  width: 100%;
  max-width: 360px;
  max-height: 80vh;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border-radius: 16px;
  overflow: hidden;
}

.mobile-modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.mobile-modal-header h3 {
  margin: 0;
  font-size: 16px;
}

.modal-close {
  width: 28px;
  height: 28px;
  border: none;
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  font-size: 18px;
  border-radius: 50%;
  cursor: pointer;
}

.mobile-modal-body {
  padding: 20px;
  overflow-y: auto;
  max-height: 60vh;
}

/* 规则弹窗内容 */
.rule-section {
  margin-bottom: 20px;
}

.rule-section h4 {
  font-size: 14px;
  color: #ffd700;
  margin-bottom: 12px;
}

.value-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.value-item {
  display: flex;
  justify-content: space-between;
  padding: 8px 12px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  font-size: 12px;
}

.value-item .cards {
  color: rgba(255, 255, 255, 0.8);
}

.value-item .value {
  color: #ffd700;
  font-weight: bold;
}

.rule-section ol {
  margin: 0;
  padding-left: 16px;
  font-size: 12px;
  line-height: 1.8;
  color: rgba(255, 255, 255, 0.8);
}

/* 设置弹窗 */
.setup-option {
  margin-bottom: 20px;
}

.setup-option label {
  display: block;
  font-size: 14px;
  color: rgba(255, 255, 255, 0.8);
  margin-bottom: 12px;
}

.player-count-selector {
  display: flex;
  gap: 12px;
}

.player-count-selector button {
  flex: 1;
  padding: 12px;
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid transparent;
  border-radius: 8px;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
}

.player-count-selector button.active {
  background: rgba(255, 215, 0, 0.2);
  border-color: #ffd700;
  color: #ffd700;
}

/* 游戏结束弹窗 */
.game-over {
  text-align: center;
}

.game-over-header {
  padding: 24px 20px;
  background: rgba(255, 215, 0, 0.1);
}

.winner-icon {
  font-size: 40px;
  margin-bottom: 8px;
}

.game-over-header h3 {
  margin: 0 0 8px;
  font-size: 14px;
  color: rgba(255, 255, 255, 0.7);
}

.winner-name {
  font-size: 20px;
  font-weight: bold;
  color: #ffd700;
}

.final-rankings {
  margin: 20px 0;
}

.rank-item {
  display: flex;
  align-items: center;
  padding: 10px 12px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  margin-bottom: 8px;
}

.rank-item.is-winner {
  background: rgba(255, 215, 0, 0.2);
  border: 1px solid rgba(255, 215, 0, 0.5);
}

.rank-num {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  font-size: 12px;
  font-weight: bold;
  margin-right: 12px;
}

.rank-item.is-winner .rank-num {
  background: #ffd700;
  color: #000;
}

.rank-name {
  flex: 1;
  font-size: 14px;
  text-align: left;
}

.rank-score {
  font-size: 14px;
  color: rgba(255, 255, 255, 0.7);
}

.game-over-actions {
  display: flex;
  gap: 12px;
}

.game-over-actions .mobile-btn {
  flex: 1;
}
</style>

--- src/components/BankGamePC.vue ---
<template>
  <div class="bank-game">
    <!-- 顶部区域 -->
    <header class="header">
      <div class="header-left">
        <div class="logo">
          <span class="logo-icon">🏦</span>
          <span class="logo-text">扑克抢银行</span>
        </div>
        <button class="rules-btn" @click="bankStore.showRules = true">
          <span class="rules-icon">?</span>
          <span class="rules-text">规则说明</span>
        </button>
      </div>

      <div class="header-center">
        <div class="stat-block">
          <div class="stat-label">牌堆剩余</div>
          <div class="stat-value">{{ bankStore.deckRemaining }}张</div>
        </div>
        <div class="stat-block" v-if="bankStore.requiredPayment > 0">
          <div class="stat-label">需支付</div>
          <div class="stat-value payment-value">{{ bankStore.requiredPayment }}</div>
        </div>
      </div>

      <div class="header-right">
        <button class="home-btn" @click="backToMenu">
          <span class="home-icon">⌂</span>
          <span class="home-text">首页</span>
        </button>
        <div class="status-indicator">
          <span class="status-dot" :class="{ 'is-active': isPlayerTurn }"></span>
          {{ statusText }}
        </div>
      </div>
    </header>

    <!-- 主游戏区域 -->
    <div class="main-container">
      <!-- 左侧玩家信息 -->
      <aside class="sidebar">
        <div class="sidebar-title">
          <span class="title-line"></span>
          玩家信息
        </div>

        <div class="player-list">
          <div v-for="(player, index) in bankStore.players" :key="player.id" class="player-card" :class="{
            'is-me': !player.isAI,
            'is-current': currentPlayerIndex === index,
            'is-out': player.isOut,
            'is-paying': isPayingPhase && getPayerIndex() === index
          }">
            <div class="player-info">
              <div class="player-avatar">{{ getPlayerInitial(player, index) }}</div>
              <div class="player-detail">
                <div class="player-name">{{ player.name }}</div>
                <div class="player-status">
                  {{ player.isOut ? '已出局' : !player.isAI ? '我' : 'CPU' }}
                </div>
              </div>
            </div>
            <div class="player-cards">
              <span class="card-count">{{ player.hand.length }}张</span>
              <span v-if="!player.isOut" class="hand-value">
                价值: {{ getHandValue(player) }}
              </span>
            </div>
          </div>
        </div>
      </aside>

      <!-- 中央游戏区域 -->
      <main class="game-board">
        <!-- 其他玩家区域 (上方) -->
        <div class="opponents-area">
          <div v-for="(player, index) in cpuPlayers" :key="player.id" class="opponent" :class="{
            'is-current': isCurrentPlayer(player.id),
            'is-out': player.isOut,
            'is-paying': isPayingPhase && getPayerIndex() === getPlayerIndex(player.id)
          }">
            <div class="opponent-avatar">{{ getPlayerInitial(player, getPlayerIndex(player)) }}</div>
            <div class="opponent-name">{{ player.name }}</div>
            <div class="opponent-cards">{{ player.isOut ? '出局' : player.hand.length + '张' }}</div>
          </div>
        </div>

        <!-- 中央公共区域 -->
        <div class="center-area">
          <!-- 牌堆 -->
          <div class="deck-section">
            <div class="deck-label">牌堆</div>
            <div class="deck-count">{{ bankStore.deckRemaining }}张</div>
            <div class="card-stack deck-stack">
              <div v-if="bankStore.deckRemaining > 0" class="stacked-card deck-card">
                <div class="card-back"></div>
              </div>
              <div v-else class="empty-pile">空</div>
            </div>
          </div>

          <!-- 当前摸到的牌 -->
          <div class="drawn-card-section" v-if="bankStore.currentDrawnCard">
            <div class="drawn-label">当前摸牌</div>
            <div class="drawn-value">价值: {{ getCardValue(bankStore.currentDrawnCard) }}</div>
            <div class="playing-card" :class="getCardColorClass(bankStore.currentDrawnCard)">
              <div class="card-corner top">
                <span>{{ getCardDisplayRank(bankStore.currentDrawnCard) }}</span>
                <span>{{ getSuitSymbol(bankStore.currentDrawnCard.suit) }}</span>
              </div>
              <div class="card-center">{{ getSuitSymbol(bankStore.currentDrawnCard.suit) }}</div>
              <div class="card-corner bottom">
                <span>{{ getCardDisplayRank(bankStore.currentDrawnCard) }}</span>
                <span>{{ getSuitSymbol(bankStore.currentDrawnCard.suit) }}</span>
              </div>
            </div>
          </div>

          <!-- 弃牌区 -->
          <div class="discard-section">
            <div class="discard-label">弃牌区</div>
            <div class="discard-count">{{ bankStore.discardPile.length }}张</div>
            <div class="card-stack discard-stack">
              <div v-for="(card, index) in displayDiscardCards" :key="index" class="stacked-card discard-card"
                :style="getStackedCardStyle(index)">
                <div class="card-back"></div>
              </div>
              <div v-if="bankStore.discardPile.length === 0" class="empty-pile">空</div>
            </div>
          </div>
        </div>

        <!-- 支付提示 -->
        <div v-if="isPayingPhase && !getPayer().isAI" class="payment-prompt">
          <div class="payment-title">需要支付 {{ bankStore.requiredPayment }}</div>
          <div class="payment-subtitle">
            已选: {{ bankStore.getSelectedTotalValue() }}
            <span v-if="bankStore.getSelectedTotalValue() !== bankStore.requiredPayment" class="payment-hint">
              ({{ bankStore.getSelectedTotalValue() > bankStore.requiredPayment ? '超出' : '不足' }})
            </span>
          </div>
        </div>

        <!-- AI思考提示 -->
        <div v-if="isAIThinking" class="thinking-indicator">
          <span class="thinking-text">{{ getCurrentPlayer().name }} 正在思考...</span>
          <span class="thinking-dots">...</span>
        </div>
      </main>

      <!-- 右侧日志 -->
      <aside class="sidebar sidebar-right">
        <div class="sidebar-title">
          <span class="title-line"></span>
          游戏日志
        </div>
        <div class="log-list">
          <div v-for="(log, index) in bankStore.logs" :key="index" class="log-entry">
            {{ log }}
          </div>
        </div>
      </aside>
    </div>

    <!-- 底部手牌区域 -->
    <div class="hand-area" v-if="playerHand.length > 0 && !bankStore.players[0].isOut">
      <div class="hand-header">
        <div class="hand-header-left">
          <span class="hand-title">我的手牌</span>
          <span class="hand-count">剩余 {{ playerHand.length }} 张</span>
        </div>
        <div class="hand-header-right">
          <span v-if="isPayingPhase && !getPayer().isAI" class="selected-info">
            已选 {{ bankStore.selectedPaymentCards.length }} 张，总计 {{ bankStore.getSelectedTotalValue() }}
          </span>
        </div>
      </div>

      <div class="hand-cards">
        <div v-for="(card, index) in playerHand" :key="index" class="playing-card" :class="[
          getCardColorClass(card),
          {
            'is-selected': isPayingPhase && bankStore.isCardSelected(card),
            'is-disabled': !isPayingPhase || getPayer().isAI
          }
        ]" @click="handleCardClick(card)">
          <div class="card-value-badge">{{ getCardValue(card) }}</div>
          <div class="card-corner top">
            <span>{{ getCardDisplayRank(card) }}</span>
            <span>{{ getSuitSymbol(card.suit) }}</span>
          </div>
          <div class="card-center">{{ getSuitSymbol(card.suit) }}</div>
          <div class="card-corner bottom">
            <span>{{ getCardDisplayRank(card) }}</span>
            <span>{{ getSuitSymbol(card.suit) }}</span>
          </div>
        </div>
      </div>

      <!-- 操作按钮区 -->
      <div class="hand-actions" v-if="isPlayerTurn || (isPayingPhase && !getPayer().isAI)">
        <!-- 摸牌按钮 -->
        <button v-if="isPlayerTurn && bankStore.gamePhase === 'playing'" class="btn btn-highlight"
          @click="handleDraw">
          摸牌
        </button>

        <!-- 支付阶段按钮 -->
        <template v-if="isPayingPhase && !getPayer().isAI">
          <button class="btn btn-highlight" :disabled="!bankStore.canPay()" @click="handleConfirmPayment">
            确认支付
          </button>
          <button class="btn btn-secondary" @click="handleResetSelection">
            重置选择
          </button>
          <button class="btn btn-danger" @click="handleGiveUp">
            放弃 (出局)
          </button>
        </template>
      </div>
    </div>

    <!-- 规则说明弹窗 -->
    <div class="rules-modal" v-if="bankStore.showRules" @click.self="bankStore.showRules = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>游戏规则</h2>
          <button class="rules-close" @click="bankStore.showRules = false">×</button>
        </div>
        <div class="rules-body">
          <div class="rules-section">
            <h3>游戏目标</h3>
            <p>游戏结束时，手牌总金额最高的玩家获胜。</p>
          </div>

          <div class="rules-section">
            <h3>牌面价值</h3>
            <ul class="value-list">
              <li><span class="card-example">5-10</span> = 100</li>
              <li><span class="card-example">J, Q, K</span> = 500</li>
              <li><span class="card-example">A</span> = 1000</li>
              <li><span class="card-example">2</span> = 2000</li>
              <li><span class="card-example">3</span> = 3000</li>
              <li><span class="card-example">4</span> = 4000</li>
              <li><span class="card-example">小王</span> = 5000</li>
              <li><span class="card-example">大王</span> = 10000</li>
            </ul>
          </div>

          <div class="rules-section">
            <h3>游戏流程</h3>
            <ol>
              <li>每位玩家初始获得5张手牌</li>
              <li>当前玩家从牌堆摸一张牌</li>
              <li>下家必须支付等同于摸牌金额的牌</li>
              <li>允许使用多张牌组合支付</li>
              <li>无法支付者出局</li>
              <li>支付成功者成为新的摸牌玩家</li>
            </ol>
          </div>

          <div class="rules-section">
            <h3>结束条件</h3>
            <ul>
              <li>牌堆抽空且最后一次支付完成</li>
              <li>仅剩一名玩家存活</li>
            </ul>
            <p>结算时，手牌总金额最高者获胜。</p>
          </div>
        </div>
      </div>
    </div>

    <!-- 游戏设置弹窗 -->
    <div class="rules-modal" v-if="showSetup" @click.self="showSetup = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>游戏设置</h2>
        </div>
        <div class="rules-body">
          <div class="setup-section">
            <h3>选择玩家数量</h3>
            <div class="player-count-options">
              <button class="count-btn" :class="{ 'is-selected': setupPlayerCount === 2 }"
                @click="setupPlayerCount = 2">
                2人
              </button>
              <button class="count-btn" :class="{ 'is-selected': setupPlayerCount === 3 }"
                @click="setupPlayerCount = 3">
                3人
              </button>
            </div>
          </div>
          <div class="setup-actions">
            <button class="btn btn-highlight" @click="startGame">开始游戏</button>
          </div>
        </div>
      </div>
    </div>

    <!-- 游戏结束弹窗 -->
    <div class="rules-modal" v-if="bankStore.gamePhase === 'gameOver'" @click.self="preventClose">
      <div class="rules-content game-over-content">
        <div class="rules-header">
          <h2>游戏结束</h2>
        </div>
        <div class="rules-body">
          <div class="winner-section">
            <div class="winner-crown">👑</div>
            <div class="winner-title">获胜者</div>
            <div class="winner-name">{{ getWinnerText() }}</div>
          </div>

          <div class="final-standings">
            <h3>最终排名</h3>
            <div class="standings-list">
              <div v-for="(player, index) in getSortedPlayers()" :key="player.id" class="standing-item"
                :class="{ 'is-winner': !player.isOut && player.totalValue === getMaxValue() }">
                <span class="standing-rank">{{ index + 1 }}</span>
                <span class="standing-name">{{ player.name }}</span>
                <span class="standing-value">
                  {{ player.isOut ? '出局' : player.totalValue }}
                </span>
              </div>
            </div>
          </div>

          <div class="game-over-actions">
            <button class="btn btn-highlight" @click="restartGame">重新开始</button>
            <button class="btn btn-secondary" @click="backToMenu">返回菜单</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, computed, onMounted } from 'vue'
import bankGameStore from '../store/bankGameStore.js'
import { Suit, SUIT_NAMES, RANK_NAMES } from '../utils/constants.js'

export default {
  name: 'BankGamePC',
  emits: ['back-to-menu'],
  setup(props, { emit }) {
    const bankStore = bankGameStore
    const showSetup = ref(true)
    const setupPlayerCount = ref(2)

    // 计算属性
    const currentPlayerIndex = computed(() => bankStore.currentPlayerIndex)
    const isPlayerTurn = computed(() => {
      return bankStore.gamePhase === 'playing' &&
        bankStore.players.length > 0 &&
        !bankStore.players[0].isOut &&
        bankStore.getCurrentPlayer().id === 'player'
    })

    const isPayingPhase = computed(() => bankStore.gamePhase === 'paying')

    const isAIThinking = computed(() => {
      const currentPlayer = bankStore.getCurrentPlayer()
      const payer = bankStore.getNextActivePlayer()
      return (bankStore.gamePhase === 'playing' && currentPlayer?.isAI) ||
        (bankStore.gamePhase === 'paying' && payer?.isAI)
    })

    const playerHand = computed(() => {
      if (bankStore.players.length === 0) return []
      return bankStore.players[0].hand
    })

    const cpuPlayers = computed(() => {
      return bankStore.players.filter(p => p.isAI)
    })

    const statusText = computed(() => {
      if (bankStore.gamePhase === 'menu') return '等待开始'
      if (bankStore.gamePhase === 'gameOver') return '游戏结束'
      if (bankStore.gamePhase === 'paying') {
        const payer = bankStore.getNextActivePlayer()
        return `${payer.name} 支付中`
      }
      const currentPlayer = bankStore.getCurrentPlayer()
      return currentPlayer?.isAI ? `${currentPlayer.name} 思考中` : '你的回合'
    })

    const displayDiscardCards = computed(() => {
      return bankStore.discardPile.slice(-5)
    })

    // 方法
    const getPlayerInitial = (player, index) => {
      return player.name.charAt(0)
    }

    const getPlayerIndex = (player) => {
      return bankStore.players.findIndex(p => p.id === player.id)
    }

    const isCurrentPlayer = (playerId) => {
      const currentPlayer = bankStore.getCurrentPlayer()
      return currentPlayer?.id === playerId
    }

    const getPayer = () => {
      const payerIndex = bankStore.getNextActivePlayerIndex()
      return bankStore.players[payerIndex]
    }

    const getPayerIndex = () => {
      return bankStore.getNextActivePlayerIndex()
    }

    const getHandValue = (player) => {
      return player.hand.reduce((sum, card) => bankStore.getCardValue(card), 0)
    }

    const getCardValue = (card) => {
      return bankStore.getCardValue(card)
    }

    const getCardColorClass = (card) => {
      if (card.suit === Suit.JOKER) return 'card-joker'
      return card.color === 'red' ? 'card-red' : 'card-black'
    }

    const getCardDisplayRank = (card) => {
      if (card.suit === Suit.JOKER) {
        return card.rank === 'SMALL_JOKER' ? '小' : '大'
      }
      return RANK_NAMES[card.rank] || card.rank
    }

    const getSuitSymbol = (suit) => {
      return SUIT_NAMES[suit] || suit
    }

    const getStackedCardStyle = (index) => {
      return {
        transform: `translateY(${-index * 2}px)`,
        zIndex: index
      }
    }

    const handleCardClick = (card) => {
      if (!isPayingPhase.value || getPayer().isAI) return
      if (bankStore.players[0].isOut) return
      bankStore.togglePaymentCard(card)
    }

    const handleDraw = () => {
      if (!isPlayerTurn.value) return
      bankStore.drawCard()
    }

    const handleConfirmPayment = () => {
      if (!bankStore.canPay()) return
      bankStore.confirmPayment()
    }

    const handleResetSelection = () => {
      bankStore.selectedPaymentCards = []
    }

    const handleGiveUp = () => {
      bankStore.giveUp()
    }

    const startGame = () => {
      showSetup.value = false
      bankStore.initGame(setupPlayerCount.value)
    }

    const restartGame = () => {
      bankStore.restart()
    }

    const backToMenu = () => {
      bankStore.backToMenu()
      showSetup.value = true
      emit('back-to-menu')
    }

    const preventClose = () => {
      // 游戏结束时阻止点击背景关闭
    }

    const getWinnerText = () => {
      const winners = bankStore.getWinners()
      if (winners.length === 0) return '无'
      if (winners.length === 1) return winners[0].name
      return winners.map(w => w.name).join(', ')
    }

    const getSortedPlayers = () => {
      return [...bankStore.players].sort((a, b) => {
        if (a.isOut && !b.isOut) return 1
        if (!a.isOut && b.isOut) return -1
        if (a.isOut && b.isOut) return 0
        return b.totalValue - a.totalValue
      })
    }

    const getMaxValue = () => {
      const activePlayers = bankStore.players.filter(p => !p.isOut)
      if (activePlayers.length === 0) return 0
      return Math.max(...activePlayers.map(p => p.totalValue))
    }

    onMounted(() => {
      if (bankStore.gamePhase === 'menu') {
        showSetup.value = true
      }
    })

    // 获取当前玩家（供模板使用）
    const getCurrentPlayer = () => {
      return bankStore.getCurrentPlayer()
    }

    return {
      bankStore,
      showSetup,
      setupPlayerCount,
      currentPlayerIndex,
      isPlayerTurn,
      isPayingPhase,
      isAIThinking,
      playerHand,
      cpuPlayers,
      statusText,
      displayDiscardCards,
      getPlayerInitial,
      getPlayerIndex,
      isCurrentPlayer,
      getCurrentPlayer,
      getPayer,
      getPayerIndex,
      getHandValue,
      getCardValue,
      getCardColorClass,
      getCardDisplayRank,
      getSuitSymbol,
      getStackedCardStyle,
      handleCardClick,
      handleDraw,
      handleConfirmPayment,
      handleResetSelection,
      handleGiveUp,
      startGame,
      restartGame,
      backToMenu,
      preventClose,
      getWinnerText,
      getSortedPlayers,
      getMaxValue,
    }
  }
}
</script>

<style scoped>
.bank-game {
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
  color: #fff;
  overflow: hidden;
}

/* 顶部导航 */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 24px;
  background: rgba(0, 0, 0, 0.3);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.header-left,
.header-right {
  display: flex;
  align-items: center;
  gap: 16px;
}

.header-center {
  display: flex;
  gap: 32px;
}

.logo {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 20px;
  font-weight: bold;
}

.logo-icon {
  font-size: 24px;
}

.rules-btn,
.home-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 6px;
  color: #fff;
  cursor: pointer;
  transition: all 0.2s;
}

.rules-btn:hover,
.home-btn:hover {
  background: rgba(255, 255, 255, 0.2);
}

.stat-block {
  text-align: center;
}

.stat-label {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
  margin-bottom: 4px;
}

.stat-value {
  font-size: 20px;
  font-weight: bold;
  color: #ffd700;
}

.payment-value {
  color: #ff6b6b;
  animation: pulse 1s infinite;
}

@keyframes pulse {

  0%,
  100% {
    opacity: 1;
  }

  50% {
    opacity: 0.7;
  }
}

.status-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: rgba(255, 255, 255, 0.8);
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #666;
}

.status-dot.is-active {
  background: #4ade80;
  box-shadow: 0 0 8px #4ade80;
}

/* 主容器 */
.main-container {
  flex: 1;
  display: flex;
  overflow: hidden;
}

/* 侧边栏 */
.sidebar {
  width: 200px;
  padding: 20px;
  background: rgba(0, 0, 0, 0.2);
  border-right: 1px solid rgba(255, 255, 255, 0.1);
  overflow-y: auto;
}

.sidebar-right {
  border-right: none;
  border-left: 1px solid rgba(255, 255, 255, 0.1);
}

.sidebar-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  font-weight: bold;
  color: rgba(255, 255, 255, 0.8);
  margin-bottom: 16px;
}

.title-line {
  width: 3px;
  height: 16px;
  background: #ffd700;
  border-radius: 2px;
}

/* 玩家列表 */
.player-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.player-card {
  padding: 12px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  border: 2px solid transparent;
  transition: all 0.2s;
}

.player-card.is-me {
  background: rgba(74, 222, 128, 0.1);
  border-color: rgba(74, 222, 128, 0.3);
}

.player-card.is-current {
  border-color: #ffd700;
  box-shadow: 0 0 12px rgba(255, 215, 0, 0.3);
}

.player-card.is-out {
  opacity: 0.5;
  background: rgba(255, 0, 0, 0.1);
}

.player-card.is-paying {
  border-color: #ff6b6b;
  animation: paying-pulse 1s infinite;
}

@keyframes paying-pulse {

  0%,
  100% {
    box-shadow: 0 0 0 rgba(255, 107, 107, 0);
  }

  50% {
    box-shadow: 0 0 12px rgba(255, 107, 107, 0.5);
  }
}

.player-info {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
}

.player-avatar {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 14px;
}

.player-name {
  font-weight: bold;
  font-size: 14px;
}

.player-status {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
}

.player-cards {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: rgba(255, 255, 255, 0.7);
}

.hand-value {
  color: #ffd700;
}

/* 游戏主区域 */
.game-board {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 20px;
  gap: 20px;
}

/* 对手区域 */
.opponents-area {
  display: flex;
  justify-content: center;
  gap: 40px;
}

.opponent {
  text-align: center;
  padding: 16px 24px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  border: 2px solid transparent;
  transition: all 0.2s;
}

.opponent.is-current {
  border-color: #ffd700;
  box-shadow: 0 0 16px rgba(255, 215, 0, 0.3);
}

.opponent.is-out {
  opacity: 0.5;
  background: rgba(255, 0, 0, 0.1);
}

.opponent.is-paying {
  border-color: #ff6b6b;
  animation: paying-pulse 1s infinite;
}

.opponent-avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 18px;
  margin: 0 auto 8px;
}

.opponent-name {
  font-weight: bold;
  margin-bottom: 4px;
}

.opponent-cards {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.7);
}

/* 中央区域 */
.center-area {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 60px;
}

.deck-section,
.drawn-card-section,
.discard-section {
  text-align: center;
}

.deck-label,
.drawn-label,
.discard-label {
  font-size: 14px;
  font-weight: bold;
  margin-bottom: 8px;
  color: rgba(255, 255, 255, 0.8);
}

.deck-count,
.drawn-value,
.discard-count {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
  margin-bottom: 12px;
}

.card-stack {
  position: relative;
  width: 80px;
  height: 112px;
  margin: 0 auto;
}

.stacked-card {
  position: absolute;
  width: 100%;
  height: 100%;
}

.card-back {
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 8px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.empty-pile {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  border: 2px dashed rgba(255, 255, 255, 0.2);
  color: rgba(255, 255, 255, 0.4);
}

/* 扑克牌样式 */
.playing-card {
  position: relative;
  width: 80px;
  height: 112px;
  background: #fff;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  cursor: pointer;
  transition: all 0.2s;
  user-select: none;
}

.playing-card:hover:not(.is-disabled) {
  transform: translateY(-8px);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}

.playing-card.is-selected {
  transform: translateY(-12px);
  box-shadow: 0 0 0 3px #ffd700, 0 8px 24px rgba(0, 0, 0, 0.4);
}

.playing-card.is-disabled {
  cursor: not-allowed;
  opacity: 0.8;
}

.card-red {
  color: #e74c3c;
}

.card-black {
  color: #2c3e50;
}

.card-joker {
  color: #9b59b6;
  background: linear-gradient(135deg, #fff 0%, #f0e6f7 100%);
}

.card-corner {
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 12px;
  font-weight: bold;
  line-height: 1;
}

.card-corner.bottom {
  transform: rotate(180deg);
}

.card-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 32px;
}

.card-value-badge {
  position: absolute;
  top: -8px;
  right: -8px;
  background: #ffd700;
  color: #000;
  font-size: 10px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 10px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

/* 支付提示 */
.payment-prompt {
  text-align: center;
  padding: 16px 32px;
  background: rgba(255, 107, 107, 0.2);
  border: 2px solid rgba(255, 107, 107, 0.5);
  border-radius: 12px;
}

.payment-title {
  font-size: 20px;
  font-weight: bold;
  color: #ff6b6b;
  margin-bottom: 8px;
}

.payment-subtitle {
  font-size: 16px;
  color: rgba(255, 255, 255, 0.8);
}

.payment-hint {
  color: #ffd700;
}

/* 思考指示器 */
.thinking-indicator {
  text-align: center;
  padding: 12px 24px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 8px;
}

.thinking-text {
  color: rgba(255, 255, 255, 0.8);
}

.thinking-dots {
  display: inline-block;
  animation: dots 1.5s infinite;
}

@keyframes dots {

  0%,
  20% {
    content: '.';
  }

  40% {
    content: '..';
  }

  60%,
  100% {
    content: '...';
  }
}

/* 日志 */
.log-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 400px;
  overflow-y: auto;
}

.log-entry {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.7);
  padding: 6px 8px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
  line-height: 1.4;
}

/* 手牌区域 */
.hand-area {
  padding: 20px 24px;
  background: rgba(0, 0, 0, 0.3);
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.hand-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.hand-header-left,
.hand-header-right {
  display: flex;
  align-items: center;
  gap: 12px;
}

.hand-title {
  font-size: 16px;
  font-weight: bold;
}

.hand-count,
.selected-info {
  font-size: 14px;
  color: rgba(255, 255, 255, 0.7);
}

.selected-info {
  color: #ffd700;
}

.hand-cards {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}

/* 操作按钮 */
.hand-actions {
  display: flex;
  justify-content: center;
  gap: 12px;
}

.btn {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s;
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-highlight {
  background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);
  color: #000;
}

.btn-highlight:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
}

.btn-secondary {
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.3);
}

.btn-secondary:hover {
  background: rgba(255, 255, 255, 0.2);
}

.btn-danger {
  background: rgba(255, 107, 107, 0.2);
  color: #ff6b6b;
  border: 1px solid rgba(255, 107, 107, 0.5);
}

.btn-danger:hover {
  background: rgba(255, 107, 107, 0.3);
}

/* 规则弹窗 */
.rules-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.rules-content {
  width: 90%;
  max-width: 600px;
  max-height: 80vh;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border-radius: 16px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  overflow: hidden;
}

.rules-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 24px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.rules-header h2 {
  margin: 0;
  font-size: 20px;
}

.rules-close {
  width: 32px;
  height: 32px;
  border: none;
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  font-size: 20px;
  border-radius: 50%;
  cursor: pointer;
}

.rules-body {
  padding: 24px;
  overflow-y: auto;
  max-height: 60vh;
}

.rules-section {
  margin-bottom: 24px;
}

.rules-section h3 {
  font-size: 16px;
  margin-bottom: 12px;
  color: #ffd700;
}

.rules-section p {
  font-size: 14px;
  line-height: 1.6;
  color: rgba(255, 255, 255, 0.8);
}

.rules-section ol,
.rules-section ul {
  margin: 0;
  padding-left: 20px;
}

.rules-section li {
  font-size: 14px;
  line-height: 1.8;
  color: rgba(255, 255, 255, 0.8);
}

.value-list {
  list-style: none;
  padding: 0;
}

.value-list li {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.card-example {
  display: inline-block;
  padding: 4px 12px;
  background: rgba(255, 215, 0, 0.2);
  border: 1px solid rgba(255, 215, 0, 0.5);
  border-radius: 4px;
  font-weight: bold;
  color: #ffd700;
  min-width: 80px;
  text-align: center;
}

/* 设置弹窗 */
.setup-section {
  text-align: center;
  margin-bottom: 24px;
}

.setup-section h3 {
  font-size: 16px;
  margin-bottom: 16px;
  color: rgba(255, 255, 255, 0.8);
}

.player-count-options {
  display: flex;
  justify-content: center;
  gap: 16px;
}

.count-btn {
  padding: 16px 32px;
  font-size: 18px;
  font-weight: bold;
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  transition: all 0.2s;
}

.count-btn.is-selected {
  background: rgba(255, 215, 0, 0.2);
  border-color: #ffd700;
  color: #ffd700;
}

.setup-actions {
  text-align: center;
}

/* 游戏结束弹窗 */
.game-over-content {
  max-width: 500px;
}

.winner-section {
  text-align: center;
  padding: 24px;
  background: rgba(255, 215, 0, 0.1);
  border-radius: 12px;
  margin-bottom: 24px;
}

.winner-crown {
  font-size: 48px;
  margin-bottom: 8px;
}

.winner-title {
  font-size: 14px;
  color: rgba(255, 255, 255, 0.7);
  margin-bottom: 8px;
}

.winner-name {
  font-size: 24px;
  font-weight: bold;
  color: #ffd700;
}

.final-standings {
  margin-bottom: 24px;
}

.final-standings h3 {
  font-size: 16px;
  margin-bottom: 16px;
  color: rgba(255, 255, 255, 0.8);
}

.standings-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.standing-item {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.standing-item.is-winner {
  background: rgba(255, 215, 0, 0.2);
  border: 1px solid rgba(255, 215, 0, 0.5);
}

.standing-rank {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  font-weight: bold;
  margin-right: 12px;
}

.standing-item.is-winner .standing-rank {
  background: #ffd700;
  color: #000;
}

.standing-name {
  flex: 1;
  font-weight: bold;
}

.standing-value {
  color: rgba(255, 255, 255, 0.7);
}

.game-over-actions {
  display: flex;
  justify-content: center;
  gap: 16px;
}
</style>

--- src/components/BluffGame.vue ---
<template>
  <div class="bluff-game">
    <!-- 顶部区域 -->
    <header class="header">
      <div class="header-left">
        <div class="logo">
          <span class="logo-icon">🎴</span>
          <span class="logo-text">吹牛皮</span>
        </div>
        <button class="rules-btn" @click="bluffStore.showRules = true">
          <span class="rules-icon">?</span>
          <span class="rules-text">规则说明</span>
        </button>
      </div>

      <div class="header-center">
        <div class="stat-block">
          <div class="stat-label">当前点数</div>
          <div class="stat-value">{{ bluffStore.currentRank || '-' }}</div>
        </div>
        <div class="stat-block">
          <div class="stat-label">牌堆总数</div>
          <div class="stat-value">{{ totalPileCards }}</div>
        </div>
      </div>

      <div class="header-right">
        <button class="home-btn" @click="backToMenu">
          <span class="home-icon">⌂</span>
          <span class="home-text">首页</span>
        </button>
        <div class="status-indicator">
          <span class="status-dot" :class="{ 'is-active': isPlayerTurn }"></span>
          {{ statusText }}
        </div>
      </div>
    </header>

    <!-- 主游戏区域 -->
    <div class="main-container">
      <!-- 左侧玩家信息 -->
      <aside class="sidebar">
        <div class="sidebar-title">
          <span class="title-line"></span>
          玩家信息
        </div>

        <div class="player-list">
          <div v-for="(player, index) in bluffStore.players" :key="player.id" class="player-card" :class="{
            'is-me': !player.isAI,
            'is-current': currentPlayerIndex === index,
            'is-thinking': isAIThinking && currentPlayerIndex === index
          }">
            <div class="player-info">
              <div class="player-avatar">{{ getPlayerInitial(player, index) }}</div>
              <div class="player-detail">
                <div class="player-name">{{ player.name }}</div>
                <div class="player-status">{{ !player.isAI ? '我' : 'CPU' }}</div>
              </div>
            </div>
            <div class="player-cards">
              <span class="card-count">{{ player.cardCount }}张</span>
            </div>
          </div>
        </div>
      </aside>

      <!-- 中央牌堆区域 -->
      <main class="game-board">
        <!-- 电脑玩家位置 (上方) -->
        <div class="opponents-area">
          <div v-for="(player, index) in cpuPlayers" :key="player.id" class="opponent"
            :class="{ 'is-current': isCurrentPlayer(player.id) }">
            <div class="opponent-avatar">{{ getPlayerInitial(player, index + 1) }}</div>
            <div class="opponent-name">{{ player.name }}</div>
            <div class="opponent-cards">{{ player.cardCount }}张</div>
          </div>
        </div>

        <!-- 牌堆区域 -->
        <div class="pile-area">
          <!-- 累积牌区 -->
          <div class="pile-section">
            <div class="pile-label">累积牌区</div>
            <div class="pile-count">{{ bluffStore.pile.accumulated.length }}张</div>
            <div class="card-stack accumulated">
              <div v-for="(card, index) in displayAccumulatedCards" :key="index" class="stacked-card"
                :style="getStackedCardStyle(index, 'accumulated')">
                <div class="card-back"></div>
              </div>
              <div v-if="bluffStore.pile.accumulated.length === 0" class="empty-pile">空</div>
            </div>
          </div>

          <!-- 最新出牌区 -->
          <div class="pile-section">
            <div class="pile-label">最新出牌{{ bluffStore.lastPlay.claimedRank ? '-' + bluffStore.lastPlay.claimedRank : '' }}</div>
            <div class="pile-count">{{ bluffStore.pile.latest.length }}张</div>
            <div class="card-stack latest">
              <div v-for="(card, index) in displayLatestCards" :key="index" class="stacked-card"
                :style="getStackedCardStyle(index, 'latest')">
                <div class="card-back"></div>
              </div>
              <div v-if="bluffStore.pile.latest.length === 0" class="empty-pile">空</div>
            </div>
            <!-- 最后出牌信息 -->
            <div v-if="bluffStore.lastPlay.playerId" class="last-play-info">
              {{ getPlayerName(bluffStore.lastPlay.playerId) }} 出了 {{ bluffStore.lastPlay.cardCount }} 张 {{
                bluffStore.lastPlay.claimedRank }}
            </div>
          </div>

          <!-- 弃牌区 -->
          <div class="pile-section discard-section">
            <div class="pile-label discard-label">弃牌区</div>
            <div class="pile-count discard-count">{{ bluffStore.discardPile.length }}张</div>
            <div class="card-stack discard-stack">
              <div v-for="(card, index) in displayDiscardCards" :key="index" class="stacked-card discard-card"
                :style="getStackedCardStyle(index, 'discard')">
                <div class="card-back"></div>
              </div>
              <div v-if="bluffStore.discardPile.length === 0" class="empty-pile">空</div>
            </div>
          </div>
        </div>

        <!-- AI思考提示 -->
        <div v-if="isAIThinking" class="thinking-indicator">
          <span class="thinking-text">{{ getCurrentPlayer().name }} 正在思考...</span>
          <span class="thinking-dots">...</span>
        </div>
      </main>

      <!-- 右侧日志 -->
      <aside class="sidebar sidebar-right">
        <div class="sidebar-title">
          <span class="title-line"></span>
          游戏日志
        </div>
        <div class="log-list">
          <div v-for="(log, index) in bluffStore.logs" :key="index" class="log-entry">
            {{ log }}
          </div>
        </div>
      </aside>
    </div>

    <!-- 底部手牌区域 -->
    <div class="hand-area" v-if="playerHand.length > 0">
      <div class="hand-header">
        <div class="hand-header-left">
          <span class="hand-title">我的手牌</span>
          <span class="hand-count">剩余 {{ playerHand.length }} 张</span>
        </div>
        <div class="hand-header-right">
          <span v-if="selectedCards.length > 0" class="selected-info">
            已选 {{ selectedCards.length }} 张
          </span>
        </div>
      </div>

      <div class="hand-cards">
        <div v-for="(card, index) in playerHand" :key="index" class="playing-card" :class="[
          getCardColorClass(card),
          { 'is-selected': isCardSelected(index) }
        ]" @click="handleCardClick(index)">
          <div class="card-corner top">
            <span>{{ getCardDisplayRank(card) }}</span>
            <span>{{ getSuitSymbol(card.suit) }}</span>
          </div>
          <div class="card-center">{{ getSuitSymbol(card.suit) }}</div>
          <div class="card-corner bottom">
            <span>{{ getCardDisplayRank(card) }}</span>
            <span>{{ getSuitSymbol(card.suit) }}</span>
          </div>
        </div>
      </div>

      <!-- 操作按钮区 -->
      <div class="hand-actions" v-if="isPlayerTurn">
        <!-- 新一轮：选择点数 -->
        <div v-if="isNewRound" class="rank-selector">
          <span class="selector-label">选择点数:</span>
          <div class="rank-options">
            <button v-for="rank in availableRanks" :key="rank" class="rank-btn"
              :class="{ 'is-selected': selectedRank === rank }" @click="selectedRank = rank">
              {{ rank }}
            </button>
          </div>
        </div>

        <!-- 出牌按钮 -->
        <button class="btn btn-highlight" :disabled="!canPlay" @click="handlePlay">
          出牌 ({{ selectedCards.length }}张)
        </button>

        <!-- 质疑按钮 -->
        <button v-if="canChallenge" class="btn btn-challenge" @click="handleChallenge">
          质疑!
        </button>

        <!-- 跳过按钮 -->
        <button v-if="canSkip" class="btn btn-skip" @click="handleSkip">
          跳过
        </button>
      </div>
    </div>

    <!-- 规则弹窗 -->
    <div class="rules-modal" v-if="bluffStore.showRules" @click.self="bluffStore.showRules = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>吹牛皮游戏规则</h2>
          <button class="rules-close" @click="bluffStore.showRules = false">×</button>
        </div>
        <div class="rules-body">
          <div class="rules-section">
            <h3>游戏目标</h3>
            <p>最先出完手中所有牌的玩家获胜。</p>
          </div>

          <div class="rules-section">
            <h3>游戏设置</h3>
            <ul>
              <li>4名玩家（1名人类 + 3名电脑）</li>
              <li>使用54张牌（含大小王）</li>
              <li>每人发13张牌，剩余2张弃置</li>
            </ul>
          </div>

          <div class="rules-section">
            <h3>游戏流程</h3>
            <h4>1. 出牌</h4>
            <p>每轮由一名玩家选择点数(A~K)并打出1张或多张牌，宣称这些牌都是该点数。</p>
            <p>后续玩家必须出相同点数的牌，可以选择：</p>
            <ul>
              <li>出真牌：手中有该点数的牌</li>
              <li>吹牛：出其他点数的牌，假装是该点数</li>
            </ul>

            <h4>2. 质疑</h4>
            <p>任何玩家都可以质疑上家的出牌。质疑后翻开牌验证：</p>
            <ul>
              <li><strong>质疑成功</strong>：上家说谎，收回牌堆所有牌</li>
              <li><strong>质疑失败</strong>：上家说真话，质疑者收回牌堆所有牌</li>
            </ul>
            <p>收牌的玩家获得下一轮出牌权，牌堆清空。</p>

            <h4>3. 万能牌</h4>
            <p>大小王是万能牌，可以当作任何点数使用。</p>
          </div>

          <div class="rules-section">
            <h3>胜负判定</h3>
            <p>当某位玩家出完所有手牌时，该玩家获胜，游戏结束。</p>
          </div>
        </div>
      </div>
    </div>

    <!-- 质疑结果弹窗 -->
    <div class="challenge-modal" v-if="challengeResult" @click.self="closeChallengeResult">
      <div class="challenge-content">
        <div class="challenge-header" :class="{ 'success': challengeResult.success }">
          <h2>{{ challengeResult.success ? '质疑成功!' : '质疑失败!' }}</h2>
        </div>
        <div class="challenge-body">
          <div class="challenge-players">
            <span class="challenger">质疑人：{{ getPlayerName(challengeResult.challengerId) }}</span>
            <span class="vs">VS</span>
            <span class="challenged">被质疑人：{{ getPlayerName(challengeResult.challengedId) }}</span>
          </div>
          <p v-if="challengeResult.success" class="challenge-result-text">
            {{ getPlayerName(challengeResult.challengedId) }} 在吹牛！<br>
            所有牌都是 {{ bluffStore.currentRank }} 的谎言被揭穿！
          </p>
          <p v-else class="challenge-result-text">
            {{ getPlayerName(challengeResult.challengedId) }} 说的是真话！<br>
            所有牌确实是 {{ bluffStore.currentRank }}
          </p>

          <div class="revealed-cards">
            <h4>翻开的牌:</h4>
            <div class="cards-display">
              <div v-for="(card, index) in challengeResult.revealedCards" :key="index" class="revealed-card"
                :class="getCardColorClass(card)">
                <div class="card-corner top">
                  <span>{{ getCardDisplayRank(card) }}</span>
                  <span>{{ getSuitSymbol(card.suit) }}</span>
                </div>
                <div class="card-center">{{ getSuitSymbol(card.suit) }}</div>
                <div class="card-corner bottom">
                  <span>{{ getCardDisplayRank(card) }}</span>
                  <span>{{ getSuitSymbol(card.suit) }}</span>
                </div>
              </div>
            </div>
          </div>

          <p class="result-summary">
            <span v-if="challengeResult.success">
              {{ getPlayerName(challengeResult.challengedId) }} 收回所有牌
            </span>
            <span v-else>
              {{ getPlayerName(challengeResult.challengerId) }} 收回所有牌
            </span>
          </p>
        </div>
        <div class="challenge-footer">
          <button class="btn-confirm" @click="closeChallengeResult">确定</button>
        </div>
      </div>
    </div>

    <!-- 游戏结束弹窗 -->
    <div class="gameover-modal" v-if="bluffStore.gamePhase === 'gameOver'">
      <div class="gameover-content">
        <div class="gameover-header">
          <h2>游戏结束</h2>
        </div>
        <div class="gameover-body">
          <div class="winner-display">
            <span class="winner-icon">🏆</span>
            <span class="winner-name">{{ winnerName }} 获胜!</span>
          </div>
        </div>
        <div class="gameover-footer">
          <button class="btn" @click="bluffStore.restartGame()">再来一局</button>
          <button class="btn btn-highlight" @click="backToMenu">返回主菜单</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, computed, watch, onMounted, onUnmounted } from 'vue'
import bluffStore from '../store/bluffGameStore.js'
import BluffAI from '../utils/BluffAI.js'

export default {
  name: 'BluffGame',
  setup (props, { emit }) {
    // 本地状态
    const selectedRank = ref(null)
    const isAIThinking = ref(false)
    const challengeResult = ref(null)
    let aiTimer = null

    // 计算属性
    const playerHand = computed(() => {
      const player = bluffStore.players.find(p => p.id === 'player')
      return player ? player.hand : []
    })

    const cpuPlayers = computed(() => {
      return bluffStore.players.filter(p => p.isAI)
    })

    const isPlayerTurn = computed(() => {
      const currentPlayer = bluffStore.getCurrentPlayer()
      return currentPlayer && !currentPlayer.isAI
    })

    const currentPlayerIndex = computed(() => {
      return bluffStore.currentPlayerIndex
    })

    const isNewRound = computed(() => {
      return bluffStore.isNewRound()
    })

    const totalPileCards = computed(() => {
      return bluffStore.pile.accumulated.length + bluffStore.pile.latest.length
    })

    const selectedCards = computed(() => {
      return bluffStore.selectedCardIndices
    })

    const availableRanks = computed(() => {
      return bluffStore.getAvailableRanks()
    })

    const canPlay = computed(() => {
      if (selectedCards.value.length === 0) return false
      if (isNewRound.value && !selectedRank.value) return false
      return true
    })

    const canChallenge = computed(() => {
      return bluffStore.pile.latest.length > 0 &&
        bluffStore.lastPlay.playerId !== 'player'
    })

    const canSkip = computed(() => {
      return bluffStore.pile.latest.length > 0 &&
        bluffStore.lastPlay.playerId !== 'player'
    })

    const statusText = computed(() => {
      if (bluffStore.gamePhase === 'gameOver') return '游戏结束'
      const currentPlayer = bluffStore.getCurrentPlayer()
      if (!currentPlayer) return '等待中'
      if (currentPlayer.isAI) return `${currentPlayer.name} 思考中`
      return '你的回合'
    })

    const displayAccumulatedCards = computed(() => {
      // 最多显示10张用于视觉效果
      return bluffStore.pile.accumulated.slice(0, 10)
    })

    const displayLatestCards = computed(() => {
      // 最多显示5张用于视觉效果
      return bluffStore.pile.latest.slice(0, 5)
    })

    const displayDiscardCards = computed(() => {
      // 最多显示10张用于视觉效果
      return bluffStore.discardPile.slice(0, 10)
    })

    const winnerName = computed(() => {
      const winner = bluffStore.players.find(p => p.hand.length === 0)
      return winner ? winner.name : ''
    })

    // 方法
    const getPlayerInitial = (player, index) => {
      if (!player.isAI) return 'P1'
      return 'P' + (index + 1)
    }

    const getPlayerName = (playerId) => {
      const player = bluffStore.players.find(p => p.id === playerId)
      return player ? player.name : playerId
    }

    const isCurrentPlayer = (playerId) => {
      const currentPlayer = bluffStore.getCurrentPlayer()
      return currentPlayer && currentPlayer.id === playerId
    }

    const getCurrentPlayer = () => {
      return bluffStore.getCurrentPlayer()
    }

    const getSuitSymbol = (suit) => {
      const symbols = {
        'spades': '♠',
        'hearts': '♥',
        'clubs': '♣',
        'diamonds': '♦',
        'joker': '🃏'
      }
      return symbols[suit] || ''
    }

    const getCardDisplayRank = (card) => {
      if (card.rank === 'JOKER') return '王'
      return card.rank
    }

    const getCardColorClass = (card) => {
      if (!card) return 'card-black'
      if (card.rank === 'JOKER') return 'card-joker'
      return card.color === 'red' ? 'card-red' : 'card-black'
    }

    const isCardSelected = (index) => {
      return bluffStore.selectedCardIndices.includes(index)
    }

    const handleCardClick = (index) => {
      if (!isPlayerTurn.value) return
      bluffStore.toggleCardSelection(index)
    }

    const handlePlay = () => {
      if (!canPlay.value) return

      const claimedRank = isNewRound.value ? selectedRank.value : bluffStore.currentRank
      const success = bluffStore.playCards('player', selectedCards.value, claimedRank)

      if (success) {
        bluffStore.clearSelection()
        selectedRank.value = null
      }
    }

    const handleChallenge = () => {
      const result = bluffStore.challenge('player')
      if (result) {
        challengeResult.value = result
      }
    }

    const handleSkip = () => {
      bluffStore.skip()
    }

    const closeChallengeResult = () => {
      challengeResult.value = null
      // 弹窗关闭后，检查当前玩家是否是AI，如果是则触发AI回合
      setTimeout(() => {
        const currentPlayer = bluffStore.getCurrentPlayer()
        if (currentPlayer && currentPlayer.isAI && bluffStore.gamePhase !== 'gameOver') {
          handleAITurn()
        }
      }, 100)
    }

    const backToMenu = () => {
      bluffStore.backToMenu()
      emit('back-to-menu')
    }

    const getStackedCardStyle = (index, type) => {
      const offset = type === 'accumulated' ? index * 2 : index * 3
      return {
        transform: `translate(${offset}px, ${offset}px)`,
        zIndex: index
      }
    }

    // AI回合处理
    const handleAITurn = async () => {
      const currentPlayer = bluffStore.getCurrentPlayer()
      if (!currentPlayer || !currentPlayer.isAI) return

      isAIThinking.value = true

      // 延迟执行，模拟思考
      await new Promise(resolve => {
        aiTimer = setTimeout(resolve, bluffStore.settings.aiDelay)
      })

      if (bluffStore.gamePhase === 'gameOver') {
        isAIThinking.value = false
        return
      }

      const gameState = {
        currentRank: bluffStore.currentRank,
        pile: bluffStore.pile,
        lastPlay: bluffStore.lastPlay,
        players: bluffStore.players
      }

      const decision = BluffAI.makeDecision(currentPlayer, gameState)

      if (decision.type === 'challenge') {
        const result = bluffStore.challenge(currentPlayer.id)
        if (result) {
          challengeResult.value = result
        }
      } else if (decision.type === 'skip') {
        bluffStore.skip()
      } else {
        bluffStore.playCards(
          currentPlayer.id,
          decision.data.cardIndices,
          decision.data.claimedRank
        )
      }

      isAIThinking.value = false
    }

    // 监听当前玩家变化
    watch(() => bluffStore.currentPlayerIndex, () => {
      // 如果质疑弹窗正在显示，不触发AI行动，等弹窗关闭后再触发
      if (challengeResult.value) {
        return
      }
      const currentPlayer = bluffStore.getCurrentPlayer()
      if (currentPlayer && currentPlayer.isAI && bluffStore.gamePhase !== 'gameOver') {
        handleAITurn()
      }
    })

    // 组件挂载时检查是否需要AI行动
    onMounted(() => {
      const currentPlayer = bluffStore.getCurrentPlayer()
      if (currentPlayer && currentPlayer.isAI && bluffStore.gamePhase !== 'gameOver') {
        handleAITurn()
      }
    })

    onUnmounted(() => {
      if (aiTimer) {
        clearTimeout(aiTimer)
      }
    })

    return {
      bluffStore,
      selectedRank,
      isAIThinking,
      challengeResult,
      playerHand,
      cpuPlayers,
      isPlayerTurn,
      currentPlayerIndex,
      isNewRound,
      totalPileCards,
      selectedCards,
      availableRanks,
      canPlay,
      canChallenge,
      canSkip,
      statusText,
      displayAccumulatedCards,
      displayLatestCards,
      displayDiscardCards,
      winnerName,
      getPlayerInitial,
      getPlayerName,
      isCurrentPlayer,
      getCurrentPlayer,
      getSuitSymbol,
      getCardDisplayRank,
      getCardColorClass,
      isCardSelected,
      handleCardClick,
      handlePlay,
      handleChallenge,
      handleSkip,
      closeChallengeResult,
      backToMenu,
      getStackedCardStyle
    }
  }
}
</script>

<style scoped>
.bluff-game {
  min-height: 100vh;
  background: #1a1a1a;
  display: flex;
  flex-direction: column;
  position: relative;
  font-family: 'JetBrains Mono', 'Consolas', monospace;
}

/* 噪点纹理覆盖层 */
.bluff-game::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  opacity: 0.12;
  pointer-events: none;
  z-index: 1;
}

/* 顶部导航 */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  background: rgba(45, 42, 40, 0.92);
  border-bottom: 1px solid rgba(180, 170, 160, 0.15);
  position: relative;
  z-index: 10;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.25);
}

.header-left,
.header-right {
  flex: 1;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 16px;
}

.header-right {
  text-align: right;
}

.logo {
  display: flex;
  align-items: center;
  gap: 8px;
}

.logo-icon {
  font-size: 20px;
}

.logo-text {
  font-size: 18px;
  font-weight: 600;
  color: rgba(245, 240, 230, 0.95);
  letter-spacing: 1px;
}

.header-center {
  display: flex;
  gap: 32px;
}

.stat-block {
  text-align: center;
}

.stat-label {
  font-size: 13px;
  color: rgba(200, 190, 180, 0.7);
  letter-spacing: 1px;
}

.stat-value {
  font-size: 24px;
  color: #c4a77d;
  font-weight: 600;
}

.status-indicator {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: #c4a77d;
  letter-spacing: 1px;
}

.status-dot {
  width: 6px;
  height: 6px;
  background: rgba(180, 170, 160, 0.4);
  border-radius: 50%;
  transition: all 0.3s;
}

.status-dot.is-active {
  background: #c4a77d;
  box-shadow: 0 0 6px rgba(196, 167, 125, 0.5);
}

/* 主容器 */
.main-container {
  flex: 1;
  display: grid;
  grid-template-columns: 240px 1fr 240px;
  gap: 16px;
  padding: 16px;
  overflow: hidden;
  position: relative;
  z-index: 5;
}

/* 侧边栏 */
.sidebar {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sidebar-title {
  font-size: 11px;
  color: rgba(180, 170, 160, 0.5);
  letter-spacing: 1px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.title-line {
  width: 16px;
  height: 1px;
  background: rgba(180, 170, 160, 0.4);
}

.player-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.player-card {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background: rgba(50, 47, 44, 0.85);
  border: 1px solid rgba(180, 170, 160, 0.12);
  transition: all 0.2s;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.player-card.is-me {
  border-color: rgba(196, 167, 125, 0.35);
  background: rgba(196, 167, 125, 0.08);
}

.player-card.is-current {
  border-color: #c4a77d;
  box-shadow: 0 0 12px rgba(196, 167, 125, 0.25);
}

.player-card.is-thinking {
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {

  0%,
  100% {
    opacity: 1;
  }

  50% {
    opacity: 0.7;
  }
}

.player-info {
  display: flex;
  align-items: center;
  gap: 10px;
}

.player-avatar {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(180, 170, 160, 0.12);
  border: 1px solid rgba(180, 170, 160, 0.25);
  font-size: 12px;
  color: rgba(220, 210, 200, 0.85);
}

.player-card.is-me .player-avatar {
  background: rgba(196, 167, 125, 0.18);
  border-color: rgba(196, 167, 125, 0.45);
  color: #c4a77d;
}

.player-name {
  font-size: 15px;
  color: rgba(245, 240, 230, 0.9);
}

.player-status {
  font-size: 13px;
  color: rgba(180, 170, 160, 0.65);
}

.card-count {
  font-size: 14px;
  color: #c4a77d;
  font-weight: 500;
}

/* 日志列表 */
.log-list {
  flex: 1;
  overflow-y: auto;
  font-size: 12px;
  color: rgba(200, 190, 180, 0.75);
  line-height: 1.8;
  max-height: 400px;
}

.log-entry {
  padding: 6px 0;
  border-bottom: 1px solid rgba(180, 170, 160, 0.1);
}

/* 游戏主区域 */
.game-board {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* 对手区域 */
.opponents-area {
  display: flex;
  justify-content: center;
  gap: 40px;
  padding: 20px;
}

.opponent {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 16px 24px;
  background: rgba(50, 47, 44, 0.85);
  border: 1px solid rgba(180, 170, 160, 0.12);
  transition: all 0.3s;
}

.opponent.is-current {
  border-color: #c4a77d;
  box-shadow: 0 0 20px rgba(196, 167, 125, 0.3);
}

.opponent-avatar {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(180, 170, 160, 0.12);
  border: 1px solid rgba(180, 170, 160, 0.25);
  font-size: 16px;
  color: rgba(220, 210, 200, 0.85);
}

.opponent-name {
  font-size: 14px;
  color: rgba(245, 240, 230, 0.9);
}

.opponent-cards {
  font-size: 13px;
  color: #c4a77d;
}

/* 牌堆区域 */
.pile-area {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 60px;
  padding: 40px;
}

.pile-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.pile-label {
  font-size: 14px;
  color: rgba(180, 170, 160, 0.7);
  letter-spacing: 1px;
}

.pile-count {
  font-size: 18px;
  color: #c4a77d;
  font-weight: 600;
}

/* 弃牌区特殊样式 */
.discard-section {
  border: 2px solid rgba(139, 154, 109, 0.4);
  border-radius: 12px;
  padding: 16px;
  background: rgba(139, 154, 109, 0.08);
}

.discard-label {
  color: #8b9a6d;
  font-weight: 600;
}

.discard-count {
  color: #8b9a6d;
}

.discard-card .card-back {
  background: linear-gradient(135deg, #5a6a4a 25%, #7a8a6a 25%, #7a8a6a 50%, #5a6a4a 50%, #5a6a4a 75%, #7a8a6a 75%);
  background-size: 8px 8px;
  border: 1px solid rgba(139, 154, 109, 0.4);
}

.card-stack {
  width: 100px;
  height: 140px;
  position: relative;
}

.stacked-card {
  position: absolute;
  width: 72px;
  height: 100px;
  transition: all 0.3s;
}

.card-back {
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #4a4540 25%, #6a6560 25%, #6a6560 50%, #4a4540 50%, #4a4540 75%, #6a6560 75%);
  background-size: 8px 8px;
  border: 1px solid rgba(180, 170, 160, 0.3);
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.empty-pile {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px dashed rgba(180, 170, 160, 0.2);
  border-radius: 4px;
  color: rgba(180, 170, 160, 0.4);
  font-size: 14px;
}

.last-play-info {
  font-size: 13px;
  color: rgba(200, 190, 180, 0.8);
  text-align: center;
  max-width: 150px;
}

/* 思考指示器 */
.thinking-indicator {
  text-align: center;
  padding: 20px;
}

.thinking-text {
  font-size: 16px;
  color: #c4a77d;
}

.thinking-dots {
  animation: dots 1.5s steps(4, end) infinite;
}

@keyframes dots {

  0%,
  20% {
    content: '';
  }

  40% {
    content: '.';
  }

  60% {
    content: '..';
  }

  80%,
  100% {
    content: '...';
  }
}

/* 手牌区域 */
.hand-area {
  background: rgba(45, 42, 40, 0.95);
  border-top: 1px solid rgba(180, 170, 160, 0.12);
  padding: 16px 24px;
  box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.25);
  position: relative;
  z-index: 10;
}

.hand-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.hand-header-left {
  display: flex;
  align-items: center;
  gap: 12px;
}

.hand-title {
  font-size: 15px;
  color: #c4a77d;
  letter-spacing: 1px;
}

.hand-count {
  font-size: 14px;
  color: rgba(180, 170, 160, 0.7);
}

.selected-info {
  font-size: 14px;
  color: #c4a77d;
}

.hand-cards {
  display: flex;
  gap: 8px;
  justify-content: center;
  flex-wrap: wrap;
  min-height: 100px;
  padding: 10px 0;
}

/* 扑克牌样式 */
.playing-card {
  width: 60px;
  height: 84px;
  background: #f0ece5;
  border: 1px solid rgba(140, 130, 120, 0.3);
  border-radius: 4px;
  position: relative;
  cursor: pointer;
  transition: all 0.2s;
  user-select: none;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
}

.playing-card:hover {
  transform: translateY(-8px);
  border-color: rgba(196, 167, 125, 0.5);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.playing-card.is-selected {
  border-color: #c4a77d;
  border-width: 3px;
  box-shadow: 0 0 15px rgba(196, 167, 125, 0.4);
  transform: translateY(-4px);
}

.playing-card.card-red {
  color: #b56565;
}

.playing-card.card-black {
  color: #4a4a4a;
}

.playing-card.card-joker {
  background: linear-gradient(135deg, #f0ece5 0%, #e8e0d5 100%);
  color: #8b4513;
}

.card-corner {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 12px;
  font-weight: bold;
  line-height: 1.2;
}

.card-corner.top {
  top: 3px;
  left: 3px;
}

.card-corner.bottom {
  bottom: 3px;
  right: 3px;
  transform: rotate(180deg);
}

.card-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 20px;
}

/* 操作按钮区 */
.hand-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  align-items: center;
  margin-top: 16px;
  flex-wrap: wrap;
}

.rank-selector {
  display: flex;
  align-items: center;
  gap: 12px;
}

.selector-label {
  font-size: 13px;
  color: rgba(180, 170, 160, 0.7);
}

.rank-options {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.rank-btn {
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(50, 47, 44, 0.85);
  border: 1px solid rgba(180, 170, 160, 0.25);
  color: rgba(220, 210, 200, 0.85);
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
}

.rank-btn:hover {
  border-color: rgba(196, 167, 125, 0.5);
  color: #c4a77d;
}

.rank-btn.is-selected {
  background: #c4a77d;
  border-color: #c4a77d;
  color: #2d2a28;
  font-weight: 600;
}

.btn {
  padding: 10px 24px;
  font-size: 14px;
  font-family: inherit;
  letter-spacing: 1px;
  background: transparent;
  border: 1px solid rgba(180, 170, 160, 0.35);
  color: rgba(220, 210, 200, 0.85);
  cursor: pointer;
  transition: all 0.2s;
}

.btn:hover {
  border-color: rgba(196, 167, 125, 0.6);
  color: rgba(245, 240, 230, 0.95);
}

.btn-highlight {
  background: #c4a77d;
  border-color: #c4a77d;
  color: #2d2a28;
}

.btn-highlight:hover {
  background: #d4b78d;
  border-color: #d4b78d;
  box-shadow: 0 4px 12px rgba(196, 167, 125, 0.3);
}

.btn-challenge {
  background: #b56565;
  border-color: #b56565;
  color: #fff;
}

.btn-challenge:hover {
  background: #c57575;
  border-color: #c57575;
  box-shadow: 0 4px 12px rgba(181, 101, 101, 0.3);
}

.btn-skip {
  background: rgba(100, 100, 100, 0.5);
  border-color: rgba(180, 170, 160, 0.35);
  color: rgba(220, 210, 200, 0.85);
}

.btn-skip:hover {
  background: rgba(120, 120, 120, 0.6);
  border-color: rgba(180, 170, 160, 0.5);
}

.btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* 规则按钮 */
.rules-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: rgba(196, 167, 125, 0.1);
  border: 1px solid rgba(196, 167, 125, 0.3);
  border-radius: 6px;
  color: #c4a77d;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s;
}

.rules-btn:hover {
  background: rgba(196, 167, 125, 0.18);
  border-color: rgba(196, 167, 125, 0.5);
  box-shadow: 0 2px 8px rgba(196, 167, 125, 0.15);
}

.rules-icon {
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(196, 167, 125, 0.2);
  border-radius: 50%;
  font-size: 12px;
  font-weight: 600;
}

/* 首页按钮 */
.home-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: rgba(196, 167, 125, 0.1);
  border: 1px solid rgba(196, 167, 125, 0.3);
  border-radius: 6px;
  color: #c4a77d;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s;
  margin-right: 12px;
}

.home-btn:hover {
  background: rgba(196, 167, 125, 0.18);
  border-color: rgba(196, 167, 125, 0.5);
  box-shadow: 0 2px 8px rgba(196, 167, 125, 0.15);
}

.home-icon {
  font-size: 14px;
}

.home-text {
  font-size: 13px;
}

/* 弹窗样式 */
.rules-modal,
.challenge-modal,
.gameover-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(30, 28, 26, 0.92);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 20px;
}

.rules-content,
.challenge-content,
.gameover-content {
  background: #2d2a28;
  border: 1px solid rgba(180, 170, 160, 0.15);
  border-radius: 12px;
  max-width: 600px;
  max-height: 80vh;
  width: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
}

.rules-header,
.challenge-header,
.gameover-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 24px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.12);
}

.rules-header h2,
.challenge-header h2,
.gameover-header h2 {
  margin: 0;
  font-size: 20px;
  color: rgba(245, 240, 230, 0.95);
  font-weight: 600;
}

.challenge-header.success {
  background: rgba(139, 154, 109, 0.2);
}

.challenge-header.success h2 {
  color: #8b9a6d;
}

.challenge-header:not(.success) {
  background: rgba(181, 101, 101, 0.2);
}

.challenge-header:not(.success) h2 {
  color: #b56565;
}

.rules-close {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(180, 170, 160, 0.08);
  border: 1px solid rgba(180, 170, 160, 0.15);
  border-radius: 6px;
  color: rgba(200, 190, 180, 0.7);
  font-size: 24px;
  cursor: pointer;
  transition: all 0.2s;
}

.rules-close:hover {
  background: rgba(196, 167, 125, 0.15);
  border-color: rgba(196, 167, 125, 0.3);
  color: rgba(245, 240, 230, 0.95);
}

.rules-body,
.challenge-body,
.gameover-body {
  flex: 1;
  overflow-y: auto;
  padding: 24px;
}

.rules-section {
  margin-bottom: 24px;
}

.rules-section:last-child {
  margin-bottom: 0;
}

.rules-section h3 {
  margin: 0 0 12px 0;
  font-size: 16px;
  color: #c4a77d;
  font-weight: 600;
}

.rules-section h4 {
  margin: 16px 0 8px 0;
  font-size: 14px;
  color: rgba(230, 225, 215, 0.9);
  font-weight: 600;
}

.rules-section p {
  margin: 0 0 8px 0;
  font-size: 13px;
  color: rgba(200, 190, 180, 0.8);
  line-height: 1.7;
}

.rules-section ul {
  margin: 0 0 8px 0;
  padding-left: 20px;
  font-size: 13px;
  color: rgba(200, 190, 180, 0.8);
  line-height: 1.7;
}

.rules-section li {
  margin-bottom: 4px;
}

/* 质疑结果 */
.challenge-players {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 16px;
  margin-bottom: 16px;
  padding: 12px;
  background: rgba(180, 170, 160, 0.08);
  border-radius: 8px;
}

.challenger,
.challenged {
  font-size: 14px;
  color: rgba(220, 210, 200, 0.9);
}

.vs {
  font-size: 12px;
  color: #c4a77d;
  font-weight: 600;
  padding: 4px 8px;
  background: rgba(196, 167, 125, 0.15);
  border-radius: 4px;
}

.challenge-result-text {
  text-align: center;
  font-size: 14px;
  line-height: 1.6;
  color: rgba(200, 190, 180, 0.9);
  margin: 12px 0;
}

.revealed-cards {
  margin: 20px 0;
}

.revealed-cards h4 {
  font-size: 14px;
  color: rgba(180, 170, 160, 0.7);
  margin-bottom: 12px;
}

.cards-display {
  display: flex;
  gap: 12px;
  justify-content: center;
  flex-wrap: wrap;
}

.revealed-card {
  width: 60px;
  height: 84px;
  background: #f0ece5;
  border: 1px solid rgba(140, 130, 120, 0.3);
  border-radius: 4px;
  position: relative;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
}

.revealed-card.card-red {
  color: #b56565;
}

.revealed-card.card-black {
  color: #4a4a4a;
}

.result-summary {
  text-align: center;
  font-size: 16px;
  color: #c4a77d;
  margin-top: 16px;
}

.challenge-footer,
.gameover-footer {
  padding: 16px 24px;
  border-top: 1px solid rgba(180, 170, 160, 0.12);
  display: flex;
  justify-content: center;
  gap: 12px;
}

.btn-confirm {
  padding: 10px 32px;
  font-size: 14px;
  font-family: inherit;
  letter-spacing: 1px;
  background: #c4a77d;
  border: none;
  border-radius: 6px;
  color: #2d2a28;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-confirm:hover {
  background: #d4b78d;
  box-shadow: 0 0 15px rgba(196, 167, 125, 0.35);
}

/* 游戏结束 */
.winner-display {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  padding: 40px;
}

.winner-icon {
  font-size: 64px;
}

.winner-name {
  font-size: 24px;
  color: #c4a77d;
  font-weight: 600;
}

/* 滚动条样式 */
.rules-body::-webkit-scrollbar,
.challenge-body::-webkit-scrollbar,
.log-list::-webkit-scrollbar {
  width: 6px;
}

.rules-body::-webkit-scrollbar-track,
.challenge-body::-webkit-scrollbar-track,
.log-list::-webkit-scrollbar-track {
  background: rgba(180, 170, 160, 0.06);
}

.rules-body::-webkit-scrollbar-thumb,
.challenge-body::-webkit-scrollbar-thumb,
.log-list::-webkit-scrollbar-thumb {
  background: rgba(180, 170, 160, 0.25);
  border-radius: 3px;
}
</style>

--- src/components/BluffGameMobile.vue ---
<template>
  <div class="bluff-game-mobile">
    <!-- 顶部导航 -->
    <header class="header">
      <div class="header-left">
        <div class="logo">
          <span class="logo-icon">🎴</span>
          <span class="logo-text">吹牛皮</span>
        </div>
      </div>
      <div class="header-center">
        <div class="stat-item">
          <span class="stat-label">当前点数</span>
          <span class="stat-value">{{ bluffStore.currentRank || '-' }}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">牌堆</span>
          <span class="stat-value">{{ totalPileCards }}</span>
        </div>
      </div>
      <div class="header-right">
        <button class="icon-btn home-btn" @click="backToMenu">⌂</button>
        <button class="icon-btn" @click="showLogs = true">📋</button>
        <button class="icon-btn" @click="bluffStore.showRules = true">?</button>
      </div>
    </header>

    <!-- 玩家区域 - 包含所有玩家 -->
    <div class="players-bar">
      <div v-for="(player, index) in allPlayers" :key="player.id" class="player-chip" :class="{
        'is-current': isCurrentPlayer(player.id),
        'is-me': !player.isAI
      }">
        <span class="player-name">{{ player.isAI ? player.name : '我' }}</span>
        <span class="player-count">{{ player.cardCount }}张</span>
      </div>
    </div>

    <!-- 游戏主区域 -->
    <main class="game-area">
      <!-- 牌堆区域 -->
      <div class="pile-container">
        <!-- 弃牌区 -->
        <div class="pile-box discard-box">
          <div class="pile-title discard-title">弃牌区</div>
          <div class="pile-stack">
            <div v-for="(card, index) in displayDiscardCards" :key="index" class="mini-card discard-card"
              :style="getStackedStyle(index)">
              <div class="mini-card-back"></div>
            </div>
            <div v-if="bluffStore.discardPile.length === 0" class="empty-slot">空</div>
          </div>
          <div class="pile-count discard-count">{{ bluffStore.discardPile.length }}张</div>
        </div>

        <!-- 累积牌区 -->
        <div class="pile-box">
          <div class="pile-title">累积牌区</div>
          <div class="pile-stack">
            <div v-for="(card, index) in displayAccumulatedCards" :key="index" class="mini-card"
              :style="getStackedStyle(index)">
              <div class="mini-card-back"></div>
            </div>
            <div v-if="bluffStore.pile.accumulated.length === 0" class="empty-slot">空</div>
          </div>
          <div class="pile-count">{{ bluffStore.pile.accumulated.length }}张</div>
        </div>

        <!-- 最新出牌区 -->
        <div class="pile-box">
          <div class="pile-title">最新出牌{{ bluffStore.lastPlay.claimedRank ? '-' + bluffStore.lastPlay.claimedRank : '' }}
          </div>
          <div class="pile-stack">
            <div v-for="(card, index) in displayLatestCards" :key="index" class="mini-card"
              :style="getStackedStyle(index)">
              <div class="mini-card-back"></div>
            </div>
            <div v-if="bluffStore.pile.latest.length === 0" class="empty-slot">空</div>
          </div>
          <div class="pile-count">{{ bluffStore.pile.latest.length }}张</div>
        </div>
      </div>

      <!-- 最近游戏日志 -->
      <div class="last-play-bar">
        <div v-for="(log, index) in recentLogs" :key="index" class="log-line">
          {{ log }}
        </div>
        <div v-if="recentLogs.length === 0" class="log-line">游戏开始，等待出牌...</div>
      </div>

      <!-- AI思考提示 -->
      <div v-if="isAIThinking" class="thinking-bar">
        <span class="thinking-text">{{ getCurrentPlayer().name }} 思考中...</span>
      </div>

      <!-- 已选手牌提示 -->
      <div v-if="selectedCards.length > 0" class="selection-hint-bar">
        已选 {{ selectedCards.length }} 张牌
      </div>
    </main>

    <!-- 手牌区域 - 固定在底部，2行显示 -->
    <div class="hand-section" v-if="playerHand.length > 0">
      <div class="hand-grid">
        <div v-for="(card, index) in playerHand" :key="index" class="hand-card" :class="[
          getCardColorClass(card),
          { 'is-selected': isCardSelected(index) }
        ]" @click="handleCardClick(index)">
          <div class="card-content">
            <span class="card-rank">{{ getCardDisplayRank(card) }}</span>
            <span class="card-suit">{{ getSuitSymbol(card.suit) }}</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 操作按钮区 -->
    <div class="action-bar" v-if="isPlayerTurn">
      <!-- 新一轮：选择点数 -->
      <div v-if="isNewRound" class="rank-selector">
        <div class="rank-scroll">
          <button v-for="rank in availableRanks" :key="rank" class="rank-chip"
            :class="{ 'is-selected': selectedRank === rank }" @click="selectedRank = rank">
            {{ rank }}
          </button>
        </div>
      </div>

      <div class="action-buttons">
        <button class="btn btn-play" :disabled="!canPlay" @click="handlePlay">
          出牌 {{ selectedCards.length > 0 ? '(' + selectedCards.length + ')' : '' }}
        </button>
        <button v-if="canChallenge" class="btn btn-challenge" @click="handleChallenge">
          质疑
        </button>
        <button v-if="canSkip" class="btn btn-skip" @click="handleSkip">
          跳过
        </button>
      </div>
    </div>

    <!-- 规则弹窗 -->
    <div class="modal" v-if="bluffStore.showRules" @click.self="bluffStore.showRules = false">
      <div class="modal-content">
        <div class="modal-header">
          <h2>吹牛皮规则</h2>
          <button class="modal-close" @click="bluffStore.showRules = false">×</button>
        </div>
        <div class="modal-body">
          <div class="rule-section">
            <h3>游戏目标</h3>
            <p>最先出完手中所有牌的玩家获胜。</p>
          </div>
          <div class="rule-section">
            <h3>出牌</h3>
            <p>选择点数(A~K)并打出1张或多张牌，宣称这些牌都是该点数。</p>
          </div>
          <div class="rule-section">
            <h3>质疑</h3>
            <p>质疑上家的出牌。若上家说谎，他收回所有牌；若说真话，你收回所有牌。</p>
          </div>
          <div class="rule-section">
            <h3>万能牌</h3>
            <p>大小王可当作任何点数使用。</p>
          </div>
        </div>
      </div>
    </div>

    <!-- 质疑结果弹窗 -->
    <div class="modal" v-if="challengeResult" @click.self="closeChallengeResult">
      <div class="modal-content">
        <div class="modal-header" :class="{ 'success': challengeResult.success }">
          <h2>{{ challengeResult.success ? '质疑成功!' : '质疑失败!' }}</h2>
        </div>
        <div class="modal-body">
          <div class="challenge-players">
            <span class="challenger">质疑：{{ getPlayerName(challengeResult.challengerId) }}</span>
            <span class="vs">VS</span>
            <span class="challenged">被质疑：{{ getPlayerName(challengeResult.challengedId) }}</span>
          </div>
          <p class="result-text" v-if="challengeResult.success">
            {{ getPlayerName(challengeResult.challengedId) }} 在吹牛！
          </p>
          <p class="result-text" v-else>
            {{ getPlayerName(challengeResult.challengedId) }} 说的是真话！
          </p>

          <div class="revealed-cards">
            <div v-for="(card, index) in challengeResult.revealedCards" :key="index" class="revealed-card"
              :class="getCardColorClass(card)">
              <div class="card-rank">{{ getCardDisplayRank(card) }}</div>
              <div class="card-suit">{{ getSuitSymbol(card.suit) }}</div>
            </div>
          </div>

          <p class="result-summary">
            <span v-if="challengeResult.success">
              {{ getPlayerName(challengeResult.challengedId) }} 收回所有牌
            </span>
            <span v-else>
              {{ getPlayerName(challengeResult.challengerId) }} 收回所有牌
            </span>
          </p>
        </div>
        <div class="modal-footer">
          <button class="btn btn-confirm" @click="closeChallengeResult">确定</button>
        </div>
      </div>
    </div>

    <!-- 游戏结束弹窗 -->
    <div class="modal" v-if="bluffStore.gamePhase === 'gameOver'">
      <div class="modal-content">
        <div class="modal-header">
          <h2>游戏结束</h2>
        </div>
        <div class="modal-body center">
          <div class="winner-display">
            <span class="winner-icon">🏆</span>
            <span class="winner-name">{{ winnerName }} 获胜!</span>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn" @click="bluffStore.restartGame()">再来一局</button>
          <button class="btn btn-highlight" @click="backToMenu">返回主菜单</button>
        </div>
      </div>
    </div>

    <!-- 日志弹窗 -->
    <div class="modal" v-if="showLogs" @click.self="showLogs = false">
      <div class="modal-content">
        <div class="modal-header">
          <h2>游戏日志</h2>
          <button class="modal-close" @click="showLogs = false">×</button>
        </div>
        <div class="modal-body">
          <div class="log-list">
            <div v-for="(log, index) in bluffStore.logs" :key="index" class="log-item">
              {{ log }}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, computed, watch, onMounted, onUnmounted } from 'vue'
import bluffStore from '../store/bluffGameStore.js'
import BluffAI from '../utils/BluffAI.js'

export default {
  name: 'BluffGameMobile',
  emits: ['back-to-menu'],
  setup (props, { emit }) {
    const selectedRank = ref(null)
    const isAIThinking = ref(false)
    const challengeResult = ref(null)
    const showLogs = ref(false)
    let aiTimer = null

    const playerHand = computed(() => {
      const player = bluffStore.players.find(p => p.id === 'player')
      return player ? player.hand : []
    })

    const cpuPlayers = computed(() => {
      return bluffStore.players.filter(p => p.isAI)
    })

    const allPlayers = computed(() => {
      // 返回所有玩家，人类玩家在最前面
      const human = bluffStore.players.find(p => !p.isAI)
      const cpus = bluffStore.players.filter(p => p.isAI)
      return human ? [human, ...cpus] : cpus
    })

    const isPlayerTurn = computed(() => {
      const currentPlayer = bluffStore.getCurrentPlayer()
      return currentPlayer && !currentPlayer.isAI
    })

    const isNewRound = computed(() => {
      return bluffStore.isNewRound()
    })

    const totalPileCards = computed(() => {
      return bluffStore.pile.accumulated.length + bluffStore.pile.latest.length
    })

    const selectedCards = computed(() => {
      return bluffStore.selectedCardIndices
    })

    const availableRanks = computed(() => {
      return bluffStore.getAvailableRanks()
    })

    const canPlay = computed(() => {
      if (selectedCards.value.length === 0) return false
      if (isNewRound.value && !selectedRank.value) return false
      return true
    })

    const canChallenge = computed(() => {
      return bluffStore.pile.latest.length > 0 &&
        bluffStore.lastPlay.playerId !== 'player'
    })

    const canSkip = computed(() => {
      return bluffStore.pile.latest.length > 0 &&
        bluffStore.lastPlay.playerId !== 'player'
    })

    const displayAccumulatedCards = computed(() => {
      return bluffStore.pile.accumulated.slice(0, 5)
    })

    const displayLatestCards = computed(() => {
      return bluffStore.pile.latest.slice(0, 3)
    })

    const displayDiscardCards = computed(() => {
      return bluffStore.discardPile.slice(0, 5)
    })

    const recentLogs = computed(() => {
      // 显示最近4条日志，去掉时间戳前缀
      return bluffStore.logs.slice(0, 4).map(log => {
        // 去掉 [HH:MM:SS] 前缀
        return log.replace(/^\[\d{2}:\d{2}:\d{2}\]\s*/, '')
      })
    })

    const winnerName = computed(() => {
      const winner = bluffStore.players.find(p => p.hand.length === 0)
      return winner ? winner.name : ''
    })

    const getPlayerName = (playerId) => {
      const player = bluffStore.players.find(p => p.id === playerId)
      return player ? player.name : playerId
    }

    const isCurrentPlayer = (playerId) => {
      const currentPlayer = bluffStore.getCurrentPlayer()
      return currentPlayer && currentPlayer.id === playerId
    }

    const getCurrentPlayer = () => {
      return bluffStore.getCurrentPlayer()
    }

    const getSuitSymbol = (suit) => {
      const symbols = {
        'spades': '♠',
        'hearts': '♥',
        'clubs': '♣',
        'diamonds': '♦',
        'joker': '🃏'
      }
      return symbols[suit] || ''
    }

    const getCardDisplayRank = (card) => {
      if (card.rank === 'JOKER') return '王'
      return card.rank
    }

    const getCardColorClass = (card) => {
      if (!card) return 'card-black'
      if (card.rank === 'JOKER') return 'card-joker'
      return card.color === 'red' ? 'card-red' : 'card-black'
    }

    const isCardSelected = (index) => {
      return bluffStore.selectedCardIndices.includes(index)
    }

    const handleCardClick = (index) => {
      if (!isPlayerTurn.value) return
      bluffStore.toggleCardSelection(index)
    }

    const handlePlay = () => {
      if (!canPlay.value) return

      const claimedRank = isNewRound.value ? selectedRank.value : bluffStore.currentRank
      const success = bluffStore.playCards('player', selectedCards.value, claimedRank)

      if (success) {
        bluffStore.clearSelection()
        selectedRank.value = null
      }
    }

    const handleChallenge = () => {
      const result = bluffStore.challenge('player')
      if (result) {
        challengeResult.value = result
      }
    }

    const handleSkip = () => {
      bluffStore.skip()
    }

    const closeChallengeResult = () => {
      challengeResult.value = null
      // 弹窗关闭后，检查当前玩家是否是AI，如果是则触发AI回合
      setTimeout(() => {
        const currentPlayer = bluffStore.getCurrentPlayer()
        if (currentPlayer && currentPlayer.isAI && bluffStore.gamePhase !== 'gameOver') {
          handleAITurn()
        }
      }, 100)
    }

    const backToMenu = () => {
      bluffStore.backToMenu()
      emit('back-to-menu')
    }

    const getStackedStyle = (index) => {
      return {
        transform: `translate(${index * 2}px, ${index * 2}px)`,
        zIndex: index
      }
    }

    const handleAITurn = async () => {
      const currentPlayer = bluffStore.getCurrentPlayer()
      if (!currentPlayer || !currentPlayer.isAI) return

      isAIThinking.value = true

      await new Promise(resolve => {
        aiTimer = setTimeout(resolve, bluffStore.settings.aiDelay)
      })

      if (bluffStore.gamePhase === 'gameOver') {
        isAIThinking.value = false
        return
      }

      const gameState = {
        currentRank: bluffStore.currentRank,
        pile: bluffStore.pile,
        lastPlay: bluffStore.lastPlay,
        players: bluffStore.players
      }

      const decision = BluffAI.makeDecision(currentPlayer, gameState)

      if (decision.type === 'challenge') {
        const result = bluffStore.challenge(currentPlayer.id)
        if (result) {
          challengeResult.value = result
        }
      } else if (decision.type === 'skip') {
        bluffStore.skip()
      } else {
        bluffStore.playCards(
          currentPlayer.id,
          decision.data.cardIndices,
          decision.data.claimedRank
        )
      }

      isAIThinking.value = false
    }

    watch(() => bluffStore.currentPlayerIndex, () => {
      // 如果质疑弹窗正在显示，不触发AI行动，等弹窗关闭后再触发
      if (challengeResult.value) {
        return
      }
      const currentPlayer = bluffStore.getCurrentPlayer()
      if (currentPlayer && currentPlayer.isAI && bluffStore.gamePhase !== 'gameOver') {
        handleAITurn()
      }
    })

    onMounted(() => {
      const currentPlayer = bluffStore.getCurrentPlayer()
      if (currentPlayer && currentPlayer.isAI && bluffStore.gamePhase !== 'gameOver') {
        handleAITurn()
      }
    })

    onUnmounted(() => {
      if (aiTimer) {
        clearTimeout(aiTimer)
      }
    })

    return {
      bluffStore,
      selectedRank,
      isAIThinking,
      challengeResult,
      showLogs,
      playerHand,
      cpuPlayers,
      allPlayers,
      isPlayerTurn,
      isNewRound,
      totalPileCards,
      selectedCards,
      availableRanks,
      canPlay,
      canChallenge,
      canSkip,
      displayAccumulatedCards,
      displayLatestCards,
      displayDiscardCards,
      recentLogs,
      winnerName,
      getPlayerName,
      isCurrentPlayer,
      getCurrentPlayer,
      getSuitSymbol,
      getCardDisplayRank,
      getCardColorClass,
      isCardSelected,
      handleCardClick,
      handlePlay,
      handleChallenge,
      handleSkip,
      closeChallengeResult,
      backToMenu,
      getStackedStyle
    }
  }
}
</script>

<style scoped>
.bluff-game-mobile {
  min-height: 100vh;
  background: #1a1a1a;
  color: rgba(245, 240, 230, 0.95);
  font-family: 'JetBrains Mono', 'Consolas', monospace;
  display: flex;
  flex-direction: column;
  position: relative;
  padding-bottom: 80px;
}

.bluff-game-mobile::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  opacity: 0.12;
  pointer-events: none;
  z-index: 1;
}

/* 顶部导航 */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  background: rgba(45, 42, 40, 0.92);
  border-bottom: 1px solid rgba(180, 170, 160, 0.15);
  position: relative;
  z-index: 10;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 8px;
}

.logo {
  display: flex;
  align-items: center;
  gap: 6px;
}

.logo-icon {
  font-size: 1.25rem;
}

.logo-text {
  font-size: 1.1rem;
  font-weight: 600;
  color: rgba(245, 240, 230, 0.95);
}

.header-center {
  display: flex;
  gap: 20px;
}

.header-right {
  display: flex;
  flex-direction: row;
  gap: 8px;
}

.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

.stat-label {
  font-size: 0.7rem;
  color: rgba(200, 190, 180, 0.7);
}

.stat-value {
  font-size: 1rem;
  font-weight: 600;
  color: #c4a77d;
}

.icon-btn {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  border: 1px solid rgba(196, 167, 125, 0.3);
  background: rgba(196, 167, 125, 0.1);
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  color: #c4a77d;
  display: flex;
  align-items: center;
  justify-content: center;
}

.home-btn {
  font-size: 1rem;
}

/* 玩家栏 - 包含所有玩家 */
.players-bar {
  display: flex;
  justify-content: space-around;
  padding: 10px 8px;
  background: rgba(50, 47, 44, 0.85);
  border-bottom: 1px solid rgba(180, 170, 160, 0.1);
  position: relative;
  z-index: 5;
}

.player-chip {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  padding: 6px 10px;
  background: rgba(60, 57, 54, 0.8);
  border: 1px solid rgba(180, 170, 160, 0.15);
  border-radius: 16px;
  transition: all 0.3s;
  min-width: 50px;
}

.player-chip.is-current {
  border-color: #c4a77d;
  box-shadow: 0 0 10px rgba(196, 167, 125, 0.3);
}

.player-chip.is-me {
  background: rgba(196, 167, 125, 0.15);
  border-color: rgba(196, 167, 125, 0.35);
}

.player-chip.is-me.is-current {
  background: rgba(196, 167, 125, 0.25);
  border-color: #c4a77d;
}

.player-name {
  font-size: 0.75rem;
  color: rgba(220, 210, 200, 0.9);
}

.player-chip.is-me .player-name {
  color: #c4a77d;
  font-weight: 600;
}

.player-count {
  font-size: 0.7rem;
  color: #c4a77d;
}

/* 游戏区域 */
.game-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 12px 12px 210px;
  gap: 12px;
  position: relative;
  z-index: 5;
  overflow-y: auto;
}

/* 牌堆容器 */
.pile-container {
  display: flex;
  justify-content: center;
  gap: 30px;
  padding: 16px;
}

.pile-box {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.pile-title {
  font-size: 0.8rem;
  color: rgba(180, 170, 160, 0.7);
}

/* 弃牌区特殊样式 */
.discard-box {
  border: 1px solid rgba(139, 154, 109, 0.3);
  border-radius: 8px;
  padding: 8px;
  background: rgba(139, 154, 109, 0.05);
}

.discard-title {
  color: #8b9a6d;
  font-weight: 600;
}

.discard-count {
  color: #8b9a6d;
}

.discard-card .mini-card-back {
  background: linear-gradient(135deg, #5a6a4a 25%, #7a8a6a 25%, #7a8a6a 50%, #5a6a4a 50%, #5a6a4a 75%, #7a8a6a 75%);
  background-size: 6px 6px;
  border: 1px solid rgba(139, 154, 109, 0.4);
}

.pile-stack {
  width: 60px;
  height: 84px;
  position: relative;
}

.mini-card {
  position: absolute;
  width: 50px;
  height: 70px;
}

.mini-card-back {
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #4a4540 25%, #6a6560 25%, #6a6560 50%, #4a4540 50%, #4a4540 75%, #6a6560 75%);
  background-size: 6px 6px;
  border: 1px solid rgba(180, 170, 160, 0.3);
  border-radius: 4px;
}

.empty-slot {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px dashed rgba(180, 170, 160, 0.2);
  border-radius: 4px;
  color: rgba(180, 170, 160, 0.4);
  font-size: 0.75rem;
}

.pile-count {
  font-size: 0.85rem;
  color: #c4a77d;
  font-weight: 600;
}

/* 最近游戏日志 */
.last-play-bar {
  padding: 8px 12px;
  background: rgba(60, 57, 54, 0.6);
  border-radius: 8px;
  font-size: 0.8rem;
  color: rgba(200, 190, 180, 0.9);
  max-height: 100px;
  overflow-y: auto;
}

.log-line {
  padding: 2px 0;
  line-height: 1.4;
  border-bottom: 1px solid rgba(180, 170, 160, 0.1);
}

.log-line:last-child {
  border-bottom: none;
}

/* 思考提示 */
.thinking-bar {
  text-align: center;
  padding: 8px;
  background: rgba(196, 167, 125, 0.15);
  border-radius: 8px;
}

.thinking-text {
  font-size: 0.9rem;
  color: #c4a77d;
}

/* 已选手牌提示 */
.selection-hint-bar {
  text-align: center;
  padding: 10px;
  background: rgba(196, 167, 125, 0.15);
  border-radius: 8px;
  font-size: 0.9rem;
  color: #c4a77d;
  font-weight: 500;
}

/* 手牌区域 - 固定在底部，2行显示 */
.hand-section {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 8px;
  background: rgba(45, 42, 40, 0.98);
  border-top: 1px solid rgba(180, 170, 160, 0.15);
  z-index: 50;
}

.hand-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 6px;
  justify-items: center;
  height: 132px;
  /* 2行: 63px * 2 + 6px gap */
  overflow-y: auto;
}

.hand-card {
  width: 45px;
  height: 63px;
  background: #f0ece5;
  border: 1px solid rgba(140, 130, 120, 0.3);
  border-radius: 4px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
  cursor: pointer;
  transition: all 0.2s;
}

.hand-card.is-selected {
  border-color: #c4a77d;
  border-width: 3px;
  box-shadow: 0 0 10px rgba(196, 167, 125, 0.4);
  transform: translateY(-4px);
}

.hand-card.card-red {
  color: #b56565;
}

.hand-card.card-black {
  color: #4a4a4a;
}

.hand-card.card-joker {
  background: linear-gradient(135deg, #f0ece5 0%, #e8e0d5 100%);
  color: #8b4513;
}

.card-content {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 2px;
}

.card-rank {
  font-size: 0.9rem;
  font-weight: bold;
}

.card-suit {
  font-size: 0.9rem;
}

/* 操作栏 - 在手牌区域上方 (手牌区域高度约148px) */
.action-bar {
  position: fixed;
  bottom: 148px;
  left: 0;
  right: 0;
  padding: 10px 16px;
  background: rgba(45, 42, 40, 0.95);
  border-top: 1px solid rgba(180, 170, 160, 0.1);
  z-index: 60;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.rank-selector {
  overflow-x: auto;
}

.rank-scroll {
  display: flex;
  gap: 8px;
  padding-bottom: 4px;
}

.rank-chip {
  flex-shrink: 0;
  padding: 8px 14px;
  background: rgba(60, 57, 54, 0.8);
  border: 1px solid rgba(180, 170, 160, 0.25);
  border-radius: 16px;
  color: rgba(220, 210, 200, 0.85);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s;
}

.rank-chip.is-selected {
  background: #c4a77d;
  border-color: #c4a77d;
  color: #2d2a28;
  font-weight: 600;
}

.action-buttons {
  display: flex;
  gap: 12px;
}

.btn {
  flex: 1;
  padding: 12px 20px;
  background: transparent;
  border: 1px solid rgba(180, 170, 160, 0.35);
  border-radius: 8px;
  font-family: inherit;
  font-size: 0.9rem;
  cursor: pointer;
  color: rgba(220, 210, 200, 0.85);
  letter-spacing: 0.5px;
  transition: all 0.2s;
}

.btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.btn-play {
  background: #c4a77d;
  border-color: #c4a77d;
  color: #2d2a28;
  font-weight: 600;
}

.btn-challenge {
  background: #b56565;
  border-color: #b56565;
  color: #fff;
}

.btn-skip {
  background: rgba(100, 100, 100, 0.5);
  border-color: rgba(180, 170, 160, 0.35);
  color: rgba(220, 210, 200, 0.85);
}

.btn-confirm {
  background: #c4a77d;
  border-color: #c4a77d;
  color: #2d2a28;
  font-weight: 600;
}

.btn-highlight {
  background: #c4a77d;
  border-color: #c4a77d;
  color: #2d2a28;
}

/* 弹窗 */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 200;
  padding: 20px;
}

.modal-content {
  background: #2d2a28;
  border-radius: 12px;
  width: 90%;
  max-width: 400px;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(180, 170, 160, 0.15);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.15);
  background: rgba(45, 42, 40, 0.95);
}

.modal-header h2 {
  margin: 0;
  font-size: 1.1rem;
  color: #c4a77d;
}

.modal-header.success {
  background: rgba(139, 154, 109, 0.2);
}

.modal-header.success h2 {
  color: #8b9a6d;
}

.modal-header:not(.success) {
  background: rgba(181, 101, 101, 0.2);
}

.modal-header:not(.success) h2 {
  color: #b56565;
}

.modal-close {
  width: 28px;
  height: 28px;
  border: none;
  background: none;
  font-size: 1.5rem;
  cursor: pointer;
  color: rgba(180, 170, 160, 0.6);
}

.modal-body {
  padding: 16px;
  background: rgba(45, 42, 40, 0.95);
}

.modal-body.center {
  text-align: center;
}

.modal-footer {
  display: flex;
  gap: 12px;
  padding: 16px;
  border-top: 1px solid rgba(180, 170, 160, 0.1);
}

/* 规则内容 */
.rule-section {
  margin-bottom: 16px;
}

.rule-section h3 {
  font-size: 0.95rem;
  margin: 0 0 8px 0;
  color: rgba(220, 210, 200, 0.9);
}

.rule-section p {
  font-size: 0.85rem;
  line-height: 1.5;
  color: rgba(180, 170, 160, 0.75);
  margin: 0;
}

/* 质疑结果 */
.challenge-players {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  padding: 8px;
  background: rgba(180, 170, 160, 0.08);
  border-radius: 6px;
  flex-wrap: wrap;
}

.challenger,
.challenged {
  font-size: 0.8rem;
  color: rgba(220, 210, 200, 0.9);
}

.vs {
  font-size: 0.7rem;
  color: #c4a77d;
  font-weight: 600;
  padding: 2px 6px;
  background: rgba(196, 167, 125, 0.15);
  border-radius: 4px;
}

.result-text {
  text-align: center;
  font-size: 0.9rem;
  color: rgba(200, 190, 180, 0.9);
  margin-bottom: 16px;
}

.revealed-cards {
  display: flex;
  gap: 10px;
  justify-content: center;
  flex-wrap: wrap;
  margin: 16px 0;
}

.revealed-card {
  width: 45px;
  height: 63px;
  background: #f0ece5;
  border: 1px solid rgba(140, 130, 120, 0.3);
  border-radius: 4px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
}

.revealed-card.card-red {
  color: #b56565;
}

.revealed-card.card-black {
  color: #4a4a4a;
}

.result-summary {
  text-align: center;
  font-size: 0.9rem;
  color: #c4a77d;
  margin-top: 12px;
}

/* 游戏结束 */
.winner-display {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  padding: 24px;
}

.winner-icon {
  font-size: 48px;
}

.winner-name {
  font-size: 1.2rem;
  color: #c4a77d;
  font-weight: 600;
}

/* 日志列表 */
.log-list {
  max-height: 300px;
  overflow-y: auto;
}

.log-item {
  padding: 8px 0;
  border-bottom: 1px solid rgba(180, 170, 160, 0.1);
  font-size: 0.8rem;
  color: rgba(200, 190, 180, 0.8);
}

.log-item:last-child {
  border-bottom: none;
}
</style>

--- src/components/MainMenu.vue ---
<template>
  <div class="menu">
    <div class="book-page">
      <header class="page-header">
        <h1>目录 CONTENTS</h1>
        <span>Vol. 2024</span>
      </header>

      <nav>
        <ul class="toc-list">
          <li>
            <a href="#" class="toc-item" @click.prevent="startBankGame">
              <div class="toc-content">
                <span class="game-index">01</span>
                <span class="game-title">扑克抢银行</span>
              </div>
            </a>
          </li>
          <li>
            <a href="#" class="toc-item" @click.prevent="startBluffGame">
              <div class="toc-content">
                <span class="game-index">02</span>
                <span class="game-title">吹牛皮</span>
              </div>
            </a>
          </li>
          <li>
            <a href="#" class="toc-item" @click.prevent="startTripleCardGame">
              <div class="toc-content">
                <span class="game-index">03</span>
                <span class="game-title">三卡对决</span>
              </div>
            </a>
          </li>
          <li>
            <a href="#" class="toc-item" @click.prevent="startSetGame">
              <div class="toc-content">
                <span class="game-index">04</span>
                <span class="game-title">形色牌</span>
              </div>
            </a>
          </li>
          <li>
            <a href="#" class="toc-item" @click.prevent="startMarbleGame">
              <div class="toc-content">
                <span class="game-index">05</span>
                <span class="game-title">弹珠大师</span>
              </div>
            </a>
          </li>
          <li>
            <a href="#" class="toc-item" @click.prevent="showSettings = true">
              <div class="toc-content">
                <span class="game-index">06</span>
                <span class="game-title">游戏设置</span>
              </div>
            </a>
          </li>
          <li>
            <a href="#" class="toc-item" @click.prevent="showRules = true">
              <div class="toc-content">
                <span class="game-index">06</span>
                <span class="game-title">规则说明</span>
              </div>
            </a>
          </li>
        </ul>
      </nav>

      <footer class="page-footer">
        <span class="page-number">- 1 -</span>
      </footer>
    </div>

    <div class="rules-modal" v-if="showSettings" @click.self="showSettings = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>游戏设置</h2>
          <button class="rules-close" @click="showSettings = false">×</button>
        </div>
        <div class="rules-body">
          <div class="settings-group">
            <div class="settings-label">
              <span class="label-dot"></span>
              电脑玩家数量
            </div>
            <div class="slider-wrapper">
              <input type="range" v-model="cpuCount" min="1" max="3" class="slider" />
              <div class="slider-marks">
                <span>1</span><span>2</span><span>3</span>
              </div>
            </div>
            <div class="settings-value">{{ cpuCount }} 人</div>
          </div>

          <div class="settings-group">
            <div class="settings-label">
              <span class="label-dot"></span>
              游戏轮数
            </div>
            <div class="slider-wrapper">
              <input type="range" v-model="roundCount" min="3" max="7" class="slider" />
              <div class="slider-marks">
                <span>3</span><span>5</span><span>7</span>
              </div>
            </div>
            <div class="settings-value">{{ roundCount }} 轮</div>
          </div>
        </div>
      </div>
    </div>

    <div class="rules-modal" v-if="showRules" @click.self="showRules = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>游戏规则</h2>
          <button class="rules-close" @click="showRules = false">×</button>
        </div>
        <div class="rules-body">
          <div class="rules-section">
            <h3>游戏目标</h3>
            <p>在可配置的轮次（默认5轮）结束后，累计积分最高的玩家获胜。玩家需通过合理分配手牌，在三种扑克小游戏（单张比大小、24点和、比三张）的每个小组中争取更高名次，从而最大化总分。</p>
          </div>

          <div class="rules-section">
            <h3>玩家配置</h3>
            <ul>
              <li>人类玩家：1名</li>
              <li>电脑对手数量：可配置 1~3 名，即总玩家数可为 2~4 人</li>
              <li>每轮每位玩家获得 12 张手牌（从一副去掉大小王的 52 张扑克中抽取）</li>
            </ul>
          </div>

          <div class="rules-section">
            <h3>游戏流程（每轮）</h3>
            <h4>1. 发牌</h4>
            <p>每轮开始前彻底洗牌，根据当前玩家总数 N，为每位玩家发放 12 张牌。剩余牌（52 - N×12）本轮弃用。</p>

            <h4>2. 分组阶段</h4>
            <p>玩家将 12 张手牌分成 6 组：</p>
            <ul>
              <li>单张（1张×6组）：各放入 1 张牌</li>
              <li>24点（2张×2组）：各放入 2 张牌</li>
              <li>比三张（3张×2组）：各放入 3 张牌</li>
            </ul>

            <h4>3. 确认与结算</h4>
            <p>玩家确认分组后，各组独立比大小或计算，得出排名并累计积分。</p>
          </div>

          <div class="rules-section">
            <h3>积分规则</h3>
            <p>设有 P 名玩家（P = 2,3,4），每组根据排名分配积分：</p>
            <ul>
              <li>第一名获得 P-1 分</li>
              <li>第二名获得 P-2 分</li>
              <li>……</li>
              <li>最后一名 0 分</li>
            </ul>
            <p class="rules-highlight">比三张组的得分翻倍（即第一名得 2×(P-1) 分，第二名得 2×(P-2) 分，以此类推）</p>
            <p>每组独立计分，立即累加到玩家的累计总分中。</p>
          </div>

          <div class="rules-section">
            <h3>轮次循环</h3>
            <p>完成一轮所有 6 组的比较与计分后，若已进行轮数达到设定值，则游戏结束，显示最终排名；否则进入下一轮（重新洗牌、发牌、分组）。</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref } from 'vue'
import gameStore from '../store/gameStore.js'
import setGameStore from '../store/setGameStore.js'
import bluffStore from '../store/bluffGameStore.js'
import bankGameStore from '../store/bankGameStore.js'
import marbleGameStore from '../store/marbleGameStore.js'

export default {
  name: 'MainMenu',
  setup () {
    const cpuCount = ref(1)
    const roundCount = ref(5)
    const showSettings = ref(false)
    const showRules = ref(false)

    const startBankGame = () => {
      // 默认2人游戏，可以在游戏内设置
      bankGameStore.initGame(2)
    }

    const startBluffGame = () => {
      bluffStore.initGame()
    }

    const startTripleCardGame = () => {
      gameStore.initGame(Number(cpuCount.value) + 1, Number(roundCount.value))
      gameStore.startNewRound()
      gameStore.gameType = 'tripleCard'
    }

    const startSetGame = () => {
      setGameStore.startGame()
    }

    const startMarbleGame = () => {
      marbleGameStore.startGame()
    }

    return {
      cpuCount,
      roundCount,
      showSettings,
      showRules,
      startBankGame,
      startBluffGame,
      startTripleCardGame,
      startSetGame,
      startMarbleGame
    }
  }
}
</script>

<style scoped>
.menu {
  min-height: 100vh;
  background-color: #f7f5f0;
  color: #2c2c2c;
  font-family: "Noto Serif SC", "Songti SC", "SimSun", serif;
  margin: 0;
  padding: 0;
  line-height: 1.8;
  display: flex;
  justify-content: center;
  position: relative;
}

.menu::before {
  content: "";
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;
  opacity: 0.14;
  background-image: url("image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  mix-blend-mode: multiply;
}

.book-page {
  width: 100%;
  max-width: 600px;
  padding: 80px 40px;
  box-sizing: border-box;
  position: relative;
  box-shadow: inset 20px 0 40px -20px rgba(0, 0, 0, 0.05);
}

.page-header {
  border-bottom: 2px solid #2c2c2c;
  padding-bottom: 20px;
  margin-bottom: 40px;
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
}

.page-header h1 {
  font-size: 1.5rem;
  margin: 0;
  font-weight: 700;
  letter-spacing: 0.1em;
}

.page-header span {
  font-family: "Helvetica Neue", Arial, sans-serif;
  font-size: 0.75rem;
  color: #8a7f70;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.toc-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.toc-item {
  margin-bottom: 24px;
  position: relative;
  display: block;
  text-decoration: none;
  color: #2c2c2c;
  transition: all 0.3s ease;
  cursor: pointer;
}

.toc-content {
  display: flex;
  align-items: baseline;
  border-bottom: 1px dotted rgba(44, 44, 44, 0.2);
  padding-bottom: 4px;
}

.game-index {
  font-family: "Helvetica Neue", Arial, sans-serif;
  font-size: 0.85rem;
  color: #8a7f70;
  margin-right: 15px;
  font-weight: 600;
  flex-shrink: 0;
}

.game-title {
  font-size: 1.1rem;
  font-weight: 500;
  flex-grow: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.toc-item:hover .game-title {
  color: #000;
  font-weight: 600;
}

.toc-item:hover .game-index {
  color: #2c2c2c;
}

.toc-item:hover .toc-content {
  border-bottom-style: solid;
  border-bottom-color: rgba(44, 44, 44, 0.6);
}

.page-footer {
  margin-top: 60px;
  text-align: center;
  font-family: "Helvetica Neue", Arial, sans-serif;
  font-size: 0.75rem;
  color: #8a7f70;
  opacity: 0.8;
}

.page-number {
  display: inline-block;
  border: 1px solid #8a7f70;
  padding: 4px 12px;
  border-radius: 50px;
}

.rules-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 20px;
}

.rules-content {
  background: #f7f5f0;
  border: 1px solid rgba(44, 44, 44, 0.2);
  border-radius: 12px;
  max-width: 700px;
  max-height: 80vh;
  width: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.rules-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 24px;
  border-bottom: 1px solid rgba(44, 44, 44, 0.2);
}

.rules-header h2 {
  margin: 0;
  font-size: 20px;
  color: #2c2c2c;
  font-weight: 600;
}

.rules-close {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(44, 44, 44, 0.05);
  border: 1px solid rgba(44, 44, 44, 0.2);
  border-radius: 6px;
  color: #2c2c2c;
  font-size: 24px;
  cursor: pointer;
  transition: all 0.2s;
}

.rules-close:hover {
  background: rgba(44, 44, 44, 0.1);
  color: #000;
}

.rules-body {
  flex: 1;
  overflow-y: auto;
  padding: 24px;
}

.rules-body::-webkit-scrollbar {
  width: 6px;
}

.rules-body::-webkit-scrollbar-track {
  background: rgba(44, 44, 44, 0.05);
}

.rules-body::-webkit-scrollbar-thumb {
  background: rgba(44, 44, 44, 0.2);
  border-radius: 3px;
}

.rules-section {
  margin-bottom: 24px;
}

.rules-section:last-child {
  margin-bottom: 0;
}

.rules-section h3 {
  margin: 0 0 12px 0;
  font-size: 16px;
  color: #8a7f70;
  font-weight: 600;
}

.rules-section h4 {
  margin: 16px 0 8px 0;
  font-size: 14px;
  color: #2c2c2c;
  font-weight: 600;
}

.rules-section p {
  margin: 0 0 12px 0;
  font-size: 14px;
  color: #2c2c2c;
  line-height: 1.8;
}

.rules-section ul {
  margin: 0 0 12px 0;
  padding-left: 20px;
}

.rules-section li {
  margin-bottom: 6px;
  font-size: 14px;
  color: #2c2c2c;
}

.rules-highlight {
  padding: 10px 12px;
  background: rgba(138, 127, 112, 0.1);
  border-left: 3px solid #8a7f70;
  border-radius: 4px;
  color: #2c2c2c;
  font-weight: 500;
}

.settings-group {
  margin-bottom: 28px;
}

.settings-group:last-child {
  margin-bottom: 0;
}

.settings-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: #2c2c2c;
  margin-bottom: 14px;
  letter-spacing: 1px;
}

.settings-label .label-dot {
  width: 6px;
  height: 6px;
  background: #8a7f70;
  border-radius: 50%;
}

.slider-wrapper {
  padding: 0 2px;
}

.slider {
  width: 100%;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(44, 44, 44, 0.1);
  border-radius: 2px;
  outline: none;
  cursor: pointer;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: #8a7f70;
  border-radius: 2px;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(138, 127, 112, 0.4);
  transition: transform 0.15s;
}

.slider::-webkit-slider-thumb:hover {
  transform: scale(1.1);
}

.slider-marks {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
  font-size: 10px;
  color: rgba(44, 44, 44, 0.4);
}

.settings-value {
  text-align: center;
  font-size: 24px;
  font-weight: 300;
  color: #8a7f70;
  margin-top: 12px;
  letter-spacing: 2px;
}

@media (max-width: 480px) {
  .book-page {
    padding: 40px 20px;
  }

  .game-title {
    font-size: 1rem;
  }
}

@media (max-width: 768px) {
  .menu {
    padding: 16px;
    align-items: flex-start;
    padding-top: 15vh;
  }

  .panel {
    width: 100%;
    max-width: 100%;
    margin: 0;
  }

  .panel-header {
    padding: 16px 20px;
  }

  .logo-icon {
    font-size: 24px;
  }

  .logo-text {
    font-size: 18px;
    letter-spacing: 3px;
  }

  .version {
    font-size: 12px;
  }

  .panel-body {
    padding: 24px 20px;
  }

  .config-group {
    margin-bottom: 24px;
  }

  .config-label {
    font-size: 13px;
    margin-bottom: 16px;
  }

  .label-dot {
    width: 8px;
    height: 8px;
  }

  .slider {
    height: 6px;
  }

  .slider::-webkit-slider-thumb {
    width: 24px;
    height: 24px;
  }

  .slider-marks {
    font-size: 12px;
    margin-top: 10px;
  }

  .config-value {
    font-size: 28px;
    margin-top: 16px;
  }

  .panel-footer {
    flex-direction: column;
    gap: 12px;
    padding: 20px;
  }

  .btn {
    padding: 16px 20px;
    font-size: 14px;
    letter-spacing: 3px;
    min-height: 52px;
  }
}

@media (max-width: 480px) {
  .menu {
    padding: 12px;
    padding-top: 10vh;
  }

  .panel-header {
    padding: 14px 16px;
  }

  .logo-text {
    font-size: 16px;
  }

  .panel-body {
    padding: 20px 16px;
  }

  .config-value {
    font-size: 24px;
  }

  .panel-footer {
    padding: 16px;
  }

  .btn {
    padding: 18px 20px;
    font-size: 15px;
    min-height: 56px;
  }
}

@media (hover: none) and (pointer: coarse) {
  .slider::-webkit-slider-thumb {
    width: 28px;
    height: 28px;
  }

  .btn {
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }

  .btn:active {
    transform: scale(0.98);
  }

  .btn-primary:active {
    background: #1d4ed8;
    box-shadow: 0 0 30px rgba(59, 130, 246, 0.6);
  }

  .btn-secondary:active {
    color: rgba(255, 255, 255, 0.95);
    border-color: rgba(255, 255, 255, 0.4);
    background: rgba(255, 255, 255, 0.05);
  }
}
</style>

--- src/components/MarbleGame.vue ---
<template>
  <div class="marble-game">
    <div class="game-container" ref="gameContainer">
      <canvas ref="canvasRef" class="game-canvas"></canvas>
      
      <div class="game-ui" :class="{ 'mobile': isMobile }">
        <div class="top-panel">
          <div class="game-title">
            <span class="title-icon">🔮</span>
            <span>弹珠大师</span>
          </div>
          <div class="turn-indicator" :class="currentPlayerClass">
            <span class="player-dot"></span>
            <span>{{ currentPlayerName }}的回合</span>
            <span v-if="gameState.isAIThinking" class="thinking">思考中...</span>
          </div>
        </div>

        <div class="message-panel" :class="gameState.messageType" v-if="gameState.message">
          {{ gameState.message }}
        </div>

        <div class="holes-progress">
          <div class="hole-item" 
               v-for="hole in gameState.holes" 
               :key="hole.id"
               :class="{ 
                 'occupied': hole.occupiedBy !== null,
                 'current-target': isCurrentTarget(hole),
                 'finish': hole.isFinish
               }">
            <span class="hole-number">{{ hole.order }}</span>
            <span class="hole-icon">{{ getHoleIcon(hole) }}</span>
          </div>
        </div>

        <div class="players-status">
          <div class="player-card" 
               v-for="player in gameState.players" 
               :key="player.id"
               :class="{ 
                 'active': gameState.currentPlayer === player.id,
                 'hunter': player.status === 'HUNTER',
                 'finished': player.finished
               }">
            <div class="player-avatar" :style="{ backgroundColor: '#' + player.color.toString(16).padStart(6, '0') }">
              {{ player.name[0] }}
            </div>
            <div class="player-info">
              <div class="player-name">{{ player.name }}</div>
              <div class="player-status">{{ getStatusText(player) }}</div>
              <div class="holes-count">已占领: {{ player.holesOccupied.length }}/3</div>
            </div>
          </div>
        </div>

        <div class="controls">
          <button class="btn btn-secondary" @click="resetCamera">重置视角</button>
          <button class="btn btn-primary" @click="showRules = true">规则</button>
          <button class="btn btn-danger" @click="backToMenu">退出</button>
        </div>

        <div class="power-indicator" v-if="inputManager?.isDragging">
          <div class="power-bar">
            <div class="power-fill" :style="{ width: (forceRatio * 100) + '%' }"></div>
          </div>
          <span class="power-text">力度: {{ Math.round(forceRatio * 100) }}%</span>
        </div>
      </div>

      <div class="start-screen" v-if="gameState.phase === 'MENU'">
        <div class="start-panel">
          <h1>🔮 弹珠大师</h1>
          <p class="subtitle">挖坑玩法 · 物理弹射</p>
          <div class="rules-preview">
            <h3>游戏规则</h3>
            <ul>
              <li>资格赛：离第一个坑最近者获得先手</li>
              <li>按顺序占领3个坑位</li>
              <li>占领3坑后进入猎人模式，可攻击对手</li>
              <li>率先进入终点坑者获胜</li>
            </ul>
          </div>
          <button class="btn btn-start" @click="startGame">开始游戏</button>
        </div>
      </div>

      <div class="game-over-screen" v-if="gameState.phase === 'GAMEOVER'">
        <div class="game-over-panel">
          <h1>🎉 游戏结束</h1>
          <div class="winner-display">
            <div class="winner-avatar" :style="{ backgroundColor: '#' + winnerColor }">
              {{ winnerName[0] }}
            </div>
            <p class="winner-text">{{ winnerName }} 获胜！</p>
          </div>
          <div class="game-over-actions">
            <button class="btn btn-primary" @click="restartGame">再来一局</button>
            <button class="btn btn-secondary" @click="backToMenu">返回菜单</button>
          </div>
        </div>
      </div>

      <div class="rules-modal" v-if="showRules" @click.self="showRules = false">
        <div class="rules-content">
          <div class="rules-header">
            <h2>游戏规则</h2>
            <button class="rules-close" @click="showRules = false">×</button>
          </div>
          <div class="rules-body">
            <div class="rules-section">
              <h3>🎯 游戏目标</h3>
              <p>按顺序占领3个坑位，然后进入终点坑获胜。</p>
            </div>
            <div class="rules-section">
              <h3>🎮 操作方式</h3>
              <p>拖拽弹珠进行弹射，力度越大飞得越远。</p>
            </div>
            <div class="rules-section">
              <h3>🏆 资格赛</h3>
              <p>开局所有玩家弹射一次，离第一个坑最近者获得先手权。</p>
            </div>
            <div class="rules-section">
              <h3>⚔️ 猎人模式</h3>
              <p>占领3个坑后进入猎人模式，可以撞击对手使其回到起点！</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted, computed, nextTick } from 'vue'
import { useRafFn, useElementSize } from '@vueuse/core'
import * as THREE from 'three'
import {
  SceneManager,
  PhysicsManager,
  InputManager,
  AIPlayer,
  createGameState,
  GamePhase,
  TurnPhase,
  initQualifying,
  startGame,
  endQualifying,
  nextTurn,
  occupyHole,
  resetPlayerToStart,
  getCurrentTargetHole,
  resetGame
} from '../utils/marbleGame/index.js'
import deviceDetector from '../utils/deviceDetector.js'

export default {
  name: 'MarbleGame',
  emits: ['back-to-menu'],
  setup(props, { emit }) {
    const gameContainer = ref(null)
    const canvasRef = ref(null)
    const isMobile = ref(false)
    const showRules = ref(false)
    
    let sceneManager = null
    let physicsManager = null
    let inputManager = null
    let aiPlayer = null
    let gameLoop = null
    
    const gameState = createGameState()
    const forceRatio = ref(0)
    
    const ballMeshes = new Map()
    const holeMeshes = new Map()
    let aimLine = null
    let particleSystems = []
    
    const qualifyingResults = []
    let isProcessingTurn = false

    const currentPlayerName = computed(() => {
      const player = gameState.players[gameState.currentPlayer]
      return player ? player.name : ''
    })

    const currentPlayerClass = computed(() => {
      const player = gameState.players[gameState.currentPlayer]
      if (!player) return ''
      return {
        'player-0': player.id === 0,
        'player-1': player.id === 1,
        'hunter': player.status === 'HUNTER'
      }
    })

    const winnerName = computed(() => {
      if (gameState.winner === null) return ''
      return gameState.players[gameState.winner]?.name || ''
    })

    const winnerColor = computed(() => {
      if (gameState.winner === null) return '000000'
      const color = gameState.players[gameState.winner]?.color || 0
      return color.toString(16).padStart(6, '0')
    })

    const initGame = () => {
      console.log('=== initGame 开始 ===')
      console.log('gameContainer:', gameContainer.value)
      console.log('container尺寸:', gameContainer.value?.clientWidth, gameContainer.value?.clientHeight)
      
      isMobile.value = deviceDetector.isMobile()
      
      sceneManager = new SceneManager(gameContainer.value)
      console.log('sceneManager 初始化完成')
      console.log('scene:', sceneManager.scene)
      console.log('camera:', sceneManager.camera)
      console.log('renderer:', sceneManager.renderer)
      
      physicsManager = new PhysicsManager()
      console.log('physicsManager 初始化完成')
      
      createLevel()
      createBalls()
      
      console.log('创建输入管理器')
      inputManager = new InputManager(
        gameContainer.value,
        sceneManager.camera,
        sceneManager.scene
      )
      
      setupInputHandlers()
      setupPhysicsCallbacks()
      
      aiPlayer = new AIPlayer(gameState, physicsManager)
      
      console.log('启动游戏循环')
      gameLoop = useRafFn(() => {
        update()
      })
      
      // 立即渲染一帧测试
      sceneManager.render()
      console.log('立即渲染一帧')
      
      console.log('=== initGame 完成 ===')
    }

    const createLevel = () => {
      console.log('=== createLevel 开始 ===')
      const width = 30
      const depth = 40
      
      // 添加测试立方体
      const testCube = new THREE.Mesh(
        new THREE.BoxGeometry(2, 2, 2),
        new THREE.MeshStandardMaterial({ color: 0xff0000 })
      )
      testCube.position.set(0, 2, 0)
      testCube.castShadow = true
      sceneManager.scene.add(testCube)
      console.log('测试立方体已添加')
      
      // 简化：先不使用高度图，确保基本功能正常
      const ground = sceneManager.createGround(width, depth, null)
      console.log('地面创建:', ground)
      physicsManager.createGround(width, depth, null)
      
      console.log('坑位数据:', gameState.holes)
      gameState.holes.forEach(hole => {
        const holeMesh = sceneManager.createHole(hole.x, hole.z, hole.radius)
        console.log('坑创建:', hole.id, holeMesh)
        holeMeshes.set(hole.id, holeMesh)
        
        physicsManager.createHoleTrigger(
          hole.x, hole.z, hole.radius,
          hole.id, hole.isFinish
        )
      })
      console.log('=== createLevel 完成 ===')
    }

    const createBalls = () => {
      console.log('=== createBalls 开始 ===')
      gameState.players.forEach((player, index) => {
        const xOffset = (index === 0) ? -2 : 2
        const position = { x: xOffset, y: 1, z: 5 }
        
        console.log('创建球:', player.name, '位置:', position)
        const ballMesh = sceneManager.createBall(
          0.4,
          player.color,
          new THREE.Vector3(position.x, position.y, position.z)
        )
        console.log('球Mesh:', ballMesh, '位置:', ballMesh?.position)
        ballMeshes.set(player.id, ballMesh)
        
        const ballBody = physicsManager.createBall(
          0.4,
          position,
          player.id,
          player.color
        )
      })
      console.log('=== createBalls 完成 ===')
    }

    const setupInputHandlers = () => {
      inputManager.onDragStart = (position) => {
        if (gameState.currentPlayer !== 0) return
        if (gameState.turnPhase !== TurnPhase.AIMING) return
        
        gameState.turnPhase = TurnPhase.MOVING
      }
      
      inputManager.onDragMove = (position, direction, ratio) => {
        forceRatio.value = ratio
        
        if (aimLine) {
          const endPoint = inputManager.getAimEndPoint()
          if (endPoint) {
            sceneManager.updateAimLine(aimLine, position, endPoint)
          }
        } else {
          const endPoint = inputManager.getAimEndPoint()
          if (endPoint) {
            aimLine = sceneManager.createAimLine(position, endPoint)
          }
        }
      }
      
      inputManager.onDragEnd = (force) => {
        if (aimLine) {
          sceneManager.removeAimLine(aimLine)
          aimLine = null
        }
        
        if (force.magnitude > 0.5) {
          physicsManager.applyImpulse(gameState.currentPlayer, force)
          gameState.turnPhase = TurnPhase.RESOLVING
          
          setTimeout(() => checkTurnEnd(), 100)
        } else {
          gameState.turnPhase = TurnPhase.AIMING
        }
        
        forceRatio.value = 0
      }
    }

    const setupPhysicsCallbacks = () => {
      physicsManager.onBallEnterHole = (playerId, holeId, isFinish) => {
        handleBallEnterHole(playerId, holeId, isFinish)
      }
      
      physicsManager.addCollisionListener((bodyA, bodyB, event) => {
        if (bodyA.playerId !== undefined && bodyB.playerId !== undefined) {
          handleBallCollision(bodyA, bodyB)
        }
      })
    }

    const handleBallEnterHole = (playerId, holeId, isFinish) => {
      if (gameState.phase === GamePhase.QUALIFYING) {
        const ballPos = physicsManager.getBallPosition(playerId)
        const firstHole = gameState.holes[0]
        const distance = Math.sqrt(
          Math.pow(ballPos.x - firstHole.x, 2) +
          Math.pow(ballPos.z - firstHole.z, 2)
        )
        
        qualifyingResults.push({ playerId, distance })
        
        if (qualifyingResults.length === gameState.players.length) {
          endQualifying(gameState, qualifyingResults)
          resetAllBalls()
        }
      } else if (gameState.phase === GamePhase.PLAYING) {
        const success = occupyHole(gameState, playerId, holeId)
        
        if (success) {
          const hole = gameState.holes.find(h => h.id === holeId)
          const holeMesh = holeMeshes.get(holeId)
          
          if (holeMesh) {
            const particleSys = sceneManager.createParticleEffect(
              holeMesh.position,
              gameState.players[playerId].color,
              30
            )
            particleSystems.push(particleSys)
          }
          
          setTimeout(() => {
            if (gameState.phase !== GamePhase.GAMEOVER) {
              nextTurn(gameState)
              resetBallForNextTurn()
            }
          }, 1500)
        } else {
          setTimeout(() => {
            physicsManager.resetBallPosition(playerId, getStartPosition(playerId))
          }, 1000)
        }
      }
    }

    const handleBallCollision = (bodyA, bodyB) => {
      const playerA = gameState.players[bodyA.playerId]
      const playerB = gameState.players[bodyB.playerId]
      
      if (playerA.status === 'HUNTER' && playerB.status !== 'HUNTER') {
        const particleSys = sceneManager.createParticleEffect(
          { x: bodyB.position.x, y: 0.5, z: bodyB.position.z },
          0xff6600,
          20
        )
        particleSystems.push(particleSys)
        
        resetPlayerToStart(gameState, bodyB.playerId)
        physicsManager.resetBallPosition(bodyB.playerId, getStartPosition(bodyB.playerId))
      }
    }

    const checkTurnEnd = () => {
      if (isProcessingTurn) return
      isProcessingTurn = true
      
      const checkInterval = setInterval(() => {
        if (physicsManager.isBallStopped(gameState.currentPlayer, 0.05)) {
          clearInterval(checkInterval)
          isProcessingTurn = false
          
          if (gameState.phase === GamePhase.PLAYING) {
            const player = gameState.players[gameState.currentPlayer]
            if (!player.finished) {
              nextTurn(gameState)
              resetBallForNextTurn()
            }
          }
        }
      }, 200)
    }

    const resetBallForNextTurn = () => {
      const player = gameState.players[gameState.currentPlayer]
      const ballPos = physicsManager.getBallPosition(player.id)
      
      if (ballPos && ballPos.y < -5) {
        physicsManager.resetBallPosition(player.id, getStartPosition(player.id))
      }
    }

    const resetAllBalls = () => {
      gameState.players.forEach(player => {
        physicsManager.resetBallPosition(player.id, getStartPosition(player.id))
      })
    }

    const getStartPosition = (playerId) => {
      const player = gameState.players[playerId]
      const lastHoleId = player.holesOccupied[player.holesOccupied.length - 1]
      
      if (lastHoleId !== undefined) {
        const hole = gameState.holes.find(h => h.id === lastHoleId)
        return { x: hole.x, y: 1, z: hole.z + 3 }
      }
      
      const xOffset = (playerId === 0) ? -2 : 2
      return { x: xOffset, y: 1, z: 5 }
    }

    const processAITurn = async () => {
      if (gameState.currentPlayer !== 1) return
      if (gameState.phase !== GamePhase.PLAYING) return
      if (gameState.turnPhase !== TurnPhase.AIMING) return
      
      gameState.turnPhase = TurnPhase.MOVING
      
      const shot = await aiPlayer.makeMove()
      
      if (shot) {
        physicsManager.applyImpulse(gameState.currentPlayer, shot)
        gameState.turnPhase = TurnPhase.RESOLVING
        checkTurnEnd()
      } else {
        gameState.turnPhase = TurnPhase.AIMING
      }
    }

    let frameCount = 0
    
    const update = () => {
      frameCount++
      if (frameCount % 60 === 0) {
        console.log('update运行中，帧:', frameCount, 
          '球位置:', ballMeshes.get(0)?.position,
          '球位置:', ballMeshes.get(1)?.position)
      }
      
      const dt = 1 / 60
      
      physicsManager.step(dt)
      
      // 调试：检查球的位置
      ballMeshes.forEach((mesh, playerId) => {
        const body = physicsManager.bodies.balls.find(b => b.playerId === playerId)
        if (body && mesh) {
          mesh.position.copy(body.position)
          mesh.quaternion.copy(body.quaternion)
        }
      })
      
      const currentBallPos = physicsManager.getBallPosition(gameState.currentPlayer)
      if (currentBallPos) {
        sceneManager.setCameraTarget(currentBallPos, { x: 0, y: 12, z: 15 })
      }
      
      particleSystems = particleSystems.filter(sys => 
        sceneManager.updateParticles(sys, dt)
      )
      
      sceneManager.render()
      
      if (gameState.phase === GamePhase.PLAYING && 
          gameState.currentPlayer === 1 && 
          gameState.turnPhase === TurnPhase.AIMING &&
          !gameState.isAIThinking) {
        processAITurn()
      }
    }

    const startGame = () => {
      initQualifying(gameState)
      resetAllBalls()
    }

    const restartGame = () => {
      resetGame(gameState)
      resetAllBalls()
      initQualifying(gameState)
    }

    const backToMenu = () => {
      if (gameLoop) gameLoop.pause()
      emit('back-to-menu')
    }

    const resetCamera = () => {
      const currentBallPos = physicsManager.getBallPosition(gameState.currentPlayer)
      if (currentBallPos) {
        sceneManager.camera.position.set(0, 15, 20)
        sceneManager.camera.lookAt(currentBallPos)
      }
    }

    const isCurrentTarget = (hole) => {
      const player = gameState.players[gameState.currentPlayer]
      if (!player) return false
      const target = getCurrentTargetHole(gameState, player.id)
      return target && target.id === hole.id
    }

    const getHoleIcon = (hole) => {
      if (hole.isFinish) return '🏁'
      if (hole.occupiedBy !== null) return '✓'
      return '○'
    }

    const getStatusText = (player) => {
      if (player.finished) return '已完成'
      if (player.status === 'HUNTER') return '🔥 猎人模式'
      return '正常'
    }

    onMounted(() => {
      // 添加全局错误处理
      window.onerror = function(msg, url, lineNo, columnNo, error) {
        console.error('全局错误:', msg, '行:', lineNo, '列:', columnNo, error)
        return false
      }
      
      window.onunhandledrejection = function(event) {
        console.error('未处理的Promise拒绝:', event.reason)
      }
      
      nextTick(() => {
        setTimeout(() => {
          initGame()
        }, 100)
      })
    })

    onUnmounted(() => {
      if (gameLoop) gameLoop.pause()
      if (inputManager) inputManager.dispose()
      if (sceneManager) sceneManager.dispose()
      if (physicsManager) physicsManager.dispose()
    })

    return {
      gameContainer,
      canvasRef,
      gameState,
      isMobile,
      showRules,
      currentPlayerName,
      currentPlayerClass,
      winnerName,
      winnerColor,
      forceRatio,
      inputManager,
      startGame,
      restartGame,
      backToMenu,
      resetCamera,
      isCurrentTarget,
      getHoleIcon,
      getStatusText
    }
  }
}
</script>

<style scoped>
.marble-game {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  background: #87CEEB;
  position: fixed;
  top: 0;
  left: 0;
}

.marble-game::before {
  content: "";
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;
  opacity: 0.12;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  mix-blend-mode: overlay;
}

.game-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.game-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
  cursor: grab;
}

.game-canvas:active {
  cursor: grabbing;
}

.game-ui {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  padding: 20px;
  box-sizing: border-box;
}

.game-ui > * {
  pointer-events: auto;
}

.top-panel {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(26, 26, 46, 0.9);
  padding: 12px 20px;
  border-radius: 12px;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.game-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 1.2rem;
  font-weight: 600;
  color: #fff;
}

.title-icon {
  font-size: 1.4rem;
}

.turn-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border-radius: 20px;
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  font-weight: 500;
}

.turn-indicator.player-0 {
  background: rgba(231, 76, 60, 0.3);
  border: 1px solid rgba(231, 76, 60, 0.5);
}

.turn-indicator.player-1 {
  background: rgba(52, 152, 219, 0.3);
  border: 1px solid rgba(52, 152, 219, 0.5);
}

.turn-indicator.hunter {
  background: rgba(255, 193, 7, 0.3);
  border: 1px solid rgba(255, 193, 7, 0.5);
  animation: hunterPulse 1s ease-in-out infinite;
}

@keyframes hunterPulse {
  0%, 100% { box-shadow: 0 0 5px rgba(255, 193, 7, 0.5); }
  50% { box-shadow: 0 0 20px rgba(255, 193, 7, 0.8); }
}

.player-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: currentColor;
}

.thinking {
  font-size: 0.8rem;
  opacity: 0.8;
  animation: thinkingDots 1.5s infinite;
}

@keyframes thinkingDots {
  0%, 20% { content: '思考中.'; }
  40% { content: '思考中..'; }
  60%, 100% { content: '思考中...'; }
}

.message-panel {
  position: absolute;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 24px;
  border-radius: 8px;
  font-weight: 500;
  animation: messageSlide 0.3s ease;
}

.message-panel.info {
  background: rgba(52, 152, 219, 0.9);
  color: #fff;
}

.message-panel.success {
  background: rgba(46, 204, 113, 0.9);
  color: #fff;
}

.message-panel.error {
  background: rgba(231, 76, 60, 0.9);
  color: #fff;
}

.message-panel.warning {
  background: rgba(255, 193, 7, 0.9);
  color: #000;
}

@keyframes messageSlide {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

.holes-progress {
  position: absolute;
  top: 80px;
  right: 20px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  background: rgba(26, 26, 46, 0.9);
  padding: 16px;
  border-radius: 12px;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.hole-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 12px;
  border-radius: 8px;
  background: rgba(255, 255, 255, 0.05);
  transition: all 0.3s ease;
}

.hole-item.occupied {
  background: rgba(46, 204, 113, 0.2);
  border: 1px solid rgba(46, 204, 113, 0.5);
}

.hole-item.current-target {
  background: rgba(255, 193, 7, 0.2);
  border: 1px solid rgba(255, 193, 7, 0.5);
  animation: targetGlow 1.5s ease-in-out infinite;
}

.hole-item.finish {
  border: 1px solid rgba(231, 76, 60, 0.5);
}

@keyframes targetGlow {
  0%, 100% { box-shadow: 0 0 5px rgba(255, 193, 7, 0.3); }
  50% { box-shadow: 0 0 15px rgba(255, 193, 7, 0.6); }
}

.hole-number {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  font-size: 0.8rem;
  font-weight: 600;
  color: #fff;
}

.hole-icon {
  font-size: 1.2rem;
}

.players-status {
  position: absolute;
  top: 80px;
  left: 20px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.player-card {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  background: rgba(26, 26, 46, 0.9);
  border-radius: 12px;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: all 0.3s ease;
  min-width: 180px;
}

.player-card.active {
  border-color: rgba(255, 255, 255, 0.3);
  box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
}

.player-card.hunter {
  border-color: rgba(255, 193, 7, 0.5);
  background: rgba(255, 193, 7, 0.1);
}

.player-card.finished {
  opacity: 0.7;
  border-color: rgba(46, 204, 113, 0.5);
}

.player-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  color: #fff;
  font-size: 1.1rem;
}

.player-info {
  flex: 1;
}

.player-name {
  font-weight: 600;
  color: #fff;
  margin-bottom: 2px;
}

.player-status {
  font-size: 0.75rem;
  color: rgba(255, 255, 255, 0.7);
  margin-bottom: 2px;
}

.holes-count {
  font-size: 0.75rem;
  color: rgba(255, 255, 255, 0.5);
}

.controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 8px;
}

.btn {
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border: none;
  font-size: 0.9rem;
}

.btn-primary {
  background: #3498db;
  color: #fff;
}

.btn-primary:hover {
  background: #2980b9;
  transform: translateY(-2px);
}

.btn-secondary {
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.btn-secondary:hover {
  background: rgba(255, 255, 255, 0.2);
}

.btn-danger {
  background: rgba(231, 76, 60, 0.8);
  color: #fff;
}

.btn-danger:hover {
  background: rgba(231, 76, 60, 1);
}

.btn-start {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: #fff;
  padding: 16px 48px;
  font-size: 1.2rem;
  border-radius: 30px;
  margin-top: 24px;
}

.btn-start:hover {
  transform: translateY(-3px);
  box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
}

.power-indicator {
  position: absolute;
  bottom: 100px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.power-bar {
  width: 200px;
  height: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  overflow: hidden;
}

.power-fill {
  height: 100%;
  background: linear-gradient(90deg, #2ecc71 0%, #f1c40f 50%, #e74c3c 100%);
  transition: width 0.05s ease;
}

.power-text {
  color: #fff;
  font-size: 0.85rem;
  font-weight: 500;
}

.start-screen,
.game-over-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(26, 26, 46, 0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.start-panel,
.game-over-panel {
  background: rgba(255, 255, 255, 0.05);
  padding: 48px;
  border-radius: 24px;
  text-align: center;
  max-width: 500px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
}

.start-panel h1,
.game-over-panel h1 {
  color: #fff;
  font-size: 2.5rem;
  margin-bottom: 8px;
}

.subtitle {
  color: rgba(255, 255, 255, 0.6);
  font-size: 1.1rem;
  margin-bottom: 32px;
}

.rules-preview {
  text-align: left;
  background: rgba(0, 0, 0, 0.2);
  padding: 24px;
  border-radius: 12px;
  margin-bottom: 24px;
}

.rules-preview h3 {
  color: #fff;
  margin-bottom: 16px;
  font-size: 1.1rem;
}

.rules-preview ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.rules-preview li {
  color: rgba(255, 255, 255, 0.8);
  padding: 8px 0;
  padding-left: 24px;
  position: relative;
}

.rules-preview li::before {
  content: '•';
  position: absolute;
  left: 8px;
  color: #667eea;
}

.winner-display {
  margin: 32px 0;
}

.winner-avatar {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  margin: 0 auto 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  font-weight: 600;
  color: #fff;
  animation: winnerPulse 1s ease-in-out infinite;
}

@keyframes winnerPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

.winner-text {
  color: #fff;
  font-size: 1.5rem;
  font-weight: 600;
}

.game-over-actions {
  display: flex;
  gap: 16px;
  justify-content: center;
}

.rules-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 200;
}

.rules-content {
  background: #1a1a2e;
  border-radius: 16px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.rules-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 24px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.rules-header h2 {
  color: #fff;
  margin: 0;
  font-size: 1.3rem;
}

.rules-close {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  color: #fff;
  font-size: 1.5rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.rules-close:hover {
  background: rgba(255, 255, 255, 0.2);
}

.rules-body {
  padding: 24px;
  overflow-y: auto;
  max-height: 60vh;
}

.rules-section {
  margin-bottom: 24px;
}

.rules-section:last-child {
  margin-bottom: 0;
}

.rules-section h3 {
  color: #667eea;
  font-size: 1rem;
  margin-bottom: 8px;
}

.rules-section p {
  color: rgba(255, 255, 255, 0.8);
  line-height: 1.6;
  margin: 0;
}

@media (max-width: 768px) {
  .game-ui {
    padding: 12px;
  }
  
  .top-panel {
    flex-direction: column;
    gap: 8px;
    padding: 10px 16px;
  }
  
  .game-title {
    font-size: 1rem;
  }
  
  .holes-progress {
    top: auto;
    bottom: 80px;
    right: 12px;
    flex-direction: row;
    padding: 10px;
  }
  
  .hole-item {
    padding: 6px 8px;
  }
  
  .hole-number {
    width: 20px;
    height: 20px;
    font-size: 0.7rem;
  }
  
  .players-status {
    top: auto;
    bottom: 80px;
    left: 12px;
  }
  
  .player-card {
    padding: 8px 12px;
    min-width: 140px;
  }
  
  .player-avatar {
    width: 32px;
    height: 32px;
    font-size: 0.9rem;
  }
  
  .player-name {
    font-size: 0.85rem;
  }
  
  .player-status,
  .holes-count {
    font-size: 0.7rem;
  }
  
  .controls {
    bottom: 12px;
    right: 12px;
  }
  
  .btn {
    padding: 8px 14px;
    font-size: 0.8rem;
  }
  
  .start-panel,
  .game-over-panel {
    padding: 32px 24px;
    margin: 20px;
  }
  
  .start-panel h1,
  .game-over-panel h1 {
    font-size: 1.8rem;
  }
  
  .game-over-actions {
    flex-direction: column;
  }
}
</style>

--- src/components/ResultDisplay.vue ---
<template>
  <div class="result">
    <div class="bg-grid"></div>
    
    <div class="panel">
      <div v-if="isSetGame" class="set-result">
        <div class="panel-header">
          <div class="panel-title">游戏结束</div>
        </div>
        
        <div class="panel-body">
          <div class="winner-block">
            <div class="winner-label">找到组合</div>
            <div class="winner-name">{{ setStore.playerSetCount }}</div>
            <div class="winner-score">共 {{ setStore.totalSetsInDeck }} 个</div>
          </div>

          <div class="set-stats">
            <div class="stat-row">
              <span class="stat-label">得分</span>
              <span class="stat-value">{{ setStore.score }}</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">用时</span>
              <span class="stat-value">{{ formatTime(setStore.timeElapsed) }}</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">提示次数</span>
              <span class="stat-value">{{ setStore.hintsUsed }}</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">免费提示</span>
              <span class="stat-value">{{ setStore.hintsFree }}</span>
            </div>
          </div>
        </div>

        <div class="panel-footer">
          <button class="btn btn-highlight" @click="backToSetMenu">
            返回主菜单
          </button>
        </div>
      </div>

      <div v-else-if="gameStore.gamePhase === 'roundResult'" class="round-result">
        <div class="panel-header">
          <div class="panel-title">第 {{ gameStore.currentRound }} 轮结算</div>
        </div>
        
        <div class="panel-body">
          <div class="score-list">
            <div 
              v-for="player in sortedPlayers" 
              :key="player.id" 
              class="score-item"
              :class="{ 'is-winner': player.roundScore > 0 }"
            >
              <div class="score-info">
                <div class="score-name">{{ player.name }}</div>
                <div class="score-total">累计 {{ gameStore.totalScores[player.id] }} 分</div>
              </div>
              <div class="score-change">+{{ player.roundScore }}</div>
            </div>
          </div>
        </div>

        <div class="panel-footer">
          <button class="btn btn-highlight" @click="nextRound">
            {{ gameStore.isGameOver() ? '查看结果' : '下一轮' }}
          </button>
        </div>
      </div>

      <div v-else-if="gameStore.gamePhase === 'gameOver'" class="final-result">
        <div class="panel-header">
          <div class="panel-title">{{ gameStore.winner.isTie ? '平局' : '最终结果' }}</div>
        </div>
        
        <div class="panel-body">
          <div v-if="!gameStore.winner.isTie" class="winner-block">
            <div class="winner-label">冠军</div>
            <div class="winner-name">{{ gameStore.winner.winner.name }}</div>
            <div class="winner-score">{{ gameStore.winner.winner.score || gameStore.totalScores[gameStore.winner.winner.id] }} 分</div>
          </div>

          <div class="rankings">
            <div class="rankings-title">最终排名</div>
            <div 
              v-for="ranking in gameStore.winner.rankings" 
              :key="ranking.player.id"
              class="ranking-item"
              :class="{ 'top-3': ranking.rank <= 3 }"
            >
              <div class="rank-num">{{ ranking.rank }}</div>
              <div class="rank-name">{{ ranking.player.name }}</div>
              <div class="rank-score">{{ ranking.score }} 分</div>
            </div>
          </div>
        </div>

        <div class="panel-footer">
          <button class="btn btn-highlight" @click="backToMenu">
            返回主菜单
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { computed } from 'vue'
import gameStore from '../store/gameStore.js'
import setGameStore from '../store/setGameStore.js'

export default {
  name: 'ResultDisplay',
  setup() {
    const setStore = setGameStore

    const isSetGame = computed(() => {
      return setStore.gamePhase === 'gameOver'
    })

    const sortedPlayers = computed(() => {
      return [...gameStore.players]
        .map(p => ({
          ...p,
          roundScore: gameStore.roundScores[p.id] || 0
        }))
        .sort((a, b) => b.roundScore - a.roundScore)
    })

    const nextRound = () => {
      if (gameStore.isGameOver()) {
        gameStore.endGame()
      } else {
        gameStore.startNewRound()
      }
    }

    const backToMenu = () => {
      gameStore.reset()
      setStore.reset()
    }

    const backToSetMenu = () => {
      setStore.reset()
    }

    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60)
      const secs = seconds % 60
      return `${mins}:${secs.toString().padStart(2, '0')}`
    }

    return {
      gameStore,
      setStore,
      isSetGame,
      sortedPlayers,
      nextRound,
      backToMenu,
      backToSetMenu,
      formatTime
    }
  }
}
</script>

<style scoped>
.result {
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #0a0a0c;
  position: relative;
  font-family: 'JetBrains Mono', 'Consolas', monospace;
}

.bg-grid {
  position: absolute;
  inset: 0;
  background-image: 
    linear-gradient(rgba(96, 165, 250, 0.04) 1px, transparent 1px),
    linear-gradient(90deg, rgba(96, 165, 250, 0.04) 1px, transparent 1px);
  background-size: 20px 20px;
  pointer-events: none;
}

.panel {
  position: relative;
  width: 420px;
  background: rgba(20, 20, 25, 0.9);
  backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.08);
  box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
}

.panel-header {
  padding: 20px 24px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

.panel-title {
  font-size: 14px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.85);
  letter-spacing: 2px;
  text-align: center;
}

.panel-body {
  padding: 24px;
}

.panel-footer {
  padding: 16px 24px;
  border-top: 1px solid rgba(255, 255, 255, 0.08);
  display: flex;
  justify-content: center;
}

.score-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.score-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
}

.score-item.is-winner {
  background: rgba(59, 130, 246, 0.05);
  border-color: rgba(59, 130, 246, 0.2);
}

.score-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.score-name {
  font-size: 13px;
  color: rgba(255, 255, 255, 0.75);
}

.score-total {
  font-size: 11px;
  color: rgba(255, 255, 255, 0.35);
}

.score-change {
  font-size: 20px;
  color: #3b82f6;
  font-weight: 300;
}

.winner-block {
  text-align: center;
  padding: 24px;
  background: rgba(59, 130, 246, 0.05);
  border: 1px solid rgba(59, 130, 246, 0.2);
  margin-bottom: 24px;
}

.winner-label {
  font-size: 11px;
  color: rgba(255, 255, 255, 0.4);
  letter-spacing: 2px;
  margin-bottom: 8px;
}

.winner-name {
  font-size: 24px;
  color: #3b82f6;
  font-weight: 500;
  margin-bottom: 4px;
}

.winner-score {
  font-size: 14px;
  color: rgba(255, 255, 255, 0.5);
}

.set-stats {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 24px;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
}

.stat-label {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.5);
}

.stat-value {
  font-size: 14px;
  color: #8e44ad;
  font-weight: 600;
}

.rankings-title {
  font-size: 11px;
  color: rgba(255, 255, 255, 0.35);
  letter-spacing: 1px;
  margin-bottom: 12px;
  text-align: center;
}

.rankings {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.ranking-item {
  display: flex;
  align-items: center;
  padding: 12px;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
}

.ranking-item.top-3 {
  background: rgba(59, 130, 246, 0.03);
}

.rank-num {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  font-size: 12px;
  color: rgba(255, 255, 255, 0.5);
  margin-right: 12px;
}

.ranking-item:nth-child(2) .rank-num {
  background: rgba(255, 215, 0, 0.15);
  border-color: rgba(255, 215, 0, 0.3);
  color: #ffd700;
}

.ranking-item:nth-child(3) .rank-num {
  background: rgba(192, 192, 192, 0.15);
  border-color: rgba(192, 192, 192, 0.3);
  color: #c0c0c0;
}

.ranking-item:nth-child(4) .rank-num {
  background: rgba(205, 127, 50, 0.15);
  border-color: rgba(205, 127, 50, 0.3);
  color: #cd7f32;
}

.rank-name {
  flex: 1;
  font-size: 12px;
  color: rgba(255, 255, 255, 0.7);
}

.rank-score {
  font-size: 13px;
  color: #3b82f6;
}

.btn {
  padding: 14px 40px;
  font-size: 12px;
  font-family: inherit;
  letter-spacing: 2px;
  background: transparent;
  border: 1px solid rgba(255, 255, 255, 0.15);
  color: rgba(255, 255, 255, 0.5);
  cursor: pointer;
  transition: all 0.2s;
}

.btn:hover {
  border-color: rgba(255, 255, 255, 0.3);
  color: rgba(255, 255, 255, 0.85);
}

.btn-highlight {
  background: #3b82f6;
  border-color: #3b82f6;
  color: #0a0a0c;
}

.btn-highlight:hover {
  background: #06b6d4;
  border-color: #06b6d4;
}

@media (max-width: 768px) {
  .result {
    padding: 16px;
    align-items: flex-start;
    padding-top: 15vh;
  }

  .panel {
    width: 100%;
    max-width: 100%;
  }

  .panel-header {
    padding: 16px 20px;
  }

  .panel-title {
    font-size: 16px;
  }

  .panel-body {
    padding: 20px;
  }

  .panel-footer {
    padding: 16px 20px;
  }

  .score-item {
    padding: 14px;
  }

  .score-name {
    font-size: 14px;
  }

  .score-total {
    font-size: 12px;
  }

  .score-change {
    font-size: 22px;
  }

  .winner-block {
    padding: 20px;
  }

  .winner-label {
    font-size: 12px;
  }

  .winner-name {
    font-size: 22px;
  }

  .winner-score {
    font-size: 15px;
  }

  .rankings-title {
    font-size: 12px;
  }

  .ranking-item {
    padding: 14px;
  }

  .rank-num {
    width: 32px;
    height: 32px;
    font-size: 14px;
  }

  .rank-name {
    font-size: 14px;
  }

  .rank-score {
    font-size: 15px;
  }

  .btn {
    padding: 16px 32px;
    font-size: 14px;
    min-height: 52px;
  }
}

@media (max-width: 480px) {
  .result {
    padding: 12px;
    padding-top: 10vh;
  }

  .panel-header {
    padding: 14px 16px;
  }

  .panel-title {
    font-size: 15px;
  }

  .panel-body {
    padding: 16px;
  }

  .score-item {
    padding: 12px;
  }

  .score-change {
    font-size: 20px;
  }

  .winner-block {
    padding: 16px;
    margin-bottom: 16px;
  }

  .winner-name {
    font-size: 20px;
  }

  .ranking-item {
    padding: 12px;
  }

  .rank-num {
    width: 28px;
    height: 28px;
    font-size: 12px;
    margin-right: 10px;
  }

  .btn {
    padding: 18px 28px;
    font-size: 15px;
    min-height: 56px;
  }
}

@media (hover: none) and (pointer: coarse) {
  .btn {
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }

  .btn:active {
    transform: scale(0.98);
  }

  .btn-highlight:active {
    background: #1d4ed8;
  }
}
</style>

--- src/components/SetGameMobile.vue ---
<template>
  <div class="game">
    <header class="header">
      <div class="header-left">
        <div class="logo">
          <span class="logo-icon">◆</span>
          <span class="logo-text">形色牌</span>
        </div>
      </div>
      <div class="header-right">
        <button class="icon-btn home-btn" @click="backToMenu">⌂</button>
        <button class="icon-btn" @click="showRules = true">?</button>
      </div>
    </header>

    <div class="stats-bar">
      <div class="stat-item">
        <span class="stat-label">得分</span>
        <span class="stat-value">{{ setStore.score }}</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">时间</span>
        <span class="stat-value">{{ formatTime(setStore.timeElapsed) }}</span>
      </div>
    </div>

    <main class="workbench">
      <div class="board" ref="boardRef">
        <canvas ref="canvasRef" @click="handleCanvasClick"></canvas>
      </div>

      <div class="board-actions">
        <button class="btn" @click="setStore.addMoreCards" :disabled="setStore.deck.length < 3">
          追加
        </button>
        <button class="btn" @click="setStore.useHint"
          :disabled="setStore.hintsFree === 0 && setStore.deck.length === 0">
          提示 {{ setStore.hintsFree > 0 ? '(免费)' : '(-50分)' }}
        </button>
        <button class="btn btn-highlight" @click="handleGiveUp">
          放弃
        </button>
      </div>

      <div class="found-info">
        <span>卡牌: {{ setStore.deck.length }} 张</span>
        <span>提示: {{ setStore.hintsFree }} 次</span>
      </div>
    </main>

    <div class="rules-modal" v-if="showRules" @click.self="showRules = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>游戏规则</h2>
          <button class="rules-close" @click="showRules = false">×</button>
        </div>
        <div class="rules-body">
          <div class="rules-section">
            <h3>游戏目标</h3>
            <p>在最短时间内找出所有形色牌组合。</p>
          </div>

          <div class="rules-section">
            <h3>什么是组合？</h3>
            <p>3张卡牌满足以下条件即构成组合：</p>
            <ul>
              <li>颜色：3张相同或3张不同</li>
              <li>形状：3张相同或3张不同</li>
              <li>填充：3张相同或3张不同</li>
              <li>数量：3张相同或3张不同</li>
            </ul>
          </div>

          <div class="rules-section">
            <h3>操作方法</h3>
            <ul>
              <li>点击卡牌选择</li>
              <li>选3张后自动判断</li>
              <li>找到组合+100分</li>
              <li>使用提示-50分</li>
            </ul>
          </div>

          <div class="rules-section">
            <h3>卡牌属性</h3>
            <ul>
              <li>颜色: 红、绿、紫</li>
              <li>形状: 椭圆、正方形、菱形</li>
              <li>填充: 实心、条纹、空心</li>
              <li>数量: 1、2、3</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="rules-modal" v-if="showGiveUpConfirm" @click.self="showGiveUpConfirm = false">
      <div class="rules-content rules-content-small">
        <div class="rules-header">
          <h2>确认放弃</h2>
        </div>
        <div class="rules-body">
          <p>确定要放弃当前游戏吗？</p>
        </div>
        <div class="settings-footer">
          <button class="btn" @click="showGiveUpConfirm = false">取消</button>
          <button class="btn btn-highlight" @click="confirmGiveUp">确认</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted, watch } from 'vue'
import setGameStore from '../store/setGameStore.js'
import { drawCard } from '../utils/setCardRenderer.js'

export default {
  name: 'SetGameMobile',
  emits: ['back-to-menu'],
  setup (props, { emit }) {
    const showRules = ref(false)
    const showGiveUpConfirm = ref(false)
    const canvasRef = ref(null)
    const boardRef = ref(null)

    const CARD_WIDTH = 74
    const CARD_HEIGHT = 100
    const CARD_GAP = 11

    let ctx = null

    const setStore = setGameStore

    const calculateCanvasHeight = (cardCount) => {
      const cols = 3
      const rows = Math.ceil(cardCount / cols)
      return rows * CARD_HEIGHT + (rows - 1) * CARD_GAP + 40 // 40px padding
    }

    const render = () => {
      if (!ctx || !canvasRef.value) return

      const canvas = canvasRef.value
      const cards = setStore.boardCards
      const selectedIds = setStore.selectedCards.map(c => c.id)
      const hintCards = setStore.showHint ? setStore.hintCards : []
      const hintCardIds = hintCards.map(c => c.id)
      const dpr = window.devicePixelRatio || 1

      // 动态调整画布高度（考虑DPR）
      const minHeight = boardRef.value ? boardRef.value.clientHeight : 400
      const requiredHeight = calculateCanvasHeight(cards.length)
      const displayHeight = Math.max(minHeight, requiredHeight)
      canvas.style.height = displayHeight + 'px'
      canvas.height = displayHeight * dpr

      // 重新应用DPR缩放
      ctx.scale(dpr, dpr)

      ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr)

      const cols = 3
      const startX = (canvas.width / dpr - (cols * CARD_WIDTH + (cols - 1) * CARD_GAP)) / 2
      const startY = 20 // 顶部padding

      cards.forEach((card, index) => {
        const col = index % cols
        const row = Math.floor(index / cols)
        const x = startX + col * (CARD_WIDTH + CARD_GAP)
        const y = startY + row * (CARD_HEIGHT + CARD_GAP)

        const isSelected = selectedIds.includes(card.id)
        const isHint = hintCardIds.includes(card.id)

        drawCard(ctx, card, x, y, CARD_WIDTH, CARD_HEIGHT, isSelected, isHint, false)
      })
    }

    const getCardAtPosition = (x, y) => {
      if (!canvasRef.value) return null

      const canvas = canvasRef.value
      const cards = setStore.boardCards
      const dpr = window.devicePixelRatio || 1
      const cols = 3
      const startX = (canvas.width / dpr - (cols * CARD_WIDTH + (cols - 1) * CARD_GAP)) / 2
      const startY = 20 // 与render一致

      for (let i = 0; i < cards.length; i++) {
        const col = i % cols
        const row = Math.floor(i / cols)
        const cardX = startX + col * (CARD_WIDTH + CARD_GAP)
        const cardY = startY + row * (CARD_HEIGHT + CARD_GAP)

        if (x >= cardX && x <= cardX + CARD_WIDTH &&
          y >= cardY && y <= cardY + CARD_HEIGHT) {
          return cards[i]
        }
      }
      return null
    }

    const handleCanvasClick = (event) => {
      if (setStore.gamePhase !== 'playing') return

      const rect = canvasRef.value.getBoundingClientRect()
      // 直接使用相对于canvas的坐标，不需要乘以DPR
      const x = event.clientX - rect.left
      const y = event.clientY - rect.top

      const card = getCardAtPosition(x, y)
      if (card) {
        setStore.selectCard(card)
      }
    }

    const handleResize = () => {
      if (!boardRef.value || !canvasRef.value) return

      const board = boardRef.value
      const canvas = canvasRef.value
      const dpr = window.devicePixelRatio || 1

      // 设置显示大小
      canvas.style.width = board.clientWidth + 'px'

      // 设置实际像素大小（考虑DPR）
      canvas.width = board.clientWidth * dpr

      // 缩放上下文以匹配DPR
      ctx.scale(dpr, dpr)

      // 高度在 render 中动态计算

      render()
    }

    watch(() => setStore.boardCards.length, render)
    watch(() => setStore.boardCards, render, { deep: true })
    watch(() => setStore.selectedCards, render, { deep: true })
    watch(() => setStore.showHint, render)
    watch(() => setStore.hintCards, render, { deep: true })

    onMounted(() => {
      if (canvasRef.value) {
        ctx = canvasRef.value.getContext('2d')
        handleResize()
        window.addEventListener('resize', handleResize)
      }
    })

    onUnmounted(() => {
      window.removeEventListener('resize', handleResize)
    })

    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60)
      const secs = seconds % 60
      return `${mins}:${secs.toString().padStart(2, '0')}`
    }

    const handleGiveUp = () => {
      showGiveUpConfirm.value = true
    }

    const confirmGiveUp = () => {
      setStore.endGame()
      showGiveUpConfirm.value = false
    }

    const backToMenu = () => {
      setStore.endGame()
      emit('back-to-menu')
    }

    return {
      showRules,
      showGiveUpConfirm,
      setStore,
      canvasRef,
      boardRef,
      handleCanvasClick,
      formatTime,
      handleGiveUp,
      confirmGiveUp,
      backToMenu
    }
  }
}
</script>

<style scoped>
.game {
  min-height: 100vh;
  background: #1a1a1a;
  color: rgba(245, 240, 230, 0.95);
  font-family: 'JetBrains Mono', 'Consolas', monospace;
  display: flex;
  flex-direction: column;
  position: relative;
}

.game::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  opacity: 0.12;
  pointer-events: none;
  z-index: 1;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  background: rgba(45, 42, 40, 0.92);
  border-bottom: 1px solid rgba(180, 170, 160, 0.15);
  position: relative;
  z-index: 10;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 12px;
}

.logo {
  display: flex;
  align-items: center;
  gap: 6px;
}

.logo-icon {
  font-size: 1.25rem;
  color: #c4a77d;
}

.logo-text {
  font-size: 1.1rem;
  font-weight: 600;
  color: rgba(245, 240, 230, 0.95);
}

.header-right {
  display: flex;
  gap: 8px;
}

.icon-btn {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  border: 1px solid rgba(196, 167, 125, 0.3);
  background: rgba(196, 167, 125, 0.1);
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  color: #c4a77d;
}

.stats-bar {
  display: flex;
  justify-content: space-around;
  padding: 10px 16px;
  background: rgba(50, 47, 44, 0.85);
  border-bottom: 1px solid rgba(180, 170, 160, 0.1);
}

.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

.stat-label {
  font-size: 0.7rem;
  color: rgba(200, 190, 180, 0.7);
}

.stat-value {
  font-size: 1rem;
  font-weight: 600;
  color: #c4a77d;
}

.workbench {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 12px;
  gap: 12px;
}

.board {
  flex: 1;
  width: 100%;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  position: relative;
}

.board canvas {
  display: block;
  width: 100%;
  cursor: pointer;
}

.board-actions {
  display: flex;
  gap: 8px;
  justify-content: center;
}

.btn {
  flex: 1;
  padding: 10px 16px;
  background: transparent;
  border: 1px solid rgba(180, 170, 160, 0.35);
  border-radius: 6px;
  font-family: inherit;
  font-size: 0.8rem;
  cursor: pointer;
  color: rgba(220, 210, 200, 0.85);
  letter-spacing: 0.5px;
}

.btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.btn-highlight {
  background: #c4a77d;
  color: #2d2a28;
  border-color: #c4a77d;
}

.found-info {
  display: flex;
  justify-content: center;
  gap: 24px;
  font-size: 0.75rem;
  color: rgba(180, 170, 160, 0.65);
}

.rules-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.rules-content {
  background: #2d2a28;
  border-radius: 12px;
  width: 90%;
  max-width: 400px;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(180, 170, 160, 0.15);
}

.rules-content-small {
  max-width: 300px;
  padding: 20px;
}

.rules-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.15);
  background: rgba(45, 42, 40, 0.95);
}

.rules-header h2 {
  margin: 0;
  font-size: 1.1rem;
  color: #c4a77d;
}

.rules-close {
  width: 28px;
  height: 28px;
  border: none;
  background: none;
  font-size: 1.5rem;
  cursor: pointer;
  color: rgba(180, 170, 160, 0.6);
}

.rules-body {
  padding: 16px;
  background: rgba(45, 42, 40, 0.95);
}

.rules-section {
  margin-bottom: 16px;
}

.rules-section h3 {
  font-size: 0.95rem;
  margin: 0 0 8px 0;
  color: rgba(220, 210, 200, 0.9);
}

.rules-section p,
.rules-section li {
  font-size: 0.85rem;
  line-height: 1.5;
  color: rgba(180, 170, 160, 0.75);
}

.rules-section ul {
  margin: 0;
  padding-left: 20px;
}

.rules-section li {
  margin-bottom: 4px;
}

.settings-footer {
  display: flex;
  gap: 12px;
  padding: 16px;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}
</style>

--- src/components/SetGamePC.vue ---
<template>
  <div class="game">
    <header class="header">
      <div class="header-left">
        <div class="logo">
          <span class="logo-icon">◆</span>
          <span class="logo-text">形色牌</span>
        </div>
        <button class="rules-btn" @click="showRules = true">
          <span class="rules-icon">?</span>
          <span class="rules-text">规则说明</span>
        </button>
      </div>
      
      <div class="header-center">
        <div class="stat-block">
          <div class="stat-label">得分</div>
          <div class="stat-value">{{ setStore.score }}</div>
        </div>
        <div class="stat-block">
          <div class="stat-label">时间</div>
          <div class="stat-value">{{ formatTime(setStore.timeElapsed) }}</div>
        </div>
      </div>
      
      <div class="header-right">
        <button class="home-btn" @click="backToMenu">
          <span class="home-icon">⌂</span>
          <span class="home-text">首页</span>
        </button>
        <div class="timer">
          {{ formatTime(setStore.timeElapsed) }}
        </div>
      </div>
    </header>

    <div class="game-container">
      <aside class="sidebar">
        <div class="sidebar-section">
          <h3>操作说明</h3>
          <p>点击三张卡牌，如果它们满足以下条件则消除：</p>
          <ul class="rules-list">
            <li>颜色全部相同或全部不同</li>
            <li>形状全部相同或全部不同</li>
            <li>填充全部相同或全部不同</li>
            <li>数量全部相同或全部不同</li>
          </ul>
        </div>
        
        <div class="sidebar-section">
          <h3>卡牌堆</h3>
          <div class="deck-info">
            <div class="deck-item">
              <span class="deck-label">剩余卡牌</span>
              <span class="deck-value">{{ setStore.deck.length }}</span>
            </div>
            <div class="deck-item">
              <span class="deck-label">提示次数</span>
              <span class="deck-value">{{ setStore.hintsFree }}</span>
            </div>
          </div>
        </div>
      </aside>

      <main class="workbench">
        <div class="board" ref="boardRef">
          <canvas 
            ref="canvasRef"
            @click="handleCanvasClick"
          ></canvas>
        </div>
        
        <div class="board-actions">
          <button class="btn" @click="setStore.addMoreCards" :disabled="setStore.deck.length < 3">
            追加3张
          </button>
          <button class="btn" @click="setStore.useHint" :disabled="setStore.hintsFree === 0 && setStore.deck.length === 0">
            提示 {{ setStore.hintsFree > 0 ? '(免费)' : '(-50分)' }}
          </button>
          <button class="btn btn-highlight" @click="handleGiveUp">
            放弃游戏
          </button>
        </div>
      </main>
    </div>

    <div class="rules-modal" v-if="showRules" @click.self="showRules = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>游戏规则</h2>
          <button class="rules-close" @click="showRules = false">×</button>
        </div>
        <div class="rules-body">
          <div class="rules-section">
            <h3>游戏目标</h3>
            <p>在最短时间内找出所有形色牌组合。形色牌(Set)是一款考验观察力和反应速度的卡牌游戏。</p>
          </div>

          <div class="rules-section">
            <h3>什么是形色牌组合？</h3>
            <p>3张卡牌如果满足以下条件，则构成一个"组合"：</p>
            <ul>
              <li>颜色：3张完全相同 或 3张完全不同</li>
              <li>形状：3张完全相同 或 3张完全不同</li>
              <li>填充：3张完全相同 或 3张完全不同</li>
              <li>数量：3张完全相同 或 3张完全不同</li>
            </ul>
            <p class="rules-example">例如：3张卡的形状都不同、颜色都不同、填充都相同、数量都相同</p>
          </div>

          <div class="rules-section">
            <h3>操作方法</h3>
            <ul>
              <li>点击桌面上的卡牌进行选择</li>
              <li>选择3张卡牌后，系统会自动判断是否构成组合</li>
              <li>如果构成组合，卡牌会被移除，并获得100分</li>
              <li>如果不能构成组合，卡牌会自动取消选择</li>
              <li>点击"提示"按钮可获得提示（扣除50分）</li>
              <li>桌面卡牌不足时，可点击"追加3张"</li>
            </ul>
          </div>

          <div class="rules-section">
            <h3>卡牌属性</h3>
            <p>每张卡牌有4个属性，每个属性有3种变体：</p>
            <ul>
              <li>颜色：砖红、鼠尾草绿、灰紫</li>
              <li>形状：椭圆、波浪、菱形</li>
              <li>填充：实心、条纹、空心</li>
              <li>数量：1、2、3</li>
            </ul>
          </div>

          <div class="rules-section">
            <h3>计分规则</h3>
            <ul>
              <li>找到一个组合：+100分</li>
              <li>使用提示：-50分</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="rules-modal" v-if="showGiveUpConfirm" @click.self="showGiveUpConfirm = false">
      <div class="rules-content rules-content-small">
        <div class="rules-header">
          <h2>确认放弃</h2>
        </div>
        <div class="rules-body">
          <p>确定要放弃当前游戏吗？</p>
        </div>
        <div class="settings-footer">
          <button class="btn" @click="showGiveUpConfirm = false">取消</button>
          <button class="btn btn-highlight" @click="confirmGiveUp">确认</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted, watch } from 'vue'
import setGameStore from '../store/setGameStore.js'
import { drawCard } from '../utils/setCardRenderer.js'

export default {
  name: 'SetGamePC',
  emits: ['back-to-menu'],
  setup(props, { emit }) {
    const showRules = ref(false)
    const showGiveUpConfirm = ref(false)
    const canvasRef = ref(null)
    const boardRef = ref(null)
    
    const CARD_WIDTH = 100
    const CARD_HEIGHT = 150
    const CARD_GAP = 16
    
    let ctx = null
    
    const setStore = setGameStore

    const render = () => {
      if (!ctx || !canvasRef.value) return
      
      const canvas = canvasRef.value
      const cards = setStore.boardCards
      const selectedIds = setStore.selectedCards.map(c => c.id)
      const hintCards = setStore.showHint ? setStore.hintCards : []
      const animationCards = setStore.animationState.active ? setStore.animationState.cards : []
      const animationCardIds = animationCards.map(c => c.id)
      const hintCardIds = hintCards.map(c => c.id)
      
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      
      const cols = 6
      const startX = (canvas.width - (cols * CARD_WIDTH + (cols - 1) * CARD_GAP)) / 2
      const startY = (canvas.height - (Math.ceil(cards.length / cols) * CARD_HEIGHT + (Math.ceil(cards.length / cols) - 1) * CARD_GAP)) / 2
      
      cards.forEach((card, index) => {
        const col = index % cols
        const row = Math.floor(index / cols)
        const x = startX + col * (CARD_WIDTH + CARD_GAP)
        const y = startY + row * (CARD_HEIGHT + CARD_GAP)
        
        const isSelected = selectedIds.includes(card.id)
        const isHint = hintCardIds.includes(card.id)
        const isFoundSet = animationCardIds.includes(card.id)
        
        drawCard(ctx, card, x, y, CARD_WIDTH, CARD_HEIGHT, isSelected, isHint, isFoundSet)
      })
      
      if (setStore.animationState.active && setStore.animationState.scoreAnimation === 'score') {
        drawScoreAnimation(ctx, canvas.width, canvas.height, setStore.animationState.scoreValue)
      }
    }

    const getCardAtPosition = (x, y) => {
      if (!canvasRef.value) return null
      
      const canvas = canvasRef.value
      const cards = setStore.boardCards
      const cols = 6
      const startX = (canvas.width - (cols * CARD_WIDTH + (cols - 1) * CARD_GAP)) / 2
      const startY = (canvas.height - (Math.ceil(cards.length / cols) * CARD_HEIGHT + (Math.ceil(cards.length / cols) - 1) * CARD_GAP)) / 2
      
      for (let i = 0; i < cards.length; i++) {
        const col = i % cols
        const row = Math.floor(i / cols)
        const cardX = startX + col * (CARD_WIDTH + CARD_GAP)
        const cardY = startY + row * (CARD_HEIGHT + CARD_GAP)
        
        if (x >= cardX && x <= cardX + CARD_WIDTH && 
            y >= cardY && y <= cardY + CARD_HEIGHT) {
          return cards[i]
        }
      }
      return null
    }

    const handleCanvasClick = (event) => {
      if (setStore.gamePhase !== 'playing') return
      
      const rect = canvasRef.value.getBoundingClientRect()
      const scaleX = canvasRef.value.width / rect.width
      const scaleY = canvasRef.value.height / rect.height
      const x = (event.clientX - rect.left) * scaleX
      const y = (event.clientY - rect.top) * scaleY
      
      const card = getCardAtPosition(x, y)
      if (card) {
        setStore.selectCard(card)
      }
    }

    const handleResize = () => {
      if (!boardRef.value || !canvasRef.value) return

      const board = boardRef.value
      const canvas = canvasRef.value
      const dpr = window.devicePixelRatio || 1

      // 设置显示大小
      canvas.style.width = board.clientWidth + 'px'
      canvas.style.height = board.clientHeight + 'px'

      // 设置实际像素大小（考虑DPR）
      canvas.width = board.clientWidth * dpr
      canvas.height = board.clientHeight * dpr

      // 缩放上下文以匹配DPR
      ctx.scale(dpr, dpr)

      render()
    }

    watch(() => setStore.boardCards.length, render)
    watch(() => setStore.boardCards, render, { deep: true })
    watch(() => setStore.selectedCards, render, { deep: true })
    watch(() => setStore.showHint, render)
    watch(() => setStore.hintCards, render, { deep: true })
    watch(() => setStore.animationState, render)

    onMounted(() => {
      if (canvasRef.value) {
        ctx = canvasRef.value.getContext('2d')
        handleResize()
        window.addEventListener('resize', handleResize)
        render()
      }
    })

    onUnmounted(() => {
      window.removeEventListener('resize', handleResize)
    })

    const formatTime = (seconds) => {
      const mins = Math.floor(seconds / 60)
      const secs = seconds % 60
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
    }

    const handleGiveUp = () => {
      showGiveUpConfirm.value = true
    }

    const confirmGiveUp = () => {
      setStore.endGame()
      showGiveUpConfirm.value = false
    }

    const backToMenu = () => {
      setStore.endGame()
      emit('back-to-menu')
    }

    return {
      showRules,
      showGiveUpConfirm,
      setStore,
      canvasRef,
      boardRef,
      handleCanvasClick,
      formatTime,
      handleGiveUp,
      confirmGiveUp,
      backToMenu
    }
  }
}
</script>

<style scoped>
.game {
  min-height: 100vh;
  background: #1a1a1a;
  color: rgba(245, 240, 230, 0.95);
  font-family: 'JetBrains Mono', 'Consolas', monospace;
  display: flex;
  flex-direction: column;
  position: relative;
}

.game::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  opacity: 0.12;
  pointer-events: none;
  z-index: 1;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 32px;
  background: rgba(45, 42, 40, 0.92);
  border-bottom: 1px solid rgba(180, 170, 160, 0.15);
  position: relative;
  z-index: 10;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.25);
}

.header-left {
  display: flex;
  align-items: center;
  gap: 24px;
}

.logo {
  display: flex;
  align-items: center;
  gap: 8px;
}

.logo-icon {
  font-size: 1.5rem;
  color: #c4a77d;
}

.logo-text {
  font-size: 1.25rem;
  font-weight: 700;
  letter-spacing: 0.1em;
  color: rgba(245, 240, 230, 0.95);
}

.rules-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  background: rgba(196, 167, 125, 0.1);
  border: 1px solid rgba(196, 167, 125, 0.3);
  border-radius: 6px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.875rem;
  color: #c4a77d;
  transition: all 0.2s ease;
}

.rules-btn:hover {
  background: rgba(196, 167, 125, 0.18);
  border-color: rgba(196, 167, 125, 0.5);
  box-shadow: 0 2px 8px rgba(196, 167, 125, 0.15);
}

.rules-icon {
  font-weight: bold;
}

.header-center {
  display: flex;
  gap: 32px;
}

.stat-block {
  text-align: center;
}

.stat-label {
  font-size: 0.75rem;
  color: rgba(200, 190, 180, 0.7);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.stat-value {
  font-size: 1.5rem;
  font-weight: 700;
  color: #c4a77d;
}

.stat-divider {
  color: rgba(180, 170, 160, 0.4);
  margin: 0 4px;
}

.header-right {
  display: flex;
  align-items: center;
}

.timer {
  font-family: "Helvetica Neue", Arial, sans-serif;
  font-size: 1.5rem;
  font-weight: 700;
  color: #c4a77d;
  letter-spacing: 0.05em;
}

.game-container {
  flex: 1;
  display: flex;
  padding: 24px;
  gap: 24px;
  position: relative;
  z-index: 1;
}

@media (max-width: 768px) {
  .game-container {
    flex-direction: column;
    padding: 12px;
    gap: 12px;
  }

  .sidebar {
    width: 100%;
    flex-direction: row;
    flex-wrap: wrap;
  }
}

.sidebar {
  width: 240px;
  background: rgba(50, 47, 44, 0.85);
  border-radius: 8px;
  padding: 20px;
  border: 1px solid rgba(180, 170, 160, 0.15);
}

.sidebar-title {
  font-size: 0.875rem;
  font-weight: 700;
  color: rgba(220, 210, 200, 0.85);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.title-line {
  width: 16px;
  height: 2px;
  background: #c4a77d;
}

.info-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.info-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
  border-bottom: 1px solid rgba(0, 0, 0, 0.06);
}

.info-label {
  font-size: 0.875rem;
  color: rgba(180, 170, 160, 0.65);
}

.info-value {
  font-size: 0.875rem;
  font-weight: 600;
  color: rgba(220, 210, 200, 0.85);
}

.found-sets {
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 400px;
  overflow-y: auto;
}

.found-set-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  background: rgba(60, 57, 54, 0.5);
  border-radius: 6px;
  border: 1px solid rgba(180, 170, 160, 0.08);
}

.found-set-label {
  font-size: 0.75rem;
  font-weight: 600;
  color: rgba(180, 170, 160, 0.6);
  width: 20px;
}

.found-set-cards {
  display: flex;
  gap: 4px;
}

.mini-card {
  width: 24px;
  height: 32px;
  border-radius: 3px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid rgba(0, 0, 0, 0.1);
}

.mini-card-number {
  font-size: 0.75rem;
  font-weight: 700;
  color: white;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.no-sets {
  font-size: 0.875rem;
  color: rgba(180, 170, 160, 0.5);
  text-align: center;
  padding: 20px;
}

.sidebar-section {
  margin-bottom: 20px;
}

.sidebar-section h3 {
  font-size: 0.875rem;
  font-weight: 700;
  color: rgba(220, 210, 200, 0.85);
  margin: 0 0 12px 0;
}

.sidebar-section p {
  font-size: 0.85rem;
  color: rgba(180, 170, 160, 0.7);
  line-height: 1.5;
  margin: 0 0 12px 0;
}

.rules-list {
  margin: 0;
  padding-left: 20px;
  font-size: 0.85rem;
  color: rgba(180, 170, 160, 0.7);
}

.rules-list li {
  margin-bottom: 4px;
  line-height: 1.5;
}

.deck-info {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.deck-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  background: rgba(60, 57, 54, 0.5);
  border-radius: 6px;
  border: 1px solid rgba(180, 170, 160, 0.08);
}

.deck-label {
  font-size: 0.85rem;
  color: rgba(180, 170, 160, 0.65);
}

.deck-value {
  font-size: 0.85rem;
  font-weight: 600;
  color: rgba(220, 210, 200, 0.85);
}

.workbench {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 24px;
}

.board {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.board canvas {
  width: 100%;
  height: 100%;
  cursor: pointer;
}

.set-card {
  aspect-ratio: 1.5;
  background: #f4f1ea;
  border-radius: 8px;
  border: 2px solid rgba(0, 0, 0, 0.08);
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px;
  position: relative;
}

.set-card::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 6px;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3'itch'/%3 stitchTiles='stE%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  opacity: 0.08;
  pointer-events: none;
}

.set-card:hover {
  border-color: rgba(107, 91, 122, 0.4);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.set-card.is-selected {
  border-color: #8e44ad;
  background: rgba(107, 91, 122, 0.1);
  box-shadow: 0 0 0 3px rgba(107, 91, 122, 0.2);
}

.set-card.is-hint {
  animation: hint-pulse 1s ease-in-out infinite;
}

@keyframes hint-pulse {
  0%, 100% { box-shadow: 0 0 0 3px rgba(122, 140, 115, 0.3); }
  50% { box-shadow: 0 0 0 6px rgba(122, 140, 115, 0.5); }
}

.card-shapes {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 4px;
  width: 100%;
  height: 100%;
}

.shape {
  width: 60%;
  height: 30%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.shape-svg {
  width: 100%;
  height: 100%;
}

.shape.oval .shape-svg ellipse {
  fill: currentColor;
  stroke: none;
}

.shape.square .shape-svg rect {
  fill: currentColor;
  stroke: none;
}

.shape.diamond .shape-svg polygon {
  fill: currentColor;
  stroke: none;
}

.shape.solid {
  color: var(--card-color);
}

.shape.solid .shape-svg * {
  fill: currentColor;
  stroke: none;
}

.shape.striped {
  color: var(--card-color);
}

.shape.striped .shape-svg {
  background: repeating-linear-gradient(
    45deg,
    transparent,
    transparent 3px,
    rgba(255, 255, 255, 0.4) 3px,
    rgba(255, 255, 255, 0.4) 6px
  );
}

.shape.striped .shape-svg * {
  fill: currentColor;
  stroke: none;
}

.shape.open {
  color: var(--card-color);
  opacity: 0.9;
}

.shape.open .shape-svg * {
  fill: none;
  stroke: currentColor;
  stroke-width: 3;
}

.shape.oval { --card-color: #e74c3c; }
.shape.square { --card-color: #27ae60; }
.shape.diamond { --card-color: #8e44ad; }

.shape.red { --card-color: #e74c3c; }
.shape.green { --card-color: #27ae60; }
.shape.purple { --card-color: #8e44ad; }

.board-actions {
  display: flex;
  gap: 16px;
}

.btn {
  padding: 12px 24px;
  font-size: 0.875rem;
  font-family: inherit;
  letter-spacing: 1px;
  background: transparent;
  border: 1px solid rgba(180, 170, 160, 0.35);
  color: rgba(220, 210, 200, 0.85);
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn:hover:not(:disabled) {
  border-color: rgba(196, 167, 125, 0.6);
  color: rgba(245, 240, 230, 0.95);
}

.btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.btn-highlight {
  background: #c4a77d;
  border-color: #c4a77d;
  color: #2d2a28;
}

.btn-highlight:hover:not(:disabled) {
  background: #d4b78d;
  border-color: #d4b78d;
  box-shadow: 0 4px 12px rgba(196, 167, 125, 0.3);
}

.rules-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.rules-content {
  background: #2d2a28;
  border-radius: 12px;
  width: 90%;
  max-width: 600px;
  max-height: 80vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(180, 170, 160, 0.15);
}

.rules-content-small {
  max-width: 400px;
}

.rules-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 24px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.15);
  background: rgba(45, 42, 40, 0.95);
}

.rules-header h2 {
  margin: 0;
  font-size: 1.25rem;
  font-weight: 700;
  color: #c4a77d;
}

.rules-close {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  color: rgba(180, 170, 160, 0.6);
  padding: 0;
  line-height: 1;
}

.rules-close:hover {
  color: #c4a77d;
}

.rules-body {
  padding: 24px;
  overflow-y: auto;
  background: rgba(45, 42, 40, 0.95);
}

.rules-section {
  margin-bottom: 24px;
}

.rules-section:last-child {
  margin-bottom: 0;
}

.rules-section h3 {
  font-size: 1rem;
  font-weight: 700;
  color: rgba(220, 210, 200, 0.9);
  margin: 0 0 12px 0;
}

.rules-section p {
  font-size: 0.875rem;
  color: rgba(180, 170, 160, 0.75);
  margin: 0 0 12px 0;
  line-height: 1.7;
}

.rules-section ul {
  margin: 0;
  padding-left: 20px;
}

.rules-section li {
  font-size: 0.875rem;
  color: rgba(180, 170, 160, 0.75);
  margin-bottom: 6px;
  line-height: 1.6;
}

.rules-example {
  padding: 12px;
  background: rgba(196, 167, 125, 0.1);
  border-radius: 6px;
  font-size: 0.875rem;
  color: #c4a77d;
}

.settings-footer {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 16px 24px;
  border-top: 1px solid rgba(180, 170, 160, 0.15);
  background: rgba(45, 42, 40, 0.95);
}

.settings-footer .btn-confirm {
  padding: 10px 24px;
  background: #c4a77d;
  color: #2d2a28;
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.settings-footer .btn-confirm:hover {
  background: #d4b78d;
}
</style>

--- src/components/TripleCardBattleMobile.vue ---
<template>
  <div class="mobile-game" :class="{ 'is-landscape': isLandscape }">
    <header class="mobile-header">
      <div class="header-top">
        <div class="logo">
          <span class="logo-icon">◈</span>
          <span class="logo-text">三卡对决</span>
        </div>
        <div class="header-actions">
          <button class="rules-btn home-btn" @click="backToMenu">
            <span>⌂</span>
          </button>
          <button class="rules-btn" @click="showRules = true">
            <span>?</span>
          </button>
        </div>
      </div>
      <div class="header-stats">
        <div class="stat-item">
          <span class="stat-label">轮次</span>
          <span class="stat-value">{{ gameStore.currentRound }}/{{ gameStore.totalRounds }}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">回合</span>
          <span class="stat-value">{{ gameStore.subRound }}/2</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">状态</span>
          <span class="stat-value status-text">{{ statusText }}</span>
        </div>
      </div>
    </header>

    <div class="mobile-content">
      <div class="players-bar">
        <div v-for="(player, index) in gameStore.players" :key="player.id" class="player-chip"
          :class="{ 'is-me': !player.isAI }">
          <span class="chip-name">{{ getPlayerInitial(player, index) }}</span>
          <span class="chip-score">{{ getPlayerScore(player.id) }}</span>
        </div>
      </div>

      <div class="zones-container" v-if="gameStore.gamePhase !== 'roundResult'">
        <div class="zone-tabs">
          <button v-for="tab in zoneTabs" :key="tab.key" class="zone-tab"
            :class="{ 'is-active': activeZone === tab.key }" @click="activeZone = tab.key">
            <span class="tab-name">{{ tab.name }}</span>
            <span class="tab-count">{{ getZoneCount(tab.key) }}/{{ tab.required }}</span>
          </button>
        </div>

        <div class="zone-display">
          <div class="zone-area" :class="{ 'zone-ready': getGroupStatus(activeZone).ready }" @click="onZoneTap">
            <div class="zone-label">
              {{ activeZoneName }}
              <span class="zone-weight">{{ activeZoneWeight }}</span>
            </div>

            <div class="zone-cards-display">
              <div v-for="(card, cardIndex) in getActiveZoneCards" :key="cardIndex" class="zone-card"
                :class="card === -1 ? 'card-slot' : getCardColorClass(card)"
                @click.stop="card === -1 ? onZoneTap() : removeCardFromGroup('player', activeZone, cardIndex)">
                <template v-if="card !== -1">
                  <span class="card-text">{{ getSuitSymbol(card.suit) }} {{ card.rank }}</span>
                </template>
                <template v-else>
                  <span class="slot-text">点击出牌</span>
                </template>
              </div>
            </div>

            <div v-for="(player, index) in otherPlayers" :key="player.id" class="other-player-zone">
              <span class="other-label">{{ getPlayerInitial(player, index + 1) }}</span>
              <div class="other-cards">
                <div v-for="(card, cardIndex) in getDisplayCards(player.id, activeZone, getRequiredCount(activeZone))"
                  :key="cardIndex" class="other-card" :class="card === -1 ? 'card-back' : getCardColorClass(card)">
                  {{ card === -1 ? '' : card.displayName }}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="result-container" v-else>
        <div class="result-header">
          第 {{ gameStore.currentRound }} 轮结算{{ gameStore.subRound === 1 ? '(上回合)' : '(下回合)' }}
        </div>
        <div class="result-tabs">
          <button class="result-tab" :class="{ 'is-active': resultTab === 'score' }" @click="resultTab = 'score'">
            计分
          </button>
          <button class="result-tab" :class="{ 'is-active': resultTab === 'cards' }" @click="resultTab = 'cards'">
            出牌
          </button>
        </div>
        <div v-if="resultTab === 'score'" class="result-group-scores">
          <div class="group-score-header">
            <span class="group-col">分组得分</span>
            <span class="group-col">单张</span>
            <span class="group-col">24点</span>
            <span class="group-col">比三张</span>
            <span class="group-col">合计</span>
            <span class="group-col">累计</span>
          </div>
          <div v-for="player in gameStore.players" :key="player.id" class="group-score-row">
            <span class="group-col group-name">{{ player.isAI ? '电脑' + player.id.replace('cpu', '') : '玩家' }}</span>
            <span class="group-col group-score" :class="{ 'score-positive': getGroupScore(player.id, 'single') > 0 }">
              +{{ getGroupScore(player.id, 'single') }}
            </span>
            <span class="group-col group-score"
              :class="{ 'score-positive': getGroupScore(player.id, 'twentyFourPoint') > 0 }">
              +{{ getGroupScore(player.id, 'twentyFourPoint') }}
            </span>
            <span class="group-col group-score"
              :class="{ 'score-positive': getGroupScore(player.id, 'threeCard') > 0 }">
              +{{ getGroupScore(player.id, 'threeCard') }}
            </span>
            <span class="group-col group-total">+{{ gameStore.roundScores[player.id] || 0 }}</span>
            <span class="group-col group-accumulated">{{ gameStore.totalScores[player.id] || 0 }}</span>
          </div>
        </div>
        <div v-else-if="resultTab === 'cards'" class="result-cards-display">
          <div class="cards-section">
            <div class="cards-section-header">单张</div>
            <div class="cards-grid">
              <div v-for="player in gameStore.players" :key="player.id" class="player-cards">
                <div class="player-label">{{ player.isAI ? '电脑' + player.id.replace('cpu', '') : '玩家' }}</div>
                <div class="player-card">
                  <div class="cards-container">
                    <div v-for="(card, cardIndex) in getDisplayCards(player.id, 'single', 1)" :key="cardIndex"
                      class="zone-card-mini" :class="card === -1 ? 'card-back' : getCardColorClass(card)">
                      {{ card === -1 ? '' : card.displayName }}
                    </div>
                  </div>
                  <div class="player-result">
                    <span class="player-rank">第{{ getGroupRank(player.id, 'single') }}名</span>
                    <span class="player-score">+{{ getGroupScore(player.id, 'single') }}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="cards-section">
            <div class="cards-section-header">24点</div>
            <div class="cards-grid">
              <div v-for="player in gameStore.players" :key="player.id" class="player-cards">
                <div class="player-label">{{ player.isAI ? '电脑' + player.id.replace('cpu', '') : '玩家' }}</div>
                <div class="player-card">
                  <div class="cards-container">
                    <div v-for="(card, cardIndex) in getDisplayCards(player.id, 'twentyFourPoint', 2)" :key="cardIndex"
                      class="zone-card-mini" :class="card === -1 ? 'card-back' : getCardColorClass(card)">
                      {{ card === -1 ? '' : card.displayName }}
                    </div>
                  </div>
                  <div class="player-result">
                    <span class="player-rank">第{{ getGroupRank(player.id, 'twentyFourPoint') }}名</span>
                    <span class="player-score">+{{ getGroupScore(player.id, 'twentyFourPoint') }}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="cards-section">
            <div class="cards-section-header">比三张</div>
            <div class="cards-grid">
              <div v-for="player in gameStore.players" :key="player.id" class="player-cards">
                <div class="player-label">{{ player.isAI ? '电脑' + player.id.replace('cpu', '') : '玩家' }}</div>
                <div class="player-card">
                  <div class="cards-container">
                    <div v-for="(card, cardIndex) in getDisplayCards(player.id, 'threeCard', 3)" :key="cardIndex"
                      class="zone-card-mini" :class="card === -1 ? 'card-back' : getCardColorClass(card)">
                      {{ card === -1 ? '' : card.displayName }}
                    </div>
                  </div>
                  <div class="player-result">
                    <span class="player-rank">第{{ getGroupRank(player.id, 'threeCard') }}名</span>
                    <span class="player-score">+{{ getGroupScore(player.id, 'threeCard') }}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <button class="btn-next" @click="handleNext">
          {{ gameStore.subRound === 1 ? '下回合' : (gameStore.isGameOver() ? '查看结果' : '下一轮') }}
        </button>
      </div>
    </div>

    <div class="mobile-hand" v-if="gameStore.gamePhase === 'grouping'">
      <div class="hand-header">
        <span class="hand-title">手牌 ({{ remainingHandCards }})</span>
        <div class="hand-actions-top">
          <button class="btn-confirm-small" :disabled="!canConfirm" @click="confirmGroup">
            确认出牌
          </button>
          <button class="btn-small" @click="toggleSort">{{ sortModeText }}</button>
          <button class="btn-small" @click="resetHand">清空</button>
        </div>
      </div>

      <div class="hand-grid">
        <div v-for="(card, index) in playerHand" :key="index" class="hand-card"
          :class="[getCardColorClass(card), { 'is-selected': selectedCardIndex === index }]"
          @click="handleCardTap(card, index)">
          <span class="card-rank">{{ card.rank }}</span>
          <span class="card-suit">{{ getSuitSymbol(card.suit) }}</span>
        </div>
      </div>
    </div>

    <div class="rules-modal" v-if="showRules" @click.self="showRules = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>游戏规则</h2>
          <button class="rules-close" @click="showRules = false">×</button>
        </div>
        <div class="rules-body">
          <div class="rules-section">
            <h3>游戏目标</h3>
            <p>在可配置的轮次结束后，累计积分最高的玩家获胜。</p>
          </div>
          <div class="rules-section">
            <h3>分组规则</h3>
            <p>每回合将6张牌分成三组：</p>
            <ul>
              <li>单张组：1张牌</li>
              <li>24点组：2张牌</li>
              <li>比三张组：3张牌（得分翻倍）</li>
            </ul>
          </div>
          <div class="rules-section">
            <h3>操作说明</h3>
            <p>1. 点击手牌选中卡牌</p>
            <p>2. 点击对应区域放置卡牌</p>
            <p>3. 点击已放置的卡牌可收回</p>
          </div>
        </div>
      </div>
    </div>

    <div class="rules-modal" v-if="showSettings" @click.self="showSettings = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>游戏设置</h2>
        </div>
        <div class="rules-body">
          <div class="settings-group">
            <div class="settings-label">
              <span class="label-dot"></span>
              电脑玩家数量
            </div>
            <div class="slider-wrapper">
              <input 
                type="range" 
                v-model="settingsCpuCount" 
                min="1" 
                max="3" 
                class="slider"
              />
              <div class="slider-marks">
                <span>1</span><span>2</span><span>3</span>
              </div>
            </div>
            <div class="settings-value">{{ settingsCpuCount }} 人</div>
          </div>
          
          <div class="settings-group">
            <div class="settings-label">
              <span class="label-dot"></span>
              游戏轮数
            </div>
            <div class="slider-wrapper">
              <input 
                type="range" 
                v-model="settingsRoundCount" 
                min="3" 
                max="7" 
                class="slider"
              />
              <div class="slider-marks">
                <span>3</span><span>5</span><span>7</span>
              </div>
            </div>
            <div class="settings-value">{{ settingsRoundCount }} 轮</div>
          </div>
        </div>
        <div class="settings-footer">
          <button class="btn-confirm" @click="confirmSettings">开始游戏</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import gameStore from '../store/gameStore.js'

export default {
  name: 'TripleCardBattleMobile',
  emits: ['back-to-menu'],
  setup (props, { emit }) {
    const selectedCardIndex = ref(null)
    const sortMode = ref('rank')
    const showRules = ref(false)
    const showSettings = ref(true)
    const settingsCpuCount = ref(1)
    const settingsRoundCount = ref(5)
    const activeZone = ref('single')
    const isLandscape = ref(false)
    const resultTab = ref('score')

    const confirmSettings = () => {
      gameStore.playerCount = Number(settingsCpuCount.value) + 1
      gameStore.totalRounds = Number(settingsRoundCount.value)
      gameStore.initGame(Number(settingsCpuCount.value) + 1, Number(settingsRoundCount.value))
      gameStore.startNewRound()
      showSettings.value = false
    }

    const zoneTabs = [
      { key: 'single', name: '单张', required: 1 },
      { key: 'twentyFourPoint', name: '24点', required: 2 },
      { key: 'threeCard', name: '比三张', required: 3 }
    ]

    const checkOrientation = () => {
      isLandscape.value = window.innerWidth > window.innerHeight
    }

    onMounted(() => {
      checkOrientation()
      window.addEventListener('resize', checkOrientation)
      window.addEventListener('orientationchange', checkOrientation)
    })

    onUnmounted(() => {
      window.removeEventListener('resize', checkOrientation)
      window.removeEventListener('orientationchange', checkOrientation)
    })

    const playerHand = computed(() => {
      const player = gameStore.players.find(p => p.id === 'player')
      return player ? player.hand : []
    })

    const remainingHandCards = computed(() => playerHand.value.length)

    const sortModeText = computed(() => {
      return sortMode.value === 'rank' ? '点数排序' : '花色排序'
    })

    const statusText = computed(() => {
      if (gameStore.gamePhase === 'grouping') {
        return gameStore.subRound === 1 ? '分组中(上)' : '分组中(下)'
      } else if (gameStore.gamePhase === 'comparing') {
        return '比较中'
      } else if (gameStore.gamePhase === 'roundResult') {
        return '结算'
      }
      return '就绪'
    })

    const activeZoneName = computed(() => {
      const tab = zoneTabs.find(t => t.key === activeZone.value)
      return tab ? tab.name : ''
    })

    const activeZoneWeight = computed(() => {
      if (activeZone.value === 'threeCard') return '2×'
      return '1×'
    })

    const otherPlayers = computed(() => {
      return gameStore.players.filter(p => p.isAI)
    })

    const canConfirm = computed(() => {
      if (gameStore.gamePhase !== 'grouping') return false

      const playerGroups = gameStore.playerGroups['player']
      if (!playerGroups) return false

      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      const singleCount = (playerGroups.single[subRoundIndex] || []).filter(c => c !== -1).length
      const twentyFourPointCount = (playerGroups.twentyFourPoint[subRoundIndex] || []).filter(c => c !== -1).length
      const threeCardCount = (playerGroups.threeCard[subRoundIndex] || []).filter(c => c !== -1).length

      return singleCount >= 1 && twentyFourPointCount >= 2 && threeCardCount >= 3
    })

    const getActiveZoneCards = computed(() => {
      const playerGroups = gameStore.playerGroups['player']
      if (!playerGroups) {
        const required = getRequiredCount(activeZone.value)
        return Array(required).fill(-1)
      }

      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      const cards = playerGroups[activeZone.value][subRoundIndex] || []
      const required = getRequiredCount(activeZone.value)

      while (cards.length < required) {
        cards.push(-1)
      }

      return cards
    })

    const getRequiredCount = (groupType) => {
      if (groupType === 'single') return 1
      if (groupType === 'twentyFourPoint') return 2
      if (groupType === 'threeCard') return 3
      return 0
    }

    const getZoneCount = (groupType) => {
      const playerGroups = gameStore.playerGroups['player']
      if (!playerGroups) return 0

      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      return (playerGroups[groupType][subRoundIndex] || []).filter(c => c !== -1).length
    }

    const getGroupStatus = (groupType) => {
      const count = getZoneCount(groupType)
      const required = getRequiredCount(groupType)
      return { ready: count >= required, count, required }
    }

    const getPlayerScore = (playerId) => {
      return gameStore.totalScores[playerId] || 0
    }

    const getGroupScore = (playerId, groupType) => {
      if (gameStore.gamePhase === 'roundResult') {
        return gameStore.currentRoundGroupScores[playerId]?.[groupType] || 0
      }
      return 0
    }

    const getGroupRank = (playerId, groupType) => {
      if (gameStore.gamePhase === 'roundResult') {
        // 根据得分计算排名
        const scores = gameStore.players.map(p => ({
          playerId: p.id,
          score: gameStore.currentRoundGroupScores[p.id]?.[groupType] || 0
        }))

        // 按得分降序排序
        scores.sort((a, b) => b.score - a.score)

        // 找到当前玩家的排名
        const rank = scores.findIndex(s => s.playerId === playerId) + 1
        return rank
      }
      return 0
    }

    const getPlayerInitial = (player, index) => {
      if (!player.isAI) return 'P1'
      return 'P' + (index + 1)
    }

    const getSuitSymbol = (suit) => {
      const symbols = {
        'spades': '♠',
        'hearts': '♥',
        'clubs': '♣',
        'diamonds': '♦'
      }
      return symbols[suit] || ''
    }

    const getCardColorClass = (card) => {
      if (!card) return 'card-black'
      return card.color === 'red' ? 'card-red' : 'card-black'
    }

    const getDisplayCards = (playerId, groupType, requiredCount) => {
      const groups = gameStore.playerGroups[playerId]
      if (!groups) return Array(requiredCount).fill(-1)

      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      let cards = groups[groupType][subRoundIndex] || []

      // 排序：先点数后花色
      const rankOrder = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2']
      const suitOrder = ['spades', 'hearts', 'clubs', 'diamonds']

      cards = cards.filter(card => card !== -1).sort((a, b) => {
        // 先按点数排序
        const rankDiff = rankOrder.indexOf(a.rank) - rankOrder.indexOf(b.rank)
        if (rankDiff !== 0) return rankDiff
        // 点数相同按花色排序
        return suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit)
      })

      while (cards.length < requiredCount) {
        cards.push(-1)
      }

      return cards
    }

    const handleCardTap = (card, index) => {
      if (selectedCardIndex.value === index) {
        selectedCardIndex.value = null
      } else {
        selectedCardIndex.value = index
      }
    }

    const onZoneTap = () => {
      if (selectedCardIndex.value === null) return

      const index = selectedCardIndex.value
      const card = playerHand.value[index]
      if (!card) return

      const player = gameStore.players.find(p => p.id === 'player')
      if (!player || !player.hand) return

      let playerGroups = gameStore.playerGroups['player']
      if (!playerGroups) {
        gameStore.initPlayerGroups(gameStore.playerCount)
        playerGroups = gameStore.playerGroups['player']
      }

      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      const targetArray = playerGroups[activeZone.value][subRoundIndex]
      const maxLength = getRequiredCount(activeZone.value)

      const validCards = targetArray.filter(c => c !== -1)
      const existingCards = [
        ...playerGroups.single[0], ...playerGroups.single[1],
        ...playerGroups.twentyFourPoint[0], ...playerGroups.twentyFourPoint[1],
        ...playerGroups.threeCard[0], ...playerGroups.threeCard[1]
      ].filter(c => c !== -1)
      const isInGroup = existingCards.some(c => c.rank === card.rank && c.suit === card.suit)

      if (!isInGroup && validCards.length < maxLength) {
        const emptyIndex = targetArray.findIndex(c => c === -1)
        if (emptyIndex !== -1) {
          targetArray[emptyIndex] = card
        } else {
          targetArray.push(card)
        }
        player.hand.splice(index, 1)
        gameStore.playerGroups['player'] = playerGroups
        selectedCardIndex.value = null
      }
    }

    const removeCardFromGroup = (playerId, groupType, cardIndex) => {
      if (playerId !== 'player' || gameStore.gamePhase !== 'grouping') return

      const player = gameStore.players.find(p => p.id === playerId)
      if (!player || !player.hand) return

      const playerGroups = gameStore.playerGroups[playerId]
      if (!playerGroups || !playerGroups[groupType]) return

      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      const groupArray = playerGroups[groupType][subRoundIndex]
      if (cardIndex < 0 || cardIndex >= groupArray.length) return

      const card = groupArray[cardIndex]
      if (!card || card === -1) return

      groupArray[cardIndex] = -1
      player.hand.push(card)
      gameStore.playerGroups[playerId] = playerGroups
    }

    const resetHand = () => {
      gameStore.resetCurrentGroups()
      selectedCardIndex.value = null
    }

    const toggleSort = () => {
      const player = gameStore.players.find(p => p.id === 'player')
      if (!player || !player.hand) return

      const suitOrder = ['spades', 'hearts', 'clubs', 'diamonds']
      const rankOrder = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2']

      if (sortMode.value === 'rank') {
        player.hand.sort((a, b) => {
          const rankDiff = rankOrder.indexOf(a.rank) - rankOrder.indexOf(b.rank)
          if (rankDiff !== 0) return rankDiff
          return suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit)
        })
        sortMode.value = 'suit'
      } else {
        player.hand.sort((a, b) => {
          const suitDiff = suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit)
          if (suitDiff !== 0) return suitDiff
          return rankOrder.indexOf(a.rank) - rankOrder.indexOf(b.rank)
        })
        sortMode.value = 'rank'
      }
    }

    const confirmGroup = () => {
      if (!canConfirm.value) return

      const playerGroups = gameStore.playerGroups['player']
      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1

      const groups = {
        single: playerGroups && playerGroups.single && playerGroups.single[subRoundIndex] ? playerGroups.single[subRoundIndex].filter(c => c !== -1) : [],
        twentyFourPoint: playerGroups && playerGroups.twentyFourPoint && playerGroups.twentyFourPoint[subRoundIndex] ? playerGroups.twentyFourPoint[subRoundIndex].filter(c => c !== -1) : [],
        threeCard: playerGroups && playerGroups.threeCard && playerGroups.threeCard[subRoundIndex] ? playerGroups.threeCard[subRoundIndex].filter(c => c !== -1) : []
      }

      gameStore.submitPlayerGroups(groups)
      gameStore.calculateRoundScores()
    }

    const handleNext = () => {
      if (gameStore.subRound === 1) {
        gameStore.prepareSecondRound()
      } else {
        if (gameStore.isGameOver()) {
          gameStore.endGame()
        } else {
          gameStore.startNewRound()
        }
      }
    }

    return {
      gameStore,
      playerHand,
      remainingHandCards,
      sortModeText,
      statusText,
      canConfirm,
      selectedCardIndex,
      showRules,
      showSettings,
      settingsCpuCount,
      settingsRoundCount,
      activeZone,
      isLandscape,
      zoneTabs,
      activeZoneName,
      activeZoneWeight,
      otherPlayers,
      getActiveZoneCards,
      getRequiredCount,
      getZoneCount,
      getGroupStatus,
      getPlayerScore,
      getGroupScore,
      getGroupRank,
      getPlayerInitial,
      resultTab,
      getSuitSymbol,
      getCardColorClass,
      getDisplayCards,
      handleCardTap,
      onZoneTap,
      removeCardFromGroup,
      resetHand,
      toggleSort,
      confirmGroup,
      handleNext,
      confirmSettings,
      backToMenu: () => emit('back-to-menu')
    }
  }
}
</script>

<style scoped>
.mobile-game {
  min-height: 100vh;
  min-height: 100dvh;
  background: #1a1a1a;
  display: flex;
  flex-direction: column;
  font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
  overflow: hidden;
  position: relative;
}

/* 噪点纹理覆盖层 */
.mobile-game::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  opacity: 0.12;
  pointer-events: none;
  z-index: 1;
}

.mobile-header {
  background: rgba(45, 42, 40, 0.95);
  padding: 8px 16px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.12);
  position: sticky;
  top: 0;
  z-index: 10;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
}

.header-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.logo {
  display: flex;
  align-items: center;
  gap: 8px;
}

.logo-icon {
  font-size: 20px;
  color: #c4a77d;
}

.logo-text {
  font-size: 16px;
  font-weight: 600;
  color: rgba(245, 240, 230, 0.95);
  letter-spacing: 1px;
}

.rules-btn {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(196, 167, 125, 0.15);
  border: 1px solid rgba(196, 167, 125, 0.3);
  border-radius: 50%;
  color: #c4a77d;
  font-size: 16px;
  font-weight: 600;
}

.header-stats {
  display: flex;
  justify-content: space-around;
  background: rgba(60, 57, 54, 0.5);
  border-radius: 8px;
  padding: 8px;
}

.stat-item {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 8px;
}

.stat-label {
  font-size: 11px;
  color: rgba(180, 170, 160, 0.6);
}

.stat-value {
  font-size: 16px;
  font-weight: 600;
  color: #c4a77d;
}

.status-text {
  font-size: 13px;
}

.mobile-content {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
  padding-bottom: 8px;
}

.players-bar {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
  overflow-x: auto;
  padding: 4px 0;
}

.player-chip {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: rgba(50, 47, 44, 0.85);
  border: 1px solid rgba(180, 170, 160, 0.12);
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.player-chip.is-me {
  border-color: rgba(196, 167, 125, 0.4);
  background: rgba(196, 167, 125, 0.1);
}

.chip-name {
  font-size: 12px;
  color: rgba(200, 190, 180, 0.75);
}

.chip-score {
  font-size: 16px;
  font-weight: 600;
  color: #c4a77d;
}

.zones-container {
  flex: 1;
}

.zone-tabs {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}

.zone-tab {
  flex: 1;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 8px;
  background: rgba(50, 47, 44, 0.85);
  border: 1px solid rgba(180, 170, 160, 0.12);
  border-radius: 8px;
  color: rgba(180, 170, 160, 0.7);
}

.zone-tab.is-active {
  border-color: #c4a77d;
  background: rgba(196, 167, 125, 0.15);
  color: #f5f0e6;
}

.tab-name {
  font-size: 14px;
  font-weight: 500;
}

.tab-count {
  font-size: 12px;
  color: #c4a77d;
}

.zone-display {
  background: rgba(50, 47, 44, 0.6);
  border-radius: 12px;
  padding: 8px;
}

.zone-area {
  background: rgba(60, 57, 54, 0.8);
  border: 2px dashed rgba(180, 170, 160, 0.18);
  border-radius: 12px;
  padding: 8px;
  min-height: 80px;
}

.zone-area.zone-ready {
  border-color: #8b9a6d;
  border-style: solid;
}

.zone-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 14px;
  color: #c4a77d;
  font-weight: 500;
}

.zone-weight {
  font-size: 12px;
  padding: 2px 8px;
  background: rgba(196, 167, 125, 0.2);
  border-radius: 4px;
}

.zone-cards-display {
  display: flex;
  gap: 6px;
  justify-content: center;
  align-items: center;
  margin-bottom: 8px;
}

.zone-card {
  padding: 6px 10px;
  background: #f0ece5;
  border-radius: 6px;
  font-weight: bold;
  font-size: 16px;
  min-width: 40px;
  text-align: center;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
}

.zone-card.card-slot {
  background: rgba(60, 57, 54, 0.4);
  border: 2px dashed rgba(180, 170, 160, 0.25);
  min-width: 50px;
  min-height: 32px;
}

.slot-text {
  font-size: 10px;
  color: rgba(180, 170, 160, 0.5);
  text-align: center;
}

.zone-card.card-red {
  color: #b56565;
}

.zone-card.card-black {
  color: #4a4a4a;
}

.card-text {
  font-size: 16px;
  font-weight: bold;
}

.other-player-zone {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  background: rgba(100, 95, 90, 0.3);
  border-radius: 6px;
  margin-top: 8px;
}

.other-label {
  font-size: 12px;
  color: #c4a77d;
  min-width: 24px;
}

.other-cards {
  display: flex;
  gap: 6px;
  align-items: center;
}

.other-card {
  padding: 6px 10px;
  background: #e8e4df;
  border-radius: 6px;
  font-size: 16px;
  font-weight: bold;
  min-width: 40px;
  text-align: center;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
}

.other-card.card-red {
  color: #b56565;
}

.other-card.card-black {
  color: #4a4a4a;
}

.other-card.card-back {
  background: linear-gradient(135deg, #4a4540 25%, #6a6560 25%, #6a6560 50%, #4a4540 50%, #4a4540 75%, #6a6560 75%);
  background-size: 6px 6px;
  color: transparent;
  min-height: 28px;
}

.result-container {
  background: rgba(50, 47, 44, 0.85);
  border-radius: 12px;
  padding: 12px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}

.result-header {
  font-size: 16px;
  color: #c4a77d;
  text-align: center;
  margin-bottom: 12px;
  font-weight: 600;
}

.result-tabs {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}

.result-tab {
  flex: 1;
  padding: 8px;
  background: rgba(60, 57, 54, 0.5);
  border: 1px solid rgba(180, 170, 160, 0.12);
  border-radius: 8px;
  color: rgba(180, 170, 160, 0.7);
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s;
}

.result-tab.is-active {
  background: rgba(196, 167, 125, 0.18);
  border-color: #c4a77d;
  color: #c4a77d;
}

.result-cards-display {
  background: rgba(60, 57, 54, 0.4);
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 12px;
}

.cards-section {
  margin-bottom: 16px;
}

.cards-section:last-child {
  margin-bottom: 0;
}

.cards-section-header {
  font-size: 14px;
  color: #c4a77d;
  font-weight: 500;
  margin-bottom: 8px;
  text-align: center;
  padding-bottom: 4px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.12);
}

.cards-grid {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.player-cards {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  background: rgba(60, 57, 54, 0.35);
  border-radius: 6px;
}

.player-label {
  font-size: 13px;
  color: rgba(220, 210, 200, 0.85);
  min-width: 60px;
}

.player-card {
  display: flex;
  gap: 12px;
  align-items: center;
  flex: 1;
  justify-content: space-between;
}

.cards-container {
  display: flex;
  gap: 8px;
  align-items: center;
}

.player-result {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 2px;
  min-width: 80px;
}

.player-rank {
  font-size: 11px;
  color: rgba(180, 170, 160, 0.65);
}

.player-score {
  font-size: 14px;
  font-weight: 600;
  color: #8b9a6d;
}

.zone-card-mini {
  padding: 4px 8px;
  background: #e8e4df;
  border-radius: 4px;
  font-size: 12px;
  font-weight: bold;
  width: 44px;
  text-align: center;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.zone-card-mini.card-red {
  color: #b56565;
}

.zone-card-mini.card-black {
  color: #4a4a4a;
}

.zone-card-mini.card-back {
  background: linear-gradient(135deg, #4a4540 25%, #6a6560 25%, #6a6560 50%, #4a4540 50%, #4a4540 75%, #6a6560 75%);
  background-size: 4px 4px;
  color: transparent;
  min-height: 24px;
}

.result-group-scores {
  background: rgba(60, 57, 54, 0.4);
  border-radius: 8px;
  padding: 8px;
  margin-bottom: 12px;
}

.group-score-header {
  display: flex;
  justify-content: space-between;
  padding: 6px 4px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.12);
  margin-bottom: 6px;
}

.group-col {
  flex: 1;
  text-align: center;
  font-size: 11px;
  color: rgba(180, 170, 160, 0.6);
}

.group-col:first-child {
  flex: 1.2;
  text-align: left;
}

.group-score-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 4px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.06);
}

.group-score-row:last-child {
  border-bottom: none;
}

.group-name {
  font-size: 13px;
  color: rgba(220, 210, 200, 0.85);
  font-weight: 500;
}

.group-score {
  font-size: 14px;
  color: rgba(180, 170, 160, 0.5);
}

.group-score.score-positive {
  color: #8b9a6d;
  font-weight: 600;
}

.group-total {
  font-size: 15px;
  font-weight: 600;
  color: #c4a77d;
}

.group-accumulated {
  font-size: 15px;
  font-weight: 600;
  color: #b88a6f;
}



.btn-next {
  width: 100%;
  padding: 8px;
  margin-top: 8px;
  background: #c4a77d;
  border: none;
  border-radius: 8px;
  color: #2d2a28;
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 1px;
}

.mobile-hand {
  background: rgba(45, 42, 40, 0.95);
  border-top: 1px solid rgba(180, 170, 160, 0.12);
  padding: 8px;
  padding-bottom: calc(8px + env(safe-area-inset-bottom, 0));
  box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.25);
}

.hand-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.hand-title {
  font-size: 14px;
  color: #c4a77d;
  font-weight: 500;
}

.hand-actions-top {
  display: flex;
  gap: 8px;
}

.btn-small {
  padding: 6px 12px;
  background: rgba(196, 167, 125, 0.15);
  border: 1px solid rgba(196, 167, 125, 0.3);
  border-radius: 6px;
  color: #c4a77d;
  font-size: 12px;
}

.btn-confirm-small {
  padding: 6px 12px;
  background: #c4a77d;
  border: 1px solid #c4a77d;
  border-radius: 6px;
  color: #2d2a28;
  font-size: 12px;
  font-weight: 500;
}

.btn-confirm-small:disabled {
  background: rgba(196, 167, 125, 0.3);
  border-color: rgba(196, 167, 125, 0.3);
  color: rgba(200, 190, 180, 0.5);
}

.hand-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  grid-template-rows: repeat(2, 1fr);
  gap: 6px;
  padding: 4px 0;
}

.hand-card {
  aspect-ratio: 5 / 3.5;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 2px;
  background: #f0ece5;
  border-radius: 6px;
  border: 2px solid transparent;
  font-weight: bold;
  transition: transform 0.15s, border-color 0.15s;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
}

.hand-card.is-selected {
  border-color: #c4a77d;
  transform: translateY(-4px);
  box-shadow: 0 6px 16px rgba(196, 167, 125, 0.25);
}

.hand-card.card-red {
  color: #b56565;
}

.hand-card.card-black {
  color: #4a4a4a;
}

.card-rank {
  font-size: 14px;
  font-weight: bold;
}

.card-suit {
  font-size: 14px;
}

.rules-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(30, 28, 26, 0.92);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 8px;
}

.rules-content {
  background: #2d2a28;
  border: 1px solid rgba(180, 170, 160, 0.15);
  border-radius: 12px;
  width: 100%;
  max-width: 400px;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
}

.rules-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.12);
}

.rules-header h2 {
  margin: 0;
  font-size: 18px;
  color: rgba(245, 240, 230, 0.95);
}

.rules-close {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(180, 170, 160, 0.08);
  border: 1px solid rgba(180, 170, 160, 0.15);
  border-radius: 6px;
  color: rgba(200, 190, 180, 0.7);
  font-size: 24px;
}

.rules-body {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.rules-section {
  margin-bottom: 8px;
}

.rules-section h3 {
  margin: 0 0 8px 0;
  font-size: 14px;
  color: #c4a77d;
}

.rules-section p {
  margin: 0 0 8px 0;
  font-size: 13px;
  color: rgba(200, 190, 180, 0.8);
  line-height: 1.6;
}

.rules-section ul {
  margin: 0;
  padding-left: 20px;
  font-size: 13px;
  color: rgba(200, 190, 180, 0.8);
  line-height: 1.8;
}

.settings-group {
  margin-bottom: 20px;
}

.settings-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: rgba(180, 170, 160, 0.65);
  margin-bottom: 12px;
  letter-spacing: 1px;
}

.settings-label .label-dot {
  width: 6px;
  height: 6px;
  background: #c4a77d;
  border-radius: 50%;
}

.slider-wrapper {
  padding: 0 2px;
}

.settings-group .slider {
  width: 100%;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(180, 170, 160, 0.15);
  border-radius: 2px;
  outline: none;
  cursor: pointer;
}

.settings-group .slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: #c4a77d;
  border-radius: 2px;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(196, 167, 125, 0.35);
}

.slider-marks {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
  font-size: 10px;
  color: rgba(180, 170, 160, 0.4);
}

.settings-value {
  text-align: center;
  font-size: 20px;
  font-weight: 300;
  color: #c4a77d;
  margin-top: 10px;
  letter-spacing: 2px;
}

.settings-footer {
  padding: 12px 16px;
  border-top: 1px solid rgba(180, 170, 160, 0.12);
  display: flex;
  justify-content: center;
}

.btn-confirm {
  padding: 10px 32px;
  font-size: 14px;
  font-family: inherit;
  letter-spacing: 1px;
  background: #c4a77d;
  border: none;
  border-radius: 6px;
  color: #2d2a28;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-confirm:hover {
  background: #d4b78d;
  box-shadow: 0 0 15px rgba(196, 167, 125, 0.35);
}

.mobile-game.is-landscape .mobile-hand {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
}

.mobile-game.is-landscape .mobile-content {
  padding-bottom: 120px;
}
</style>

--- src/components/TripleCardBattlePC.vue ---
<template>
  <div class="game">

    <header class="header">
      <div class="header-left">
        <div class="logo">
          <span class="logo-icon">◈</span>
          <span class="logo-text">三卡对决</span>
        </div>
        <button class="rules-btn" @click="showRules = true">
          <span class="rules-icon">?</span>
          <span class="rules-text">规则说明</span>
        </button>
        <button class="rules-btn" @click="showSettings = true">
          <span class="rules-icon">⚙</span>
          <span class="rules-text">游戏设置</span>
        </button>
      </div>
      
      <div class="header-center">
        <div class="stat-block">
          <div class="stat-label">当前轮次</div>
          <div class="stat-value">{{ gameStore.currentRound }}<span class="stat-divider">/</span>{{ gameStore.totalRounds }} <span class="sub-round">({{ gameStore.subRound }}/2)</span></div>
        </div>
      </div>
      
      <div class="header-right">
        <button class="home-btn" @click="backToMenu">
          <span class="home-icon">⌂</span>
          <span class="home-text">首页</span>
        </button>
        <div class="status-indicator">
          <span class="status-dot"></span>
          {{ statusText }}
        </div>
      </div>
    </header>

    <div class="main-container">
      <aside class="sidebar">
        <div class="sidebar-title">
          <span class="title-line"></span>
          玩家
        </div>
        
        <div class="player-list">
          <div 
            v-for="(player, index) in gameStore.players" 
            :key="player.id"
            class="player-card"
            :class="{ 'is-me': !player.isAI }"
          >
            <div class="player-info">
              <div class="player-avatar">{{ getPlayerInitial(player, index) }}</div>
              <div class="player-detail">
                <div class="player-name">{{ player.name }}</div>
                <div class="player-status">{{ !player.isAI ? '我' : 'CPU' }}</div>
              </div>
            </div>
            <div class="player-score">{{ getPlayerScore(player.id) }}</div>
          </div>
        </div>
      </aside>

      <main class="workbench">
        <div class="zone" data-label="A区 · 单张" :class="{ 'zone-ready': getGroupStatus('single').ready }">
          <div class="zone-header">
            <span>单张比大小</span>
            <span class="zone-weight">1×</span>
          </div>
          <div 
            class="zone-content"
            :class="{ 'zone-clickable': selectedCardIndex !== null }"
            @dragover.prevent
            @drop="onDrop($event, 'single')"
            @click="onZoneClick('single')"
          >
            <div 
              v-for="(player, index) in gameStore.players" 
              :key="player.id"
              class="zone-row"
              :class="{ 'is-player': !player.isAI, 'is-complete': getGroupStatus('single').ready }"
            >
              <div class="zone-row-label">{{ getPlayerInitial(player, index) }}</div>
              <div class="zone-cards">
                <div 
                  v-for="(card, cardIndex) in getDisplayCards(player.id, 'single', 1)" 
                  :key="cardIndex"
                  class="zone-card-mini"
                  :class="card === -1 ? 'card-back' : getCardColorClass(card)"
                  @click="card !== -1 && removeCardFromGroup(player.id, 'single', cardIndex)"
                >
                  {{ card === -1 ? '' : card.displayName }}
                </div>
              </div>
              <div v-if="gameStore.gamePhase === 'roundResult' && getGroupScore(player.id, 'single') > 0" class="zone-row-score">
                +{{ getGroupScore(player.id, 'single') }}
              </div>
            </div>
          </div>
          <div class="zone-info">
            <span>拖入卡牌 ({{ getGroupStatus('single').count }}/{{ getGroupStatus('single').required }})</span>
          </div>
        </div>

        <div class="zone" data-label="B区 · 24点" :class="{ 'zone-ready': getGroupStatus('twentyFourPoint').ready }">
          <div class="zone-header">
            <span>24点和</span>
            <span class="zone-weight">1×</span>
          </div>
          <div 
            class="zone-content"
            :class="{ 'zone-clickable': selectedCardIndex !== null }"
            @dragover.prevent
            @drop="onDrop($event, 'twentyFourPoint')"
            @click="onZoneClick('twentyFourPoint')"
          >
            <div 
              v-for="(player, index) in gameStore.players" 
              :key="player.id"
              class="zone-row"
              :class="{ 'is-player': !player.isAI, 'is-complete': getGroupStatus('twentyFourPoint').ready }"
            >
              <div class="zone-row-label">{{ getPlayerInitial(player, index) }}</div>
              <div class="zone-cards">
                <div 
                  v-for="(card, cardIndex) in getDisplayCards(player.id, 'twentyFourPoint', 2)" 
                  :key="cardIndex"
                  class="zone-card-mini"
                  :class="card === -1 ? 'card-back' : getCardColorClass(card)"
                  @click="card !== -1 && removeCardFromGroup(player.id, 'twentyFourPoint', cardIndex)"
                >
                  {{ card === -1 ? '' : card.displayName }}
                </div>
              </div>
              <div v-if="gameStore.gamePhase === 'roundResult' && getGroupScore(player.id, 'twentyFourPoint') > 0" class="zone-row-score">
                +{{ getGroupScore(player.id, 'twentyFourPoint') }}
              </div>
            </div>
          </div>
          <div class="zone-info">
            <span>拖入卡牌 ({{ getGroupStatus('twentyFourPoint').count }}/{{ getGroupStatus('twentyFourPoint').required }})</span>
          </div>
        </div>

        <div class="zone" data-label="C区 · 比三张" :class="{ 'zone-ready': getGroupStatus('threeCard').ready }">
          <div class="zone-header">
            <span>比三张</span>
            <span class="zone-weight zone-weight-highlight">2×</span>
          </div>
          <div 
            class="zone-content"
            :class="{ 'zone-clickable': selectedCardIndex !== null }"
            @dragover.prevent
            @drop="onDrop($event, 'threeCard')"
            @click="onZoneClick('threeCard')"
          >
            <div 
              v-for="(player, index) in gameStore.players" 
              :key="player.id"
              class="zone-row"
              :class="{ 'is-player': !player.isAI, 'is-complete': getGroupStatus('threeCard').ready }"
            >
              <div class="zone-row-label">{{ getPlayerInitial(player, index) }}</div>
              <div class="zone-cards">
                <div 
                  v-for="(card, cardIndex) in getDisplayCards(player.id, 'threeCard', 3)" 
                  :key="cardIndex"
                  class="zone-card-mini"
                  :class="card === -1 ? 'card-back' : getCardColorClass(card)"
                  @click="card !== -1 && removeCardFromGroup(player.id, 'threeCard', cardIndex)"
                >
                  {{ card === -1 ? '' : card.displayName }}
                </div>
              </div>
              <div v-if="gameStore.gamePhase === 'roundResult' && getGroupScore(player.id, 'threeCard') > 0" class="zone-row-score">
                +{{ getGroupScore(player.id, 'threeCard') }}
              </div>
            </div>
          </div>
          <div class="zone-info">
            <span>拖入卡牌 ({{ getGroupStatus('threeCard').count }}/{{ getGroupStatus('threeCard').required }})</span>
          </div>
        </div>
      </main>

      <aside class="sidebar sidebar-right">
        <template v-if="gameStore.gamePhase === 'roundResult'">
          <div class="sidebar-title">
            <span class="title-line"></span>
            第 {{ gameStore.currentRound }} 轮结算{{ gameStore.subRound === 1 ? '(上回合)' : '(下回合)' }}
          </div>
          <div class="result-list">
            <div class="result-item header">
              <span>玩家</span>
              <span>得分</span>
              <span>累计</span>
            </div>
            <div 
              v-for="player in gameStore.players" 
              :key="player.id" 
              class="result-item"
            >
              <span class="result-name">{{ player.isAI ? '电脑' + player.id.replace('cpu', '') : '玩家' }}</span>
              <span class="result-score">+{{ gameStore.roundScores[player.id] || 0 }}</span>
              <span class="result-total">{{ gameStore.totalScores[player.id] || 0 }}</span>
            </div>
          </div>
          <div class="result-actions">
            <button class="btn btn-highlight" @click="handleNext">
              {{ gameStore.subRound === 1 ? '下回合' : (gameStore.isGameOver() ? '查看结果' : '下一轮') }}
            </button>
          </div>
        </template>
        <template v-else>
          <div class="sidebar-title">
            <span class="title-line"></span>
            LOGS
          </div>
          <div class="log-list">
            <div v-for="(log, index) in gameLogs" :key="index" class="log-entry">
              {{ log }}
            </div>
          </div>
        </template>
      </aside>
    </div>

    <div class="hand-area" v-if="gameStore.gamePhase === 'grouping'">
      <div class="hand-header">
        <div class="hand-header-left">
          <span class="hand-title">手牌</span>
          <span class="hand-count">剩余 {{ remainingHandCards }} 张</span>
        </div>
        <button class="btn-sort" @click="toggleSort">{{ sortModeText }}</button>
      </div>
      
      <div class="hand-cards">
        <div 
          v-for="(card, index) in playerHand" 
          :key="index"
          class="playing-card"
          :class="[getCardColorClass(card), { 'is-selected': selectedCardIndex === index, 'is-dragging': draggingIndex === index }]"
          draggable="true"
          @dragstart="onDragStart($event, card, index)"
          @dragend="onDragEnd"
          @click="handleCardClick(card, index)"
        >
          <div class="card-corner top">
            <span>{{ card.rank }}</span>
            <span>{{ getSuitSymbol(card.suit) }}</span>
          </div>
          <div class="card-center">{{ getSuitSymbol(card.suit) }}</div>
          <div class="card-corner bottom">
            <span>{{ card.rank }}</span>
            <span>{{ getSuitSymbol(card.suit) }}</span>
          </div>
        </div>
      </div>

      <div class="hand-actions" v-if="gameStore.gamePhase === 'grouping'">
        <button class="btn" @click="resetHand">清空</button>
        <button class="btn btn-highlight" :disabled="!canConfirm" @click="confirmGroup">确认出牌</button>
      </div>
    </div>

    <div class="rules-modal" v-if="showRules" @click.self="showRules = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>游戏规则</h2>
          <button class="rules-close" @click="showRules = false">×</button>
        </div>
        <div class="rules-body">
          <div class="rules-section">
            <h3>游戏目标</h3>
            <p>在可配置的轮次（默认5轮）结束后，累计积分最高的玩家获胜。玩家需通过合理分配手牌，在三种扑克小游戏（单张比大小、24点和、比三张）的每个小组中争取更高名次，从而最大化总分。</p>
          </div>

          <div class="rules-section">
            <h3>玩家配置</h3>
            <ul>
              <li>人类玩家：1名</li>
              <li>电脑对手数量：可配置 1~3 名，即总玩家数可为 2~4 人</li>
              <li>每轮每位玩家获得 12 张手牌（从一副去掉大小王的 52 张扑克中抽取）</li>
            </ul>
          </div>

          <div class="rules-section">
            <h3>游戏流程（每轮）</h3>
            <h4>1. 发牌</h4>
            <p>每轮开始前彻底洗牌，根据当前玩家总数 N，为每位玩家发放 12 张牌。剩余牌（52 - N×12）本轮弃用。</p>
            
            <h4>2. 分组阶段</h4>
            <p>每位玩家需将 12 张牌分成两份（每份 6 张），每份内部分为三个小组：</p>
            <ul>
              <li>1张牌组（单张组）</li>
              <li>2张牌组（24点组）</li>
              <li>3张牌组（比三张组）</li>
            </ul>
            <p>每位玩家共形成 6 个小组，各小组牌数固定，不可更改。所有手牌必须用完，不得剩余，小组之间牌不可重复。</p>
            
            <h4>3. 比较阶段</h4>
            <p>所有玩家完成分组后，同时亮出各组的牌，对每一个小组（共6组）独立进行以下比较：</p>
            
            <div class="rules-subsection">
              <h5>① 单张组</h5>
              <p>按扑克点数大小排序，从大到小：A > K > Q > J > 10 > 9 > … > 2</p>
              <p>花色大小为：黑桃 > 红桃 > 梅花 > 方片</p>
              <p>点数相同则平局</p>
            </div>
            
            <div class="rules-subsection">
              <h5>② 24点组</h5>
              <p>按两张牌的点数之和排序，和越大排名越高</p>
              <p>点数相同，则比较花色，花色大小为：黑桃 > 红桃 > 梅花 > 方片</p>
            </div>
            
            <div class="rules-subsection">
              <h5>③ 比三张组</h5>
              <p>按标准比三张牌型大小排序，优先级为：</p>
              <ol>
                <li>豹子（三张同点）</li>
                <li>同花顺（同花且顺子）</li>
                <li>同花（三张同花色）</li>
                <li>顺子（点数连续，A可作为1或14，但不可循环，如QKA、A23合法）</li>
                <li>对子（两张同点）</li>
                <li>散牌（高牌）</li>
              </ol>
              <p>若牌型相同，则依次比较单张点数（从大到小）；若仍相同，则比较花色，花色大小为：黑桃 > 红桃 > 梅花 > 方片</p>
            </div>
          </div>

          <div class="rules-section">
            <h3>积分规则</h3>
            <p>设有 P 名玩家（P = 2,3,4），每组根据排名分配积分：</p>
            <ul>
              <li>第一名获得 P-1 分</li>
              <li>第二名获得 P-2 分</li>
              <li>……</li>
              <li>最后一名 0 分</li>
            </ul>
            <p class="rules-highlight">比三张组的得分翻倍（即第一名得 2×(P-1) 分，第二名得 2×(P-2) 分，以此类推）</p>
            <p>每组独立计分，立即累加到玩家的累计总分中。</p>
          </div>

          <div class="rules-section">
            <h3>轮次循环</h3>
            <p>完成一轮所有 6 组的比较与计分后，若已进行轮数达到设定值，则游戏结束，显示最终排名；否则进入下一轮（重新洗牌、发牌、分组）。</p>
          </div>
        </div>
      </div>
    </div>

    <div class="rules-modal" v-if="showSettings" @click.self="showSettings = false">
      <div class="rules-content">
        <div class="rules-header">
          <h2>游戏设置</h2>
          <button class="rules-close" @click="showSettings = false">×</button>
        </div>
        <div class="rules-body">
          <div class="settings-group">
            <div class="settings-label">
              <span class="label-dot"></span>
              电脑玩家数量
            </div>
            <div class="slider-wrapper">
              <input 
                type="range" 
                v-model="settingsCpuCount" 
                min="1" 
                max="3" 
                class="slider"
                @change="updateSettingsCpuCount"
              />
              <div class="slider-marks">
                <span>1</span><span>2</span><span>3</span>
              </div>
            </div>
            <div class="settings-value">{{ settingsCpuCount }} 人</div>
          </div>
          
          <div class="settings-group">
            <div class="settings-label">
              <span class="label-dot"></span>
              游戏轮数
            </div>
            <div class="slider-wrapper">
              <input 
                type="range" 
                v-model="settingsRoundCount" 
                min="3" 
                max="7" 
                class="slider"
                @change="updateSettingsRoundCount"
              />
              <div class="slider-marks">
                <span>3</span><span>5</span><span>7</span>
              </div>
            </div>
            <div class="settings-value">{{ settingsRoundCount }} 轮</div>
          </div>
          
          <div class="settings-group">
            <div class="settings-label">
              <span class="label-dot"></span>
              排序方式
            </div>
            <div class="sort-toggle">
              <button 
                class="sort-btn" 
                :class="{ active: sortMode === 'rank' }"
                @click="sortMode = 'rank'"
              >
                先点数后花色
              </button>
              <button 
                class="sort-btn" 
                :class="{ active: sortMode === 'suit' }"
                @click="sortMode = 'suit'"
              >
                先花色后点数
              </button>
            </div>
          </div>
        </div>
        <div class="settings-footer">
          <button class="btn-confirm" @click="confirmSettings">确认</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, computed } from 'vue'
import gameStore from '../store/gameStore.js'
import AIPlayer from '../utils/AIPlayer.js'

export default {
  name: 'TripleCardBattlePC',
  emits: ['back-to-menu'],
  setup(props, { emit }) {
    const selectedCardIndex = ref(null)
    const draggingIndex = ref(null)
    const sortMode = ref('rank')
    const showRules = ref(false)
    const showSettings = ref(true)
    const settingsCpuCount = ref(1)
    const settingsRoundCount = ref(5)
    
    const updateSettingsCpuCount = () => {
      gameStore.playerCount = Number(settingsCpuCount.value) + 1
    }

    const updateSettingsRoundCount = () => {
      gameStore.totalRounds = Number(settingsRoundCount.value)
    }

    const confirmSettings = () => {
      gameStore.playerCount = Number(settingsCpuCount.value) + 1
      gameStore.totalRounds = Number(settingsRoundCount.value)
      gameStore.initGame(Number(settingsCpuCount.value) + 1, Number(settingsRoundCount.value))
      gameStore.startNewRound()
      showSettings.value = false
    }
    
    const playerHand = computed(() => {
      const player = gameStore.players.find(p => p.id === 'player')
      return player ? player.hand : []
    })

    const remainingHandCards = computed(() => {
      return playerHand.value.length
    })

    const sortModeText = computed(() => {
      return sortMode.value === 'rank' ? '先点数后花色' : '先花色后点数'
    })

    const gameLogs = ref([
      '初始化完成',
      '等待分组...'
    ])

    const statusText = computed(() => {
      if (gameStore.gamePhase === 'grouping') {
        return gameStore.subRound === 1 ? '等待分组 (第1回合)' : '等待分组 (第2回合)'
      } else if (gameStore.gamePhase === 'comparing') {
        return '分组确认'
      } else if (gameStore.gamePhase === 'roundResult') {
        return '本轮结果'
      }
      return '就绪'
    })

    const hasConfirmed = computed(() => {
      return gameStore.gamePhase === 'comparing' || gameStore.gamePhase === 'roundResult'
    })

    const canConfirm = computed(() => {
      if (gameStore.gamePhase !== 'grouping') return false

      const playerGroups = gameStore.playerGroups['player']
      if (!playerGroups) return false

      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      const singleCount = (playerGroups.single[subRoundIndex] || []).filter(c => c !== -1).length
      const twentyFourPointCount = (playerGroups.twentyFourPoint[subRoundIndex] || []).filter(c => c !== -1).length
      const threeCardCount = (playerGroups.threeCard[subRoundIndex] || []).filter(c => c !== -1).length

      return singleCount >= 1 && twentyFourPointCount >= 2 && threeCardCount >= 3
    })

    const getGroupStatus = (groupType) => {
      const playerGroups = gameStore.playerGroups['player']
      if (!playerGroups) return { ready: false, count: 0, required: 0 }
      
      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      let count = 0
      let required = 0
      
      if (groupType === 'single') {
        count = (playerGroups.single[subRoundIndex] || []).filter(c => c !== -1).length
        required = 1
      } else if (groupType === 'twentyFourPoint') {
        count = (playerGroups.twentyFourPoint[subRoundIndex] || []).filter(c => c !== -1).length
        required = 2
      } else if (groupType === 'threeCard') {
        count = (playerGroups.threeCard[subRoundIndex] || []).filter(c => c !== -1).length
        required = 3
      }
      
      return { ready: count >= required, count, required }
    }

    const getPlayerGroupCards = (playerId, groupType) => {
      const groups = gameStore.playerGroups[playerId]
      if (!groups) return []
      
      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      
      if (groupType === 'single') {
        return groups.single[subRoundIndex] || []
      } else if (groupType === 'twentyFourPoint') {
        return groups.twentyFourPoint[subRoundIndex] || []
      } else if (groupType === 'threeCard') {
        return groups.threeCard[subRoundIndex] || []
      }
      return []
    }

    const getDisplayCards = (playerId, groupType, requiredCount) => {
      const cards = getPlayerGroupCards(playerId, groupType)
      return cards
    }

    const getPlayerScore = (playerId) => {
      if (gameStore.subRound === 1) {
        return gameStore.totalScores[playerId] || 0
      } else {
        return gameStore.totalScores[playerId] || 0
      }
    }

    const getGroupScore = (playerId, groupType) => {
      if (gameStore.gamePhase === 'roundResult') {
        return gameStore.currentRoundGroupScores[playerId]?.[groupType] || 0
      }
      return 0
    }

    const getPlayerInitial = (player, index) => {
      if (!player.isAI) return 'P1'
      return 'P' + (index + 1)
    }

    const getSuitSymbol = (suit) => {
      const symbols = {
        'spades': '♠',
        'hearts': '♥',
        'clubs': '♣',
        'diamonds': '♦'
      }
      return symbols[suit] || ''
    }

    const getCardColorClass = (card) => {
      if (!card) return 'card-black'
      return card.color === 'red' ? 'card-red' : 'card-black'
    }

    const handleCardClick = (card, index) => {
      if (selectedCardIndex.value === index) {
        selectedCardIndex.value = null
      } else {
        selectedCardIndex.value = index
      }
    }

    const onZoneClick = (groupType) => {
      if (selectedCardIndex.value === null) return
      
      const index = selectedCardIndex.value
      const card = playerHand.value[index]
      if (!card) return

      const player = gameStore.players.find(p => p.id === 'player')
      if (!player || !player.hand) return

      let playerGroups = gameStore.playerGroups['player']
      if (!playerGroups) {
        gameStore.initPlayerGroups(gameStore.playerCount)
        playerGroups = gameStore.playerGroups['player']
      }

      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      const targetArray = playerGroups[groupType][subRoundIndex]
      const maxLength = groupType === 'single' ? 1 : (groupType === 'twentyFourPoint' ? 2 : 3)

      const validCards = targetArray.filter(c => c !== -1)
      const existingCards = [
        ...playerGroups.single[0], ...playerGroups.single[1],
        ...playerGroups.twentyFourPoint[0], ...playerGroups.twentyFourPoint[1],
        ...playerGroups.threeCard[0], ...playerGroups.threeCard[1]
      ].filter(c => c !== -1)
      const isInGroup = existingCards.some(c => c.rank === card.rank && c.suit === card.suit)
      
      if (!isInGroup && validCards.length < maxLength) {
        const emptyIndex = targetArray.findIndex(c => c === -1)
        if (emptyIndex !== -1) {
          targetArray[emptyIndex] = card
        } else {
          targetArray.push(card)
        }
        player.hand.splice(index, 1)
        gameStore.playerGroups['player'] = playerGroups
        selectedCardIndex.value = null
      }
    }

    const onDragStart = (event, card, index) => {
      draggingIndex.value = index
      event.dataTransfer.setData('cardIndex', index)
      event.dataTransfer.effectAllowed = 'move'
    }

    const onDragEnd = () => {
      draggingIndex.value = null
    }

    const onDrop = (event, groupType) => {
      const cardIndex = event.dataTransfer.getData('cardIndex')
      if (cardIndex === '' || cardIndex === null) return
      
      const index = parseInt(cardIndex)
      const card = playerHand.value[index]
      if (!card) return

      const player = gameStore.players.find(p => p.id === 'player')
      if (!player || !player.hand) return

      let playerGroups = gameStore.playerGroups['player']
      if (!playerGroups) {
        gameStore.initPlayerGroups(gameStore.playerCount)
        playerGroups = gameStore.playerGroups['player']
      }

      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      const targetArray = playerGroups[groupType][subRoundIndex]
      const maxLength = groupType === 'single' ? 1 : (groupType === 'twentyFourPoint' ? 2 : 3)

      const validCards = targetArray.filter(c => c !== -1)
      const existingCards = [
        ...playerGroups.single[0], ...playerGroups.single[1],
        ...playerGroups.twentyFourPoint[0], ...playerGroups.twentyFourPoint[1],
        ...playerGroups.threeCard[0], ...playerGroups.threeCard[1]
      ].filter(c => c !== -1)
      const isInGroup = existingCards.some(c => c.rank === card.rank && c.suit === card.suit)
      
      if (!isInGroup && validCards.length < maxLength) {
        const emptyIndex = targetArray.findIndex(c => c === -1)
        if (emptyIndex !== -1) {
          targetArray[emptyIndex] = card
        } else {
          targetArray.push(card)
        }
        player.hand.splice(index, 1)
        gameStore.playerGroups['player'] = playerGroups
      }

      draggingIndex.value = null
    }

    const removeCardFromGroup = (playerId, groupType, cardIndex) => {
      if (playerId !== 'player' || gameStore.gamePhase !== 'grouping') return

      const player = gameStore.players.find(p => p.id === playerId)
      if (!player || !player.hand) return

      const playerGroups = gameStore.playerGroups[playerId]
      if (!playerGroups || !playerGroups[groupType]) return

      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      const groupArray = playerGroups[groupType][subRoundIndex]
      if (cardIndex < 0 || cardIndex >= groupArray.length) return

      const card = groupArray[cardIndex]
      if (!card || card === -1) return

      groupArray[cardIndex] = -1
      player.hand.push(card)
      gameStore.playerGroups[playerId] = playerGroups
    }

    const resetHand = () => {
      gameStore.resetCurrentGroups()
      selectedCardIndex.value = null
    }

    const toggleSort = () => {
      const player = gameStore.players.find(p => p.id === 'player')
      if (!player || !player.hand) return

      const suitOrder = ['spades', 'hearts', 'clubs', 'diamonds']
      const rankOrder = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2']

      if (sortMode.value === 'rank') {
        player.hand.sort((a, b) => {
          const rankDiff = rankOrder.indexOf(a.rank) - rankOrder.indexOf(b.rank)
          if (rankDiff !== 0) return rankDiff
          return suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit)
        })
        sortMode.value = 'suit'
      } else {
        player.hand.sort((a, b) => {
          const suitDiff = suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit)
          if (suitDiff !== 0) return suitDiff
          return rankOrder.indexOf(a.rank) - rankOrder.indexOf(b.rank)
        })
        sortMode.value = 'rank'
      }
    }

    const confirmGroup = () => {
      if (!canConfirm.value) return
      
      const playerGroups = gameStore.playerGroups['player']
      const subRoundIndex = gameStore.subRound === 1 ? 0 : 1
      
      const groups = {
        single: playerGroups && playerGroups.single && playerGroups.single[subRoundIndex] ? playerGroups.single[subRoundIndex].filter(c => c !== -1) : [],
        twentyFourPoint: playerGroups && playerGroups.twentyFourPoint && playerGroups.twentyFourPoint[subRoundIndex] ? playerGroups.twentyFourPoint[subRoundIndex].filter(c => c !== -1) : [],
        threeCard: playerGroups && playerGroups.threeCard && playerGroups.threeCard[subRoundIndex] ? playerGroups.threeCard[subRoundIndex].filter(c => c !== -1) : []
      }
      
      gameStore.submitPlayerGroups(groups)
      gameStore.calculateRoundScores()
    }

    const handleNext = () => {
      if (gameStore.subRound === 1) {
        gameStore.prepareSecondRound()
      } else {
        if (gameStore.isGameOver()) {
          gameStore.endGame()
        } else {
          gameStore.startNewRound()
        }
      }
    }

    return {
      gameStore,
      playerHand,
      remainingHandCards,
      sortModeText,
      gameLogs,
      statusText,
      hasConfirmed,
      canConfirm,
      selectedCardIndex,
      draggingIndex,
      showRules,
      showSettings,
      settingsCpuCount,
      settingsRoundCount,
      updateSettingsCpuCount,
      updateSettingsRoundCount,
      confirmSettings,
      getGroupStatus,
      getPlayerGroupCards,
      getDisplayCards,
      getPlayerScore,
      getGroupScore,
      getPlayerInitial,
      getSuitSymbol,
      getCardColorClass,
      handleCardClick,
      onZoneClick,
      onDragStart,
      onDragEnd,
      onDrop,
      removeCardFromGroup,
      resetHand,
      toggleSort,
      confirmGroup,
      handleNext,
      backToMenu: () => emit('back-to-menu')
    }
  }
}
</script>

<style scoped>
.game {
  min-height: 100vh;
  background: #1a1a1a;
  display: flex;
  flex-direction: column;
  position: relative;
  font-family: 'JetBrains Mono', 'Consolas', monospace;
}

/* 噪点纹理覆盖层 */
.game::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  opacity: 0.12;
  pointer-events: none;
  z-index: 1;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  background: rgba(45, 42, 40, 0.92);
  border-bottom: 1px solid rgba(180, 170, 160, 0.15);
  position: relative;
  z-index: 10;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.25);
}

.header-left, .header-right {
  flex: 1;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 16px;
}

.header-right {
  text-align: right;
}

.logo {
  display: flex;
  align-items: center;
  gap: 8px;
}

.logo-icon {
  font-size: 18px;
  color: #c4a77d;
}

.logo-text {
  font-size: 18px;
  font-weight: 600;
  color: rgba(245, 240, 230, 0.95);
  letter-spacing: 1px;
}

.header-center {
  display: flex;
  gap: 32px;
}

.stat-block {
  text-align: center;
}

.stat-label {
  font-size: 13px;
  color: rgba(200, 190, 180, 0.7);
  letter-spacing: 1px;
}

.stat-value {
  font-size: 24px;
  color: #c4a77d;
  font-weight: 600;
}

.stat-divider {
  color: rgba(180, 170, 160, 0.4);
  margin: 0 2px;
}

.sub-round {
  font-size: 14px;
  color: rgba(200, 190, 180, 0.6);
  margin-left: 4px;
}

.status-indicator {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: #c4a77d;
  letter-spacing: 1px;
}

.status-dot {
  width: 6px;
  height: 6px;
  background: #c4a77d;
  border-radius: 50%;
  box-shadow: 0 0 6px rgba(196, 167, 125, 0.5);
}

.main-container {
  flex: 1;
  display: grid;
  grid-template-columns: 240px 1fr 240px;
  gap: 16px;
  padding: 16px;
  overflow: hidden;
}

.sidebar {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sidebar-right {
  
}

.sidebar-title {
  font-size: 11px;
  color: rgba(180, 170, 160, 0.5);
  letter-spacing: 1px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.title-line {
  width: 16px;
  height: 1px;
  background: rgba(180, 170, 160, 0.4);
}

.player-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.player-card {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background: rgba(50, 47, 44, 0.85);
  border: 1px solid rgba(180, 170, 160, 0.12);
  transition: all 0.2s;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.player-card.is-me {
  border-color: rgba(196, 167, 125, 0.35);
  background: rgba(196, 167, 125, 0.08);
}

.player-info {
  display: flex;
  align-items: center;
  gap: 10px;
}

.player-avatar {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(180, 170, 160, 0.12);
  border: 1px solid rgba(180, 170, 160, 0.25);
  font-size: 12px;
  color: rgba(220, 210, 200, 0.85);
}

.player-card.is-me .player-avatar {
  background: rgba(196, 167, 125, 0.18);
  border-color: rgba(196, 167, 125, 0.45);
  color: #c4a77d;
}

.player-name {
  font-size: 15px;
  color: rgba(245, 240, 230, 0.9);
}

.player-status {
  font-size: 13px;
  color: rgba(180, 170, 160, 0.65);
}

.player-score {
  font-size: 20px;
  color: #c4a77d;
  font-weight: 600;
}

.log-list {
  flex: 1;
  overflow-y: auto;
  font-size: 13px;
  color: rgba(200, 190, 180, 0.75);
  line-height: 1.8;
}

.log-entry {
  padding: 6px 0;
  border-bottom: 1px solid rgba(180, 170, 160, 0.1);
}

.workbench {
  display: grid;
  grid-template-columns: 1fr 2fr 3fr;
  gap: 12px;
}

.zone {
  background: rgba(50, 47, 44, 0.85);
  border: 1px solid rgba(180, 170, 160, 0.12);
  display: flex;
  flex-direction: column;
  min-height: 300px;
  transition: border-color 0.3s, box-shadow 0.3s;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}

.zone.zone-ready {
  border-color: #8b9a6d;
  box-shadow: 0 0 15px rgba(139, 154, 109, 0.2);
}

.zone::before {
  content: attr(data-label);
  position: absolute;
  top: -10px;
  left: 16px;
  background: #2d2a28;
  padding: 0 8px;
  font-size: 13px;
  color: #c4a77d;
  letter-spacing: 1px;
}

.zone-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.08);
  font-size: 15px;
  color: #c4a77d;
}

.zone-info {
  padding: 8px 16px;
  font-size: 13px;
  color: rgba(180, 170, 160, 0.65);
  border-top: 1px solid rgba(180, 170, 160, 0.06);
}

.zone-weight {
  color: #c4a77d;
}

.zone-weight-highlight {
  color: #b88a6f;
}

.zone-content {
  flex: 1;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.zone-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  background: rgba(100, 95, 90, 0.35);
  min-height: 44px;
}

.zone-row.is-player {
  background: rgba(184, 138, 111, 0.25);
}

.zone-row.is-complete {
  background: rgba(139, 154, 109, 0.3);
}

.zone-row-label {
  width: 24px;
  font-size: 13px;
  color: #c4a77d;
}

.zone-row-score {
  margin-left: 8px;
  font-size: 14px;
  font-weight: 600;
  color: #8b9a6d;
  min-width: 36px;
  text-align: right;
}

.zone-cards {
  display: flex;
  gap: 4px;
}

.zone-card-mini {
  padding: 4px 8px;
  background: #e8e4df;
  border: 1px solid rgba(120, 110, 100, 0.25);
  font-size: 16px;
  font-weight: bold;
  width: 6em;
  height: 30px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.zone-card-mini.card-red {
  color: #a05050;
}

.zone-card-mini.card-black {
  color: #3a3a3a;
}

.zone-card-mini.card-back {
  background: linear-gradient(135deg, #4a4540 25%, #6a6560 25%, #6a6560 50%, #4a4540 50%, #4a4540 75%, #6a6560 75%);
  background-size: 8px 8px;
  color: transparent;
  border-color: #8a8580;
}

.zone-empty {
  font-size: 13px;
  color: #3b82f6;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.hand-area {
  background: rgba(45, 42, 40, 0.95);
  border-top: 1px solid rgba(180, 170, 160, 0.12);
  padding: 16px 24px;
  box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.25);
}

.hand-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.hand-header-left {
  display: flex;
  align-items: center;
  gap: 12px;
}

.hand-title {
  font-size: 15px;
  color: #c4a77d;
  letter-spacing: 1px;
}

.hand-count {
  font-size: 14px;
  color: #c4a77d;
}

.btn-sort {
  padding: 6px 16px;
  font-size: 13px;
  font-family: inherit;
  letter-spacing: 1px;
  background: transparent;
  border: 1px solid rgba(196, 167, 125, 0.5);
  color: #c4a77d;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-sort:hover {
  background: rgba(196, 167, 125, 0.1);
  border-color: #c4a77d;
}

.hand-cards {
  display: flex;
  gap: 10px;
  justify-content: center;
  min-height: 100px;
}

.playing-card {
  width: 72px;
  height: 100px;
  background: #f0ece5;
  border: 1px solid rgba(140, 130, 120, 0.3);
  position: relative;
  cursor: grab;
  transition: all 0.2s;
  user-select: none;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
}

.playing-card:hover {
  transform: translateY(-8px);
  border-color: rgba(196, 167, 125, 0.5);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
}

.playing-card.is-selected {
  border-color: #c4a77d;
  border-width: 3px;
  box-shadow: 0 0 20px rgba(196, 167, 125, 0.4), inset 0 0 10px rgba(196, 167, 125, 0.1);
  transform: translateY(-4px);
}

.playing-card.is-selected:hover {
  transform: translateY(-8px);
}

.zone-clickable {
  cursor: pointer;
  transition: all 0.2s;
}

.zone-clickable:hover {
  background: rgba(196, 167, 125, 0.08);
  box-shadow: inset 0 0 20px rgba(196, 167, 125, 0.08);
}

.playing-card.is-dragging {
  opacity: 0.5;
}

.playing-card.card-red {
  color: #b56565;
}

.playing-card.card-black {
  color: #4a4a4a;
}

.card-corner {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 16px;
  font-weight: bold;
  line-height: 1.2;
}

.card-corner.top {
  top: 4px;
  left: 4px;
}

.card-corner.bottom {
  bottom: 4px;
  right: 4px;
  transform: rotate(180deg);
}

.card-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 24px;
}

.hand-actions {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 12px;
}

.btn {
  padding: 10px 24px;
  font-size: 14px;
  font-family: inherit;
  letter-spacing: 1px;
  background: transparent;
  border: 1px solid rgba(180, 170, 160, 0.35);
  color: rgba(220, 210, 200, 0.85);
  cursor: pointer;
  transition: all 0.2s;
}

.btn:hover {
  border-color: rgba(196, 167, 125, 0.6);
  color: rgba(245, 240, 230, 0.95);
}

.btn-highlight {
  background: #c4a77d;
  border-color: #c4a77d;
  color: #2d2a28;
}

.btn-highlight:hover {
  background: #d4b78d;
  border-color: #d4b78d;
  box-shadow: 0 4px 12px rgba(196, 167, 125, 0.3);
}

.btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.result-list {
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.result-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 12px;
  background: rgba(60, 57, 54, 0.5);
  border: 1px solid rgba(180, 170, 160, 0.08);
  font-size: 13px;
}

.result-item.header {
  background: rgba(196, 167, 125, 0.12);
  border-color: rgba(196, 167, 125, 0.2);
  font-size: 11px;
  color: rgba(180, 170, 160, 0.6);
}

.result-name {
  color: rgba(220, 210, 200, 0.8);
}

.result-score {
  color: #c4a77d;
  font-weight: 500;
}

.result-total {
  color: rgba(180, 170, 160, 0.6);
}

.result-actions {
  padding: 12px;
  display: flex;
  justify-content: center;
}

.result-actions .btn {
  width: 100%;
}

.rules-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: rgba(196, 167, 125, 0.1);
  border: 1px solid rgba(196, 167, 125, 0.3);
  border-radius: 6px;
  color: #c4a77d;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s;
}

.rules-btn:hover {
  background: rgba(196, 167, 125, 0.18);
  border-color: rgba(196, 167, 125, 0.5);
  box-shadow: 0 2px 8px rgba(196, 167, 125, 0.15);
}

.rules-icon {
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(196, 167, 125, 0.2);
  border-radius: 50%;
  font-size: 12px;
  font-weight: 600;
}

.rules-text {
  font-size: 13px;
}

.rules-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(30, 28, 26, 0.92);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 20px;
}

.rules-content {
  background: #2d2a28;
  border: 1px solid rgba(180, 170, 160, 0.15);
  border-radius: 12px;
  max-width: 700px;
  max-height: 80vh;
  width: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
}

.rules-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 24px;
  border-bottom: 1px solid rgba(180, 170, 160, 0.12);
}

.rules-header h2 {
  margin: 0;
  font-size: 20px;
  color: rgba(245, 240, 230, 0.95);
  font-weight: 600;
}

.rules-close {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(180, 170, 160, 0.08);
  border: 1px solid rgba(180, 170, 160, 0.15);
  border-radius: 6px;
  color: rgba(200, 190, 180, 0.7);
  font-size: 24px;
  cursor: pointer;
  transition: all 0.2s;
}

.rules-close:hover {
  background: rgba(196, 167, 125, 0.15);
  border-color: rgba(196, 167, 125, 0.3);
  color: rgba(245, 240, 230, 0.95);
}

.rules-body {
  flex: 1;
  overflow-y: auto;
  padding: 24px;
}

.rules-body::-webkit-scrollbar {
  width: 6px;
}

.rules-body::-webkit-scrollbar-track {
  background: rgba(180, 170, 160, 0.06);
}

.rules-body::-webkit-scrollbar-thumb {
  background: rgba(180, 170, 160, 0.25);
  border-radius: 3px;
}

.rules-section {
  margin-bottom: 24px;
}

.rules-section:last-child {
  margin-bottom: 0;
}

.rules-section h3 {
  margin: 0 0 12px 0;
  font-size: 16px;
  color: #c4a77d;
  font-weight: 600;
}

.rules-section h4 {
  margin: 16px 0 8px 0;
  font-size: 14px;
  color: rgba(230, 225, 215, 0.9);
  font-weight: 600;
}

.rules-section h5 {
  margin: 12px 0 6px 0;
  font-size: 13px;
  color: rgba(220, 215, 205, 0.85);
  font-weight: 600;
}

.rules-section p {
  margin: 0 0 8px 0;
  font-size: 13px;
  color: rgba(200, 190, 180, 0.8);
  line-height: 1.7;
}

.rules-section ul,
.rules-section ol {
  margin: 0 0 8px 0;
  padding-left: 20px;
  font-size: 13px;
  color: rgba(200, 190, 180, 0.8);
  line-height: 1.7;
}

.rules-section li {
  margin-bottom: 4px;
}

.rules-subsection {
  margin: 12px 0;
  padding: 12px;
  background: rgba(60, 57, 54, 0.4);
  border-radius: 8px;
}

.rules-highlight {
  padding: 10px 12px;
  background: rgba(196, 167, 125, 0.12);
  border-left: 3px solid #c4a77d;
  border-radius: 4px;
  color: rgba(230, 225, 215, 0.9);
  font-weight: 500;
}

.settings-group {
  margin-bottom: 28px;
}

.settings-group:last-child {
  margin-bottom: 0;
}

.settings-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: rgba(180, 170, 160, 0.65);
  margin-bottom: 14px;
  letter-spacing: 1px;
}

.settings-label .label-dot {
  width: 6px;
  height: 6px;
  background: #c4a77d;
  border-radius: 50%;
}

.slider-wrapper {
  padding: 0 2px;
}

.settings-group .slider {
  width: 100%;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(180, 170, 160, 0.15);
  border-radius: 2px;
  outline: none;
  cursor: pointer;
}

.settings-group .slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: #c4a77d;
  border-radius: 2px;
  cursor: pointer;
  box-shadow: 0 0 10px rgba(196, 167, 125, 0.35);
  transition: transform 0.15s;
}

.settings-group .slider::-webkit-slider-thumb:hover {
  transform: scale(1.1);
}

.slider-marks {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
  font-size: 10px;
  color: rgba(180, 170, 160, 0.4);
}

.settings-value {
  text-align: center;
  font-size: 24px;
  font-weight: 300;
  color: #c4a77d;
  margin-top: 12px;
  letter-spacing: 2px;
}

.sort-toggle {
  display: flex;
  gap: 12px;
}

.sort-btn {
  flex: 1;
  padding: 10px 16px;
  font-size: 12px;
  font-family: inherit;
  letter-spacing: 1px;
  background: rgba(60, 57, 54, 0.5);
  border: 1px solid rgba(180, 170, 160, 0.12);
  border-radius: 6px;
  color: rgba(180, 170, 160, 0.65);
  cursor: pointer;
  transition: all 0.2s;
}

.sort-btn:hover {
  background: rgba(80, 77, 74, 0.6);
  color: rgba(220, 210, 200, 0.85);
  border-color: rgba(196, 167, 125, 0.3);
}

.sort-btn.active {
  background: #c4a77d;
  border-color: #c4a77d;
  color: #2d2a28;
  font-weight: 600;
}

.settings-footer {
  padding: 16px 24px;
  border-top: 1px solid rgba(180, 170, 160, 0.12);
  display: flex;
  justify-content: flex-end;
}

.btn-confirm {
  padding: 10px 24px;
  font-size: 13px;
  font-family: inherit;
  letter-spacing: 1px;
  background: #c4a77d;
  border: none;
  border-radius: 6px;
  color: #2d2a28;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-confirm:hover {
  background: #d4b78d;
  box-shadow: 0 0 15px rgba(196, 167, 125, 0.35);
}
</style>

--- src/main.js ---
import { createApp } from 'vue'
import App from './App.vue'
import './style.css'

createApp(App).mount('#app')

--- src/store/bankGameStore.js ---
import { reactive } from 'vue'
import Card from '../utils/Card.js'
import { Suit } from '../utils/constants.js'

/**
 * 扑克抢银行游戏状态管理
 */
const bankGameStore = reactive({
  // 游戏状态: menu, setup, playing, paying, roundResult, gameOver
  gamePhase: 'menu',

  // 玩家数量 (2或3人)
  playerCount: 2,

  // 玩家列表
  players: [],

  // 当前回合玩家索引
  currentPlayerIndex: 0,

  // 牌堆
  deck: [],

  // 弃牌区
  discardPile: [],

  // 当前摸到的牌 (公共显示)
  currentDrawnCard: null,

  // 当前需要支付的金额
  requiredPayment: 0,

  // 支付者选择的牌
  selectedPaymentCards: [],

  // 游戏日志
  logs: [],

  // 是否显示规则
  showRules: false,

  // 游戏设置
  settings: {
    aiDelay: 1000,
  },

  // 金额映射表
  cardValueMap: {
    '5': 100,
    '6': 100,
    '7': 100,
    '8': 100,
    '9': 100,
    '10': 100,
    'J': 500,
    'Q': 500,
    'K': 500,
    'A': 1000,
    '2': 2000,
    '3': 3000,
    '4': 4000,
    'SMALL_JOKER': 5000,  // 小王
    'BIG_JOKER': 10000,   // 大王
  },

  /**
   * 获取牌的金额
   * @param {Card} card 扑克牌
   * @returns {number} 金额
   */
  getCardValue(card) {
    if (card.suit === Suit.JOKER) {
      // 大小王通过rank区分
      return card.rank === 'SMALL_JOKER' ? 5000 : 10000
    }
    return this.cardValueMap[card.rank] || 0
  },

  /**
   * 初始化游戏
   * @param {number} playerCount 玩家数量 (2或3)
   */
  initGame(playerCount = 2) {
    this.playerCount = playerCount
    this.gamePhase = 'playing'
    this.players = []
    this.currentPlayerIndex = 0
    this.deck = []
    this.discardPile = []
    this.currentDrawnCard = null
    this.requiredPayment = 0
    this.selectedPaymentCards = []
    this.logs = []

    // 创建玩家 (1人类 + 1-2 AI)
    this.players = [
      { id: 'player', name: '玩家', isAI: false, hand: [], isOut: false, totalValue: 0 },
    ]
    for (let i = 1; i < playerCount; i++) {
      this.players.push({
        id: `cpu${i}`,
        name: `电脑${i}`,
        isAI: true,
        hand: [],
        isOut: false,
        totalValue: 0,
      })
    }

    // 创建并洗牌
    this.createDeck()
    this.shuffleDeck()

    // 发牌 (每人5张)
    for (let i = 0; i < 5; i++) {
      for (let j = 0; j < playerCount; j++) {
        const card = this.deck.pop()
        if (card) {
          this.players[j].hand.push(card)
        }
      }
    }

    // 发牌后按金额排序手牌
    this.players.forEach((p) => {
      this.sortHand(p.hand)
    })

    // 随机决定先手玩家
    this.currentPlayerIndex = Math.floor(Math.random() * playerCount)

    this.addLog('游戏开始！每位玩家获得5张手牌')
    this.addLog(`${this.players[this.currentPlayerIndex].name} 获得先手`)

    // 如果是AI先手，自动执行
    if (this.getCurrentPlayer().isAI) {
      setTimeout(() => this.aiDrawCard(), this.settings.aiDelay)
    }
  },

  /**
   * 创建一副54张牌 (包含大小王)
   */
  createDeck() {
    this.deck = []
    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
    const suits = [Suit.SPADES, Suit.HEARTS, Suit.CLUBS, Suit.DIAMONDS]

    for (const suit of suits) {
      for (const rank of ranks) {
        this.deck.push(new Card(rank, suit))
      }
    }

    // 添加大小王
    this.deck.push(new Card('SMALL_JOKER', Suit.JOKER))
    this.deck.push(new Card('BIG_JOKER', Suit.JOKER))
  },

  /**
   * 洗牌
   */
  shuffleDeck() {
    for (let i = this.deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1))
      ;[this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]]
    }
  },

  /**
   * 排序手牌（按金额从大到小）
   * @param {Array} hand 手牌数组
   */
  sortHand(hand) {
    hand.sort((a, b) => this.getCardValue(b) - this.getCardValue(a))
  },

  /**
   * 获取当前玩家
   */
  getCurrentPlayer() {
    return this.players[this.currentPlayerIndex]
  },

  /**
   * 获取下一位未出局的玩家
   */
  getNextActivePlayer() {
    let nextIndex = (this.currentPlayerIndex + 1) % this.players.length
    let attempts = 0
    while (this.players[nextIndex].isOut && attempts < this.players.length) {
      nextIndex = (nextIndex + 1) % this.players.length
      attempts++
    }
    return attempts < this.players.length ? this.players[nextIndex] : null
  },

  /**
   * 获取下一位未出局玩家的索引
   */
  getNextActivePlayerIndex() {
    let nextIndex = (this.currentPlayerIndex + 1) % this.players.length
    let attempts = 0
    while (this.players[nextIndex].isOut && attempts < this.players.length) {
      nextIndex = (nextIndex + 1) % this.players.length
      attempts++
    }
    return attempts < this.players.length ? nextIndex : -1
  },

  /**
   * 摸牌
   */
  drawCard() {
    if (this.deck.length === 0) {
      this.addLog('牌堆已空，游戏结束')
      this.endGame()
      return
    }

    const player = this.getCurrentPlayer()
    const card = this.deck.pop()
    this.currentDrawnCard = card
    player.hand.push(card)
    this.sortHand(player.hand)

    const cardValue = this.getCardValue(card)
    this.addLog(`${player.name} 摸到 ${card.displayName}，价值 ${cardValue}`)

    // 进入支付阶段
    this.requiredPayment = cardValue
    this.gamePhase = 'paying'
    this.selectedPaymentCards = []

    // 确定下家
    const nextPlayerIndex = this.getNextActivePlayerIndex()
    if (nextPlayerIndex === -1 || nextPlayerIndex === this.currentPlayerIndex) {
      // 没有其他玩家了，或者只剩自己，游戏结束
      this.addLog('只剩一名玩家，游戏结束')
      this.endGame()
      return
    }

    const nextPlayer = this.players[nextPlayerIndex]
    this.addLog(`${nextPlayer.name} 需要支付 ${cardValue}`)

    // 如果是AI支付
    if (nextPlayer.isAI) {
      setTimeout(() => this.aiPay(), this.settings.aiDelay)
    }
  },

  /**
   * AI摸牌
   */
  aiDrawCard() {
    this.drawCard()
  },

  /**
   * 选择支付牌
   * @param {Card} card 选中的牌
   */
  togglePaymentCard(card) {
    const index = this.selectedPaymentCards.findIndex((c) => c === card)
    if (index === -1) {
      this.selectedPaymentCards.push(card)
    } else {
      this.selectedPaymentCards.splice(index, 1)
    }
  },

  /**
   * 判断牌是否被选中
   * @param {Card} card 牌
   */
  isCardSelected(card) {
    return this.selectedPaymentCards.includes(card)
  },

  /**
   * 获取当前选择牌的总金额
   */
  getSelectedTotalValue() {
    return this.selectedPaymentCards.reduce((sum, card) => sum + this.getCardValue(card), 0)
  },

  /**
   * 检查是否可以支付
   */
  canPay() {
    return this.getSelectedTotalValue() === this.requiredPayment
  },

  /**
   * 确认支付
   */
  confirmPayment() {
    if (!this.canPay()) return

    const nextPlayerIndex = this.getNextActivePlayerIndex()
    const payer = this.players[nextPlayerIndex]

    // 将选中的牌移入弃牌区
    for (const card of this.selectedPaymentCards) {
      const handIndex = payer.hand.findIndex((c) => c === card)
      if (handIndex !== -1) {
        payer.hand.splice(handIndex, 1)
        this.discardPile.push(card)
      }
    }

    this.addLog(`${payer.name} 成功支付 ${this.requiredPayment}`)

    // 支付者成为新的当前玩家
    this.currentPlayerIndex = nextPlayerIndex
    this.currentDrawnCard = null
    this.requiredPayment = 0
    this.selectedPaymentCards = []
    this.gamePhase = 'playing'

    // 检查牌堆是否已空
    if (this.deck.length === 0) {
      this.addLog('牌堆已空，游戏结束')
      this.endGame()
      return
    }

    // 如果是AI摸牌
    if (this.getCurrentPlayer().isAI) {
      setTimeout(() => this.aiDrawCard(), this.settings.aiDelay)
    }
  },

  /**
   * 放弃支付 (出局)
   */
  giveUp() {
    const nextPlayerIndex = this.getNextActivePlayerIndex()
    const payer = this.players[nextPlayerIndex]

    // 该玩家出局
    payer.isOut = true

    // 手牌全部弃置
    for (const card of payer.hand) {
      this.discardPile.push(card)
    }
    payer.hand = []

    this.addLog(`${payer.name} 无法支付，出局！`)

    // 检查是否只剩一名玩家
    const activePlayers = this.players.filter((p) => !p.isOut)
    if (activePlayers.length === 1) {
      this.addLog(`${activePlayers[0].name} 是最后存活的玩家`)
      this.endGame()
      return
    }

    // 检查牌堆是否已空
    if (this.deck.length === 0) {
      this.addLog('牌堆已空，游戏结束')
      this.endGame()
      return
    }

    // 下家成为新的当前玩家并立即摸牌
    this.currentPlayerIndex = nextPlayerIndex
    this.currentDrawnCard = null
    this.requiredPayment = 0
    this.selectedPaymentCards = []

    // 找到下一个未出局的玩家
    while (this.players[this.currentPlayerIndex].isOut) {
      this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length
    }

    this.gamePhase = 'playing'

    this.addLog(`轮到 ${this.getCurrentPlayer().name} 摸牌`)

    // 如果是AI摸牌
    if (this.getCurrentPlayer().isAI) {
      setTimeout(() => this.aiDrawCard(), this.settings.aiDelay)
    }
  },

  /**
   * AI支付逻辑
   */
  aiPay() {
    const payer = this.getNextActivePlayer()
    const targetValue = this.requiredPayment

    // 使用动态规划找最优解
    const solution = this.findPaymentSolution(payer.hand, targetValue)

    if (solution) {
      // 找到解决方案，选择这些牌
      this.selectedPaymentCards = solution
      setTimeout(() => this.confirmPayment(), this.settings.aiDelay)
    } else {
      // 无法支付，出局
      setTimeout(() => this.giveUp(), this.settings.aiDelay)
    }
  },

  /**
   * 使用动态规划找支付方案
   * @param {Array} hand 手牌
   * @param {number} target 目标金额
   * @returns {Array|null} 解决方案或null
   */
  findPaymentSolution(hand, target) {
    const n = hand.length
    // dp[i][v] 表示使用前i张牌能否凑出金额v
    const dp = Array(n + 1)
      .fill(null)
      .map(() => Array(target + 1).fill(false))
    dp[0][0] = true

    const values = hand.map((card) => this.getCardValue(card))

    for (let i = 1; i <= n; i++) {
      for (let v = 0; v <= target; v++) {
        dp[i][v] = dp[i - 1][v]
        if (v >= values[i - 1] && dp[i - 1][v - values[i - 1]]) {
          dp[i][v] = true
        }
      }
    }

    if (!dp[n][target]) return null

    // 回溯找出使用的牌
    const solution = []
    let v = target
    for (let i = n; i > 0 && v > 0; i--) {
      if (!dp[i - 1][v]) {
        solution.push(hand[i - 1])
        v -= values[i - 1]
      }
    }

    return solution
  },

  /**
   * 检查玩家是否能支付
   * @param {Object} player 玩家
   * @param {number} target 目标金额
   */
  canPlayerPay(player, target) {
    return this.findPaymentSolution(player.hand, target) !== null
  },

  /**
   * 游戏结束
   */
  endGame() {
    this.gamePhase = 'gameOver'

    // 计算每位存活玩家的手牌总金额
    this.players.forEach((player) => {
      if (!player.isOut) {
        player.totalValue = player.hand.reduce((sum, card) => sum + this.getCardValue(card), 0)
      } else {
        player.totalValue = 0
      }
    })

    // 按金额排序
    const sortedPlayers = [...this.players].sort((a, b) => b.totalValue - a.totalValue)

    this.addLog('游戏结束！')
    this.addLog('最终排名：')
    sortedPlayers.forEach((p, i) => {
      if (!p.isOut) {
        this.addLog(`${i + 1}. ${p.name}: ${p.totalValue}`)
      } else {
        this.addLog(`${i + 1}. ${p.name}: 出局`)
      }
    })
  },

  /**
   * 获取获胜者
   */
  getWinners() {
    const activePlayers = this.players.filter((p) => !p.isOut)
    if (activePlayers.length === 0) return []

    const maxValue = Math.max(...activePlayers.map((p) => p.totalValue))
    return activePlayers.filter((p) => p.totalValue === maxValue)
  },

  /**
   * 返回主菜单
   */
  backToMenu() {
    this.gamePhase = 'menu'
    this.players = []
    this.deck = []
    this.discardPile = []
    this.currentDrawnCard = null
    this.requiredPayment = 0
    this.selectedPaymentCards = []
    this.logs = []
  },

  /**
   * 重新开始
   */
  restart() {
    this.initGame(this.playerCount)
  },

  /**
   * 添加日志
   */
  addLog(message) {
    const time = new Date().toLocaleTimeString('zh-CN', {
      hour12: false,
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
    })
    this.logs.unshift(`[${time}] ${message}`)
    if (this.logs.length > 50) {
      this.logs.pop()
    }
  },

  /**
   * 获取牌堆剩余数量
   */
  get deckRemaining() {
    return this.deck.length
  },

  /**
   * 获取存活玩家数量
   */
  get activePlayerCount() {
    return this.players.filter((p) => !p.isOut).length
  },
})

export default bankGameStore

--- src/store/bluffGameStore.js ---
import { reactive } from 'vue'
import Card from '../utils/Card.js'
import { Suit, RANK_PRIORITY, SUIT_PRIORITY } from '../utils/constants.js'

/**
 * 吹牛皮游戏状态管理
 */
const bluffGameStore = reactive({
  // 游戏状态
  gamePhase: 'menu', // menu, playing, roundResult, gameOver

  // 玩家列表
  players: [],

  // 当前回合玩家索引
  currentPlayerIndex: 0,

  // 当前轮次点数 (A, 2, 3, ..., K)
  currentRank: null,

  // 牌堆状态
  pile: {
    accumulated: [], // 累积牌区
    latest: [], // 最新出牌区
  },

  // 弃牌区
  discardPile: [],

  // 最后出牌信息
  lastPlay: {
    playerId: null,
    cardCount: 0,
    claimedRank: null,
  },

  // 连续跳过计数
  skipCount: 0,

  // 游戏日志
  logs: [],

  // 选中的手牌索引
  selectedCardIndices: [],

  // 是否显示规则
  showRules: false,

  // 游戏设置
  settings: {
    aiDelay: 1000, // AI行动延迟(ms)
  },

  /**
   * 初始化游戏
   */
  initGame() {
    this.gamePhase = 'playing'
    this.players = []
    this.currentPlayerIndex = 0
    this.currentRank = null
    this.pile = { accumulated: [], latest: [] }
    this.discardPile = []
    this.skipCount = 0
    this.lastPlay = { playerId: null, cardCount: 0, claimedRank: null }
    this.logs = []
    this.selectedCardIndices = []

    // 创建玩家 (1人类 + 3AI)
    this.players = [
      { id: 'player', name: '玩家', isAI: false, hand: [], cardCount: 0 },
      { id: 'cpu1', name: '电脑1', isAI: true, hand: [], cardCount: 0 },
      { id: 'cpu2', name: '电脑2', isAI: true, hand: [], cardCount: 0 },
      { id: 'cpu3', name: '电脑3', isAI: true, hand: [], cardCount: 0 },
    ]

    // 生成并洗牌
    const deck = this.createDeck()
    this.shuffleDeck(deck)

    // 发牌 (每人13张，剩余2张弃置)
    for (let i = 0; i < 13; i++) {
      for (let j = 0; j < 4; j++) {
        const card = deck.pop()
        if (card) {
          this.players[j].hand.push(card)
        }
      }
    }

    // 发牌后排序手牌（先点数后花色）
    this.players.forEach((p) => {
      this.sortHand(p.hand)
      p.cardCount = p.hand.length
    })

    // 随机决定首位出牌玩家
    this.currentPlayerIndex = Math.floor(Math.random() * 4)

    this.addLog('游戏开始！每位玩家获得13张牌')
    this.addLog(`${this.players[this.currentPlayerIndex].name} 获得首发出牌权`)
  },

  /**
   * 排序手牌（先点数后花色）
   * @param {Array} hand 手牌数组
   */
  sortHand(hand) {
    hand.sort((a, b) => {
      // 先按点数排序
      const rankDiff = RANK_PRIORITY[b.rank] - RANK_PRIORITY[a.rank]
      if (rankDiff !== 0) return rankDiff

      // 点数相同按花色排序
      return SUIT_PRIORITY[b.suit] - SUIT_PRIORITY[a.suit]
    })
  },

  /**
   * 创建一副54张牌
   */
  createDeck() {
    const deck = []
    const ranks = [
      'A',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      '10',
      'J',
      'Q',
      'K',
    ]
    const suits = [Suit.SPADES, Suit.HEARTS, Suit.CLUBS, Suit.DIAMONDS]

    for (const suit of suits) {
      for (const rank of ranks) {
        deck.push(new Card(rank, suit))
      }
    }

    // 添加大小王
    deck.push(new Card('JOKER', Suit.JOKER))
    deck.push(new Card('JOKER', Suit.JOKER))

    return deck
  },

  /**
   * 洗牌
   */
  shuffleDeck(deck) {
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1))
      ;[deck[i], deck[j]] = [deck[j], deck[i]]
    }
  },

  /**
   * 获取当前玩家
   */
  getCurrentPlayer() {
    return this.players[this.currentPlayerIndex]
  },

  /**
   * 切换到下一个玩家
   */
  nextPlayer() {
    this.currentPlayerIndex = (this.currentPlayerIndex + 1) % 4
  },

  /**
   * 添加日志
   */
  addLog(message) {
    const time = new Date().toLocaleTimeString('zh-CN', {
      hour12: false,
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
    })
    this.logs.unshift(`[${time}] ${message}`)
    if (this.logs.length > 50) {
      this.logs.pop()
    }
  },

  /**
   * 判断是否为新一轮开始(牌堆为空)
   */
  isNewRound() {
    return this.pile.accumulated.length === 0 && this.pile.latest.length === 0
  },

  /**
   * 出牌
   * @param {string} playerId 玩家ID
   * @param {number[]} cardIndices 出牌的手牌索引
   * @param {string} claimedRank 宣称的点数
   */
  playCards(playerId, cardIndices, claimedRank) {
    const player = this.players.find((p) => p.id === playerId)
    if (!player) return false

    // 获取要出的牌
    const playedCards = cardIndices.map((i) => player.hand[i]).filter((c) => c)
    if (playedCards.length === 0) return false

    // 如果不是新一轮，验证宣称点数
    if (!this.isNewRound() && claimedRank !== this.currentRank) {
      return false
    }

    // 将上一家的牌移入累积区
    if (this.pile.latest.length > 0) {
      this.pile.accumulated.push(...this.pile.latest)
    }

    // 将新牌放入最新区
    this.pile.latest = playedCards

    // 从手牌中移除
    // 按索引降序排序，避免删除时索引错乱
    const sortedIndices = [...cardIndices].sort((a, b) => b - a)
    for (const index of sortedIndices) {
      player.hand.splice(index, 1)
    }
    player.cardCount = player.hand.length

    // 更新最后出牌信息
    this.lastPlay = {
      playerId: playerId,
      cardCount: playedCards.length,
      claimedRank: claimedRank,
    }

    // 设置当前点数
    this.currentRank = claimedRank

    // 重置跳过计数
    this.skipCount = 0

    this.addLog(`${player.name} 出了 ${playedCards.length} 张 ${claimedRank}`)

    // 检查是否获胜
    if (player.hand.length === 0) {
      this.gamePhase = 'gameOver'
      this.addLog(`${player.name} 手牌出完，获得胜利！`)
      return true
    }

    // 切换到下一个玩家
    this.nextPlayer()
    return true
  },

  /**
   * 质疑
   * @param {string} challengerId 质疑者ID
   */
  challenge(challengerId) {
    const challenger = this.players.find((p) => p.id === challengerId)
    if (!challenger) return null

    const lastPlayer = this.players.find((p) => p.id === this.lastPlay.playerId)
    if (!lastPlayer) return null

    // 验证最新出牌区的牌
    const isAllTrue = this.pile.latest.every(
      (card) =>
        card.rank === this.lastPlay.claimedRank || card.rank === 'JOKER',
    )

    let result = {
      success: !isAllTrue,
      challengerId: challengerId,
      challengedId: this.lastPlay.playerId,
      revealedCards: [...this.pile.latest],
    }

    // 记录最后出牌的人（在清空牌堆前）
    const lastPlayerId = this.lastPlay.playerId
    let nextPlayerId

    if (isAllTrue) {
      // 质疑失败，质疑者收回所有牌，最后出牌的人获得出牌权
      challenger.hand.push(...this.pile.accumulated, ...this.pile.latest)
      this.sortHand(challenger.hand)
      challenger.cardCount = challenger.hand.length
      nextPlayerId = lastPlayerId // 最后出牌的人获得出牌权
      this.addLog(
        `${challenger.name} 质疑失败！收回 ${this.pile.accumulated.length + this.pile.latest.length} 张牌`,
      )
    } else {
      // 质疑成功，上家收回所有牌，质疑者获得出牌权
      lastPlayer.hand.push(...this.pile.accumulated, ...this.pile.latest)
      this.sortHand(lastPlayer.hand)
      lastPlayer.cardCount = lastPlayer.hand.length
      nextPlayerId = challengerId // 质疑者获得出牌权
      this.addLog(
        `${challenger.name} 质疑成功！${lastPlayer.name} 收回 ${this.pile.accumulated.length + this.pile.latest.length} 张牌`,
      )
    }

    // 清空牌堆
    this.pile.accumulated = []
    this.pile.latest = []
    this.currentRank = null
    this.skipCount = 0
    this.lastPlay = { playerId: null, cardCount: 0, claimedRank: null }

    // 设置下一轮出牌权
    this.currentPlayerIndex = this.players.findIndex(
      (p) => p.id === nextPlayerId,
    )
    const nextPlayer = this.players[this.currentPlayerIndex]
    this.addLog(`${nextPlayer.name} 获得下一轮出牌权`)

    return result
  },

  /**
   * 跳过（不质疑，不出牌）
   * 仅在有上家出牌时可用，跳过本轮，轮到下一家
   */
  skip() {
    const currentPlayer = this.getCurrentPlayer()
    if (!currentPlayer) return false

    // 必须是有上家出牌的情况下才能跳过
    if (this.pile.latest.length === 0) {
      return false
    }

    this.addLog(`${currentPlayer.name} 选择跳过`)
    this.skipCount++

    // 检查是否所有其他玩家都跳过了（3人跳过 = 其他3人都跳过）
    if (this.skipCount >= 3) {
      // 全部跳过，牌堆进入弃牌区
      const allCards = [...this.pile.accumulated, ...this.pile.latest]
      this.discardPile.push(...allCards)
      const discardedCount = allCards.length

      // 清空牌堆
      this.pile.accumulated = []
      this.pile.latest = []
      this.currentRank = null
      this.skipCount = 0

      // 最后出牌者获得出牌权
      const lastPlayerIndex = this.players.findIndex(
        (p) => p.id === this.lastPlay.playerId,
      )
      this.currentPlayerIndex = lastPlayerIndex
      this.lastPlay = { playerId: null, cardCount: 0, claimedRank: null }

      const lastPlayer = this.players[lastPlayerIndex]
      this.addLog(`全部跳过！${discardedCount}张牌进入弃牌区`)
      this.addLog(`${lastPlayer.name} 获得下一轮出牌权`)
      return true
    }

    this.nextPlayer()
    return true
  },

  /**
   * 获取可用的点数列表 (A-K)
   */
  getAvailableRanks() {
    return ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
  },

  /**
   * 切换手牌选中状态
   */
  toggleCardSelection(index) {
    const pos = this.selectedCardIndices.indexOf(index)
    if (pos > -1) {
      this.selectedCardIndices.splice(pos, 1)
    } else {
      this.selectedCardIndices.push(index)
    }
  },

  /**
   * 清空选中
   */
  clearSelection() {
    this.selectedCardIndices = []
  },

  /**
   * 重新开始游戏
   */
  restartGame() {
    this.initGame()
  },

  /**
   * 返回主菜单
   */
  backToMenu() {
    this.gamePhase = 'menu'
    this.players = []
    this.currentPlayerIndex = 0
    this.currentRank = null
    this.pile = { accumulated: [], latest: [] }
    this.lastPlay = { playerId: null, cardCount: 0, claimedRank: null }
    this.logs = []
    this.selectedCardIndices = []
  },
})

export default bluffGameStore

--- src/store/gameStore.js ---
import Deck from '../utils/Deck.js'
import AIPlayer from '../utils/AIPlayer.js'
import RuleEvaluator from '../utils/RuleEvaluator.js'
import { reactive, readonly } from 'vue'

const state = reactive({
  gameType: 'tripleCard',
  playerCount: 2,
  totalRounds: 5,
  currentRound: 0,
  subRound: 1,
  players: [],
  playerGroups: {},
  roundScores: {},
  tempRoundScores: {},
  firstRoundGroupScores: {},
  groupScores: {},
  currentRoundGroupScores: {},
  totalScores: {},
  gamePhase: 'menu',
  winner: null,
  playerHandBackup: []
})

class GameStore {
  constructor() {
  }

  get gameType() { return state.gameType }
  set gameType(v) { state.gameType = v }

  get playerCount() { return state.playerCount }
  set playerCount(v) { state.playerCount = v }

  get totalRounds() { return state.totalRounds }
  set totalRounds(v) { state.totalRounds = v }

  get currentRound() { return state.currentRound }
  set currentRound(v) { state.currentRound = v }

  get subRound() { return state.subRound }
  set subRound(v) { state.subRound = v }

  get players() { return state.players }
  set players(v) { state.players = v }

  get playerGroups() { return state.playerGroups }
  set playerGroups(v) { state.playerGroups = v }

  get roundScores() { return state.roundScores }
  set roundScores(v) { state.roundScores = v }

  get tempRoundScores() { return state.tempRoundScores }
  set tempRoundScores(v) { state.tempRoundScores = v }

  get firstRoundGroupScores() { return state.firstRoundGroupScores }
  set firstRoundGroupScores(v) { state.firstRoundGroupScores = v }

  get groupScores() { return state.groupScores }
  set groupScores(v) { state.groupScores = v }

  get currentRoundGroupScores() { return state.currentRoundGroupScores }
  set currentRoundGroupScores(v) { state.currentRoundGroupScores = v }

  get totalScores() { return state.totalScores }
  set totalScores(v) { state.totalScores = v }

  get gamePhase() { return state.gamePhase }
  set gamePhase(v) { state.gamePhase = v }

  get winner() { return state.winner }
  set winner(v) { state.winner = v }

  reset() {
    state.playerCount = 2
    state.totalRounds = 5
    state.currentRound = 0
    state.subRound = 1
    state.players.length = 0
    state.players.push({ id: 'player', name: '玩家', isAI: false })
    state.playerGroups = {}
    state.roundScores = {}
    state.tempRoundScores = {}
    state.firstRoundGroupScores = {}
    state.groupScores = {}
    state.currentRoundGroupScores = {}
    state.totalScores = {}
    state.gamePhase = 'menu'
    state.winner = null
    state.playerHandBackup = []
  }

  createDeck() {
    return new Deck()
  }

  initPlayerGroups(playerCount) {
    this.playerGroups = {}
    
    const playerIds = ['player']
    for (let i = 1; i < playerCount; i++) {
      playerIds.push(`cpu${i}`)
    }
    
    playerIds.forEach(id => {
      this.playerGroups[id] = {
        single: [[-1], [-1]],
        twentyFourPoint: [[-1, -1], [-1, -1]],
        threeCard: [[-1, -1, -1], [-1, -1, -1]]
      }
    })
  }

  initGame(playerCount, totalRounds) {
    this.playerCount = playerCount
    this.totalRounds = totalRounds
    this.currentRound = 0
    state.players.length = 0
    state.playerGroups = {}
    state.roundScores = {}
    state.totalScores = {}

    state.players.push({ id: 'player', name: '玩家', isAI: false })

    for (let i = 1; i < playerCount; i++) {
      state.players.push({ id: `cpu${i}`, name: `电脑${i}`, isAI: true })
    }

    state.players.forEach(p => {
      state.totalScores[p.id] = 0
    })

    this.initPlayerGroups(playerCount)
    this.gamePhase = 'grouping'
  }

  startNewRound() {
    this.currentRound++
    this.subRound = 1
    const deck = this.createDeck()
    deck.shuffle()
    this.initPlayerGroups(this.players.length)
    this.roundScores = {}
    this.tempRoundScores = {}
    this.firstRoundGroupScores = {}
    this.groupScores = {}
    this.currentRoundGroupScores = {}

    const suitOrder = ['spades', 'hearts', 'clubs', 'diamonds']
    const rankOrder = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2']

    this.players.forEach(player => {
      const hand = deck.drawMultiple(12)
      hand.sort((a, b) => {
        const suitDiff = suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit)
        if (suitDiff !== 0) return suitDiff
        return rankOrder.indexOf(a.rank) - rankOrder.indexOf(b.rank)
      })
      player.hand = hand
    })

    state.playerHandBackup = JSON.parse(JSON.stringify(this.players.map(p => p.hand)))

    this.gamePhase = 'grouping'
  }

  resetCurrentGroups() {
    const subRoundIndex = this.subRound === 1 ? 0 : 1

    const player = this.players.find(p => p.id === 'player')
    if (player && player.hand) {
      const usedCards = [
        ...(this.playerGroups['player'].single[subRoundIndex] || []),
        ...(this.playerGroups['player'].twentyFourPoint[subRoundIndex] || []),
        ...(this.playerGroups['player'].threeCard[subRoundIndex] || [])
      ].filter(c => c !== -1)
      
      const usedCardKeys = new Set(usedCards.map(c => c.rank + c.suit))
      player.hand = player.hand.filter(c => !usedCardKeys.has(c.rank + c.suit))
      usedCards.forEach(card => {
        if (!player.hand.some(h => h.rank === card.rank && h.suit === card.suit)) {
          player.hand.push(card)
        }
      })
    }

    this.playerGroups['player'] = {
      single: [[-1], [-1]],
      twentyFourPoint: [[-1, -1], [-1, -1]],
      threeCard: [[-1, -1, -1], [-1, -1, -1]]
    }

    this.players.forEach(player => {
      if (player.isAI) {
        this.playerGroups[player.id] = {
          single: [[-1], [-1]],
          twentyFourPoint: [[-1, -1], [-1, -1]],
          threeCard: [[-1, -1, -1], [-1, -1, -1]]
        }
      }
    })
  }

  submitPlayerGroups(groups) {
    const subRoundIndex = this.subRound === 1 ? 0 : 1
    
    if (!this.playerGroups['player']) {
      this.playerGroups['player'] = {
        single: [[-1], [-1]],
        twentyFourPoint: [[-1, -1], [-1, -1]],
        threeCard: [[-1, -1, -1], [-1, -1, -1]]
      }
    }
    
    this.playerGroups['player'].single[subRoundIndex] = groups.single.length > 0 ? [groups.single[0]] : [-1]
    this.playerGroups['player'].twentyFourPoint[subRoundIndex] = [groups.twentyFourPoint[0] || -1, groups.twentyFourPoint[1] || -1]
    this.playerGroups['player'].threeCard[subRoundIndex] = [groups.threeCard[0] || -1, groups.threeCard[1] || -1, groups.threeCard[2] || -1]

    this.players.forEach(player => {
      if (player.isAI) {
        if (!this.playerGroups[player.id]) {
          this.playerGroups[player.id] = {
            single: [[-1], [-1]],
            twentyFourPoint: [[-1, -1], [-1, -1]],
            threeCard: [[-1, -1, -1], [-1, -1, -1]]
          }
        }
        
        const groups = AIPlayer.decide(player.hand, 'smart')
        
        this.playerGroups[player.id].single[subRoundIndex] = [groups.single[0] || -1]
        this.playerGroups[player.id].twentyFourPoint[subRoundIndex] = [groups.twentyFourPoint[0] || -1, groups.twentyFourPoint[1] || -1]
        this.playerGroups[player.id].threeCard[subRoundIndex] = [groups.threeCard[0] || -1, groups.threeCard[1] || -1, groups.threeCard[2] || -1]

        const usedCards = [...groups.single, ...groups.twentyFourPoint, ...groups.threeCard]
        player.hand = player.hand.filter(c =>
          !usedCards.some(used => used.rank === c.rank && used.suit === c.suit)
        )
      }
    })

    this.gamePhase = 'comparing'
  }

  calculateRoundScores() {
    if (this.subRound === 2) {
      this.firstRoundGroupScores = JSON.parse(JSON.stringify(this.groupScores))
    }

    this.groupScores = {}
    this.players.forEach(p => {
      this.groupScores[p.id] = { single: 0, twentyFourPoint: 0, threeCard: 0 }
    })

    this.currentRoundGroupScores = {}
    this.players.forEach(p => {
      this.currentRoundGroupScores[p.id] = { single: 0, twentyFourPoint: 0, threeCard: 0 }
    })
    
    this.roundScores = {}
    this.players.forEach(p => {
      this.roundScores[p.id] = 0
    })

    const groupTypes = [
      { key: 'single', type: 'single', isDouble: false },
      { key: '24point', type: '24point', isDouble: false },
      { key: 'threeCard', type: 'threecard', isDouble: true }
    ]

    groupTypes.forEach(gt => {
      const playersData = this.players.map(p => {
        let cards = []
        const subRoundIndex = this.subRound === 1 ? 0 : 1
        
        if (gt.key === 'single') {
          cards = (this.playerGroups[p.id]?.single[subRoundIndex] || []).filter(c => c !== -1)
        } else if (gt.key === '24point') {
          cards = (this.playerGroups[p.id]?.twentyFourPoint[subRoundIndex] || []).filter(c => c !== -1)
        } else if (gt.key === 'threeCard') {
          cards = (this.playerGroups[p.id]?.threeCard[subRoundIndex] || []).filter(c => c !== -1)
        }
        return { playerId: p.id, cards }
      })

      const validPlayersData = playersData.filter(pd => pd.cards.length > 0)
      
      if (validPlayersData.length === 0) return

      const ranks = RuleEvaluator.calculateGroupRank(validPlayersData, gt.type)

      ranks.forEach(r => {
        const score = RuleEvaluator.calculateScore(r.rank, this.playerCount, gt.isDouble)
        
        this.roundScores[r.playerId] = (this.roundScores[r.playerId] || 0) + score
        
        const groupKey = gt.key === '24point' ? 'twentyFourPoint' : gt.key
        this.currentRoundGroupScores[r.playerId][groupKey] = score
        this.groupScores[r.playerId][groupKey] = score
      })
    })

    if (this.subRound === 2) {
      this.players.forEach(p => {
        const first = this.firstRoundGroupScores[p.id] || { single: 0, twentyFourPoint: 0, threeCard: 0 }
        this.groupScores[p.id].single += first.single
        this.groupScores[p.id].twentyFourPoint += first.twentyFourPoint
        this.groupScores[p.id].threeCard += first.threeCard
      })
    }

    if (this.subRound === 1) {
      this.tempRoundScores = { ...this.roundScores }
    } else {
      this.players.forEach(p => {
        const totalScore = (this.tempRoundScores[p.id] || 0) + (this.roundScores[p.id] || 0)
        this.totalScores[p.id] += totalScore
      })
    }

    this.gamePhase = 'roundResult'
  }

  isGameOver() {
    return this.currentRound >= this.totalRounds
  }

  getFinalResult() {
    const sortedPlayers = [...this.players].sort((a, b) =>
      this.totalScores[b.id] - this.totalScores[a.id]
    )

    const winner = sortedPlayers[0]
    const isTie = sortedPlayers.length > 1 &&
      this.totalScores[sortedPlayers[0].id] === this.totalScores[sortedPlayers[1].id]

    return {
      winner,
      isTie,
      rankings: sortedPlayers.map((p, index) => ({
        rank: index + 1,
        player: p,
        score: this.totalScores[p.id]
      }))
    }
  }

  endGame() {
    this.gamePhase = 'gameOver'
    this.winner = this.getFinalResult()
  }

  backToMenu() {
    this.gamePhase = 'menu'
    this.currentRound = 0
    this.subRound = 1
    state.players = []
    state.playerGroups = {}
    state.roundScores = {}
    state.tempRoundScores = {}
    state.firstRoundGroupScores = {}
    state.groupScores = {}
    state.currentRoundGroupScores = {}
    state.totalScores = {}
    state.winner = null
    state.playerHandBackup = []
  }

  validateGroups(groups) {
    const requiredCards = {
      single: 1,
      twentyFourPoint: 2,
      threeCard: 3
    }

    const singleCount = (groups.single || []).filter(c => c !== -1).length
    const twentyFourPointCount = (groups.twentyFourPoint || []).filter(c => c !== -1).length
    const threeCardCount = (groups.threeCard || []).filter(c => c !== -1).length

    if (singleCount !== requiredCards.single) {
      return { valid: false, error: `单张组需要${requiredCards.single}张牌，当前${singleCount}张` }
    }
    if (twentyFourPointCount !== requiredCards.twentyFourPoint) {
      return { valid: false, error: `24点组需要${requiredCards.twentyFourPoint}张牌，当前${twentyFourPointCount}张` }
    }
    if (threeCardCount !== requiredCards.threeCard) {
      return { valid: false, error: `比三张组需要${requiredCards.threeCard}张牌，当前${threeCardCount}张` }
    }

    const allCards = [
      ...groups.single,
      ...groups.twentyFourPoint,
      ...groups.threeCard
    ].filter(c => c !== -1)
    
    const uniqueCards = new Set(allCards.map(c => c.rank + c.suit))
    if (uniqueCards.size !== 6) {
      return { valid: false, error: `需要6张不同的牌，当前${uniqueCards.size}张` }
    }

    return { valid: true, error: null }
  }

  prepareSecondRound() {
    const player = this.players.find(p => p.id === 'player')
    if (player && player.hand) {
      const usedCards = [
        ...(this.playerGroups['player'].single[0] || []),
        ...(this.playerGroups['player'].twentyFourPoint[0] || []),
        ...(this.playerGroups['player'].threeCard[0] || [])
      ].filter(c => c !== -1)
      
      const usedCardKeys = new Set(usedCards.map(c => c.rank + c.suit))
      player.hand = player.hand.filter(c => !usedCardKeys.has(c.rank + c.suit))
    }

    this.players.forEach(player => {
      if (player.isAI && player.hand) {
        const usedCards = [
          ...(this.playerGroups[player.id].single[0] || []),
          ...(this.playerGroups[player.id].twentyFourPoint[0] || []),
          ...(this.playerGroups[player.id].threeCard[0] || [])
        ].filter(c => c !== -1)
        
        const usedCardKeys = new Set(usedCards.map(c => c.rank + c.suit))
        player.hand = player.hand.filter(c => !usedCardKeys.has(c.rank + c.suit))
      }
    })

    this.subRound = 2
    this.gamePhase = 'grouping'
  }
}

const gameStore = new GameStore()

export default gameStore

--- src/store/marbleGameStore.js ---
import { reactive } from 'vue'

const marbleGameStore = reactive({
  gamePhase: 'menu',
  
  startGame() {
    this.gamePhase = 'playing'
  },
  
  backToMenu() {
    this.gamePhase = 'menu'
  },
  
  endGame() {
    this.gamePhase = 'gameOver'
  }
})

export default marbleGameStore

--- src/store/setGameStore.js ---
import { reactive, readonly } from 'vue'

const COLORS = ['red', 'green', 'purple']
const SHAPES = ['oval', 'square', 'diamond']
const SHADINGS = ['solid', 'striped', 'open']
const NUMBERS = [1, 2, 3]

const COLOR_VALUES = {
  red: '#e74c3c',
  green: '#27ae60',
  purple: '#8e44ad'
}

const state = reactive({
  gameType: 'set',
  gamePhase: 'menu',
  score: 0,
  timeElapsed: 0,
  timerInterval: null,
  deck: [],
  boardCards: [],
  selectedCards: [],
  playerFoundSets: [],
  playerSetCount: 0,
  computerSetCount: 0,
  hintsUsed: 0,
  hintsFree: 3,
  showHint: false,
  hintCards: [],
  isGameOver: false,
  winner: null,
  animationState: {
    active: false,
    cards: [],
    scoreAnimation: null,
    scoreValue: 0,
    scoreTargetX: 0,
    scoreTargetY: 0
  }
})

function generateDeck() {
  const deck = []
  let id = 0
  for (const color of COLORS) {
    for (const shape of SHAPES) {
      for (const shading of SHADINGS) {
        for (const number of NUMBERS) {
          deck.push({
            id: id++,
            color,
            shape,
            shading,
            number,
            colorValue: COLOR_VALUES[color]
          })
        }
      }
    }
  }
  return deck
}

function shuffleDeck(deck) {
  const shuffled = [...deck]
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1))
    ;[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]
  }
  return shuffled
}

function isSet(cards) {
  if (cards.length !== 3) return false
  console.log('isSet', cards)
  const attributes = ['color', 'shape', 'shading', 'number']
  
  for (const attr of attributes) {
    const values = cards.map(c => c[attr])
    const uniqueValues = [...new Set(values)]
    
    if (uniqueValues.length !== 1 && uniqueValues.length !== 3) {
      return false
    }
  }
  
  return true
}

function findHint(boardCards) {
  for (let i = 0; i < boardCards.length; i++) {
    for (let j = i + 1; j < boardCards.length; j++) {
      for (let k = j + 1; k < boardCards.length; k++) {
        if (isSet([boardCards[i], boardCards[j], boardCards[k]])) {
          return [boardCards[i], boardCards[j], boardCards[k]]
        }
      }
    }
  }
  return []
}

class SetGameStore {
  constructor() {
  }

  get gameType() { return state.gameType }
  get gamePhase() { return state.gamePhase }
  set gamePhase(v) { state.gamePhase = v }

  get score() { return state.score }
  set score(v) { state.score = v }

  get timeElapsed() { return state.timeElapsed }
  set timeElapsed(v) { state.timeElapsed = v }

  get deck() { return state.deck }
  set deck(v) { state.deck = v }

  get boardCards() { return state.boardCards }
  set boardCards(v) { state.boardCards = v }

  get selectedCards() { return state.selectedCards }
  set selectedCards(v) { state.selectedCards = v }

  get playerFoundSets() { return state.playerFoundSets }
  set playerFoundSets(v) { state.playerFoundSets = v }

  get playerSetCount() { return state.playerSetCount }
  set playerSetCount(v) { state.playerSetCount = v }

  get computerSetCount() { return state.computerSetCount }
  set computerSetCount(v) { state.computerSetCount = v }

  get hintsUsed() { return state.hintsUsed }
  set hintsUsed(v) { state.hintsUsed = v }

  get hintsFree() { return state.hintsFree }
  set hintsFree(v) { state.hintsFree = v }

  get animationState() { return state.animationState }
  set animationState(v) { state.animationState = v }

  get showHint() { return state.showHint }
  set showHint(v) { state.showHint = v }

  get hintCards() { return state.hintCards }
  set hintCards(v) { state.hintCards = v }

  get isGameOver() { return state.isGameOver }
  set isGameOver(v) { state.isGameOver = v }

  get winner() { return state.winner }
  set winner(v) { state.winner = v }

  reset() {
    this.stopTimer()
    state.gamePhase = 'menu'
    state.score = 0
    state.timeElapsed = 0
    state.deck = []
    state.boardCards = []
    state.selectedCards = []
    state.playerFoundSets = []
    state.playerSetCount = 0
    state.computerSetCount = 0
    state.hintsUsed = 0
    state.hintsFree = 3
    state.showHint = false
    state.hintCards = []
    state.isGameOver = false
    state.winner = null
    state.animationState = {
      active: false,
      cards: [],
      scoreAnimation: null,
      scoreValue: 0,
      scoreTargetX: 0,
      scoreTargetY: 0
    }
  }

  startGame() {
    this.reset()
    state.deck = shuffleDeck(generateDeck())
    state.boardCards = state.deck.splice(0, 12)
    state.gamePhase = 'playing'
    this.startTimer()
  }

  startTimer() {
    state.timerInterval = setInterval(() => {
      state.timeElapsed++
    }, 1000)
  }

  stopTimer() {
    if (state.timerInterval) {
      clearInterval(state.timerInterval)
      state.timerInterval = null
    }
  }

  selectCard(card) {
    if (state.gamePhase !== 'playing') return
    
    const index = state.selectedCards.findIndex(c => c.id === card.id)
    
    if (index >= 0) {
      state.selectedCards.splice(index, 1)
    } else if (state.selectedCards.length < 3) {
      state.selectedCards.push(card)
    }
    
    if (state.selectedCards.length === 3) {
      this.checkSet()
    }
  }

  checkSet() {
    if (isSet(state.selectedCards)) {
      state.playerFoundSets.push([...state.selectedCards])
      state.playerSetCount++
      state.score += 100
      
      const selectedIds = state.selectedCards.map(c => c.id)
      const removedIndices = []
      state.boardCards = state.boardCards.filter((c, index) => {
        if (selectedIds.includes(c.id)) {
          removedIndices.push(index)
          return false
        }
        return true
      })
      
      const newCards = []
      if (state.boardCards.length < 12 && state.deck.length > 0) {
        const needed = 12 - state.boardCards.length
        const drawnCards = state.deck.splice(0, needed)
        newCards.push(...drawnCards)
      }
      
      if (removedIndices.length > 0 && newCards.length > 0) {
        let cardIndex = 0
        const sortedIndices = [...removedIndices].sort((a, b) => a - b)
        sortedIndices.forEach((index, i) => {
          if (cardIndex < newCards.length) {
            state.boardCards.splice(index, 0, newCards[cardIndex])
            cardIndex++
          }
        })
        while (cardIndex < newCards.length) {
          state.boardCards.push(newCards[cardIndex])
          cardIndex++
        }
      } else if (newCards.length > 0) {
        state.boardCards.push(...newCards)
      }
      
      state.selectedCards = []
      state.showHint = false
      
      state.animationState = {
        active: true,
        cards: [...state.playerFoundSets[state.playerFoundSets.length - 1]],
        scoreAnimation: 'score',
        scoreValue: 100,
        scoreTargetX: 0,
        scoreTargetY: 0
      }
      
      setTimeout(() => {
        state.animationState.active = false
        state.animationState.cards = []
      }, 1000)
      
      this.checkGameOver()
    } else {
      setTimeout(() => {
        state.selectedCards = []
      }, 500)
    }
  }

  useHint() {
    const hint = findHint(state.boardCards)
    if (hint.length > 0) {
      if (state.hintsFree > 0) {
        state.hintsFree--
      } else {
        state.hintsUsed++
        state.score -= 50
      }
      state.hintCards = hint
      state.showHint = true
      
      // 5秒后自动隐藏提示
      if (state.hintTimeout) {
        clearTimeout(state.hintTimeout)
      }
      state.hintTimeout = setTimeout(() => {
        state.showHint = false
        state.hintCards = []
      }, 5000)
    }
  }

  addMoreCards() {
    if (state.deck.length >= 3) {
      const newCards = state.deck.splice(0, 3)
      state.boardCards.push(...newCards)
    }
  }

  checkGameOver() {
    const remainingSets = findHint(state.boardCards)
    
    if (remainingSets.length === 0 && state.deck.length === 0) {
      this.endGame()
    }
  }

  endGame() {
    this.stopTimer()
    state.gamePhase = 'gameOver'
    state.isGameOver = true

    if (state.playerSetCount > state.computerSetCount) {
      state.winner = 'player'
    } else if (state.playerSetCount < state.computerSetCount) {
      state.winner = 'computer'
    } else {
      state.winner = 'tie'
    }
  }

  backToMenu() {
    this.stopTimer()
    state.gamePhase = 'menu'
    state.score = 0
    state.timeElapsed = 0
    state.deck = []
    state.boardCards = []
    state.selectedCards = []
    state.playerFoundSets = []
    state.playerSetCount = 0
    state.computerSetCount = 0
    state.hintsUsed = 0
    state.hintsFree = 3
    state.showHint = false
    state.hintCards = []
    state.isGameOver = false
    state.winner = null
    state.animationState = {
      active: false,
      cards: [],
      scoreAnimation: null,
      scoreValue: 0,
      scoreTargetX: 0,
      scoreTargetY: 0
    }
  }

  isSet(cards) {
    return isSet(cards)
  }

  getCardDisplayName(card) {
    const colorNames = { red: '红', green: '绿', purple: '紫' }
    const shapeNames = { oval: '椭圆', square: '正方形', diamond: '菱形' }
    const shadingNames = { solid: '实心', striped: '条纹', open: '空心' }
    
    return `${colorNames[card.color]}${shapeNames[card.shape]}${shadingNames[card.shading]}${card.number}个`
  }
}

const setGameStore = new SetGameStore()

export default setGameStore
export { COLORS, SHAPES, SHADINGS, NUMBERS, COLOR_VALUES, isSet }

--- src/style.css ---
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  font-size: 16px;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}

body {
  font-family: 'Microsoft YaHei', 'PingFang SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #1a472a 0%, #2d5a3f 50%, #1a472a 100%);
  min-height: 100vh;
  min-height: 100dvh;
  color: #fff;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overflow-x: hidden;
}

#app {
  width: 100%;
  min-height: 100vh;
  min-height: 100dvh;
}

@media (max-width: 768px) {
  html {
    font-size: 14px;
  }

  body {
    background: #0a0a0c;
    overscroll-behavior: none;
  }
}

@media (hover: none) and (pointer: coarse) {
  * {
    -webkit-tap-highlight-color: transparent;
  }

  input, button, select, textarea {
    touch-action: manipulation;
  }
}

@supports (padding: max(0px)) {
  body {
    padding-left: max(0px, env(safe-area-inset-left));
    padding-right: max(0px, env(safe-area-inset-right));
  }
}

::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

@media (max-width: 768px) {
  ::-webkit-scrollbar {
    width: 4px;
    height: 4px;
  }
}

::selection {
  background: rgba(59, 130, 246, 0.3);
  color: #fff;
}

input, button, select, textarea {
  font-family: inherit;
  font-size: inherit;
}

button {
  cursor: pointer;
  border: none;
  background: none;
}

a {
  color: #3b82f6;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

img {
  max-width: 100%;
  height: auto;
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.animate-fade-in {
  animation: fadeIn 0.3s ease-out;
}

.animate-slide-up {
  animation: slideUp 0.3s ease-out;
}

.animate-pulse {
  animation: pulse 2s ease-in-out infinite;
}

@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

--- src/utils/AIPlayer.js ---
import Card from './Card.js'
import RuleEvaluator from './RuleEvaluator.js'

/**
 * AI对手类
 * 使用枚举算法实现最优分组策略
 */
class AIPlayer {
  /**
   * 生成数组的所有组合
   * @param {Array} arr 输入数组
   * @param {number} k 组合大小
   * @returns {Array} 所有组合的数组
   */
  static combinations(arr, k) {
    const result = []
    if (k === 0) {
      result.push([])
      return result
    }
    if (k === arr.length) {
      result.push([...arr])
      return result
    }
    if (k > arr.length) {
      return result
    }

    function helper(start, current) {
      if (current.length === k) {
        result.push([...current])
        return
      }
      for (let i = start; i < arr.length; i++) {
        current.push(arr[i])
        helper(i + 1, current)
        current.pop()
      }
    }

    helper(0, [])
    return result
  }

  /**
   * 评估分组分数
   * @param {Card[]} singleCard 单张组
   * @param {Card[]} twentyFourCards 24点组（2张）
   * @param {Card[]} pokerCards 炸金花组（3张）
   * @returns {number} 总分
   */
  static evaluateGroup(singleCard, twentyFourCards, pokerCards) {
    if (!singleCard || singleCard.length === 0 || !singleCard[0]) return 0
    if (!twentyFourCards || twentyFourCards.length < 2 || !twentyFourCards[0] || !twentyFourCards[1]) return 0
    if (!pokerCards || pokerCards.length < 3 || !pokerCards[0] || !pokerCards[1] || !pokerCards[2]) return 0

    const scoreSingle = RuleEvaluator.scoreSingle(singleCard[0])
    const score24 = RuleEvaluator.score24(twentyFourCards[0], twentyFourCards[1])
    const scorePoker = RuleEvaluator.scorePoker(pokerCards[0], pokerCards[1], pokerCards[2])

    return scoreSingle + score24 + 2 * scorePoker
  }

  /**
   * 枚举最优分组（上半回合：12张牌选6张）
   * @param {Card[]} hand 玩家手牌（12张）
   * @returns {Object} 最优分组结果
   */
  static enumerateBestGroup(hand) {
    if (hand.length === 6) {
      return this.enumerateSixCards(hand)
    }

    const sixCardCombinations = this.combinations(hand, 6)
    
    let bestScore = -Infinity
    let bestGroup = null
    let bestCombination = null

    for (const combination of sixCardCombinations) {
      const group = this.enumerateSixCards(combination)
      if (group) {
        const score = this.evaluateGroup(
          group.single,
          group.twentyFourPoint,
          group.threeCard
        )
        
        if (score > bestScore) {
          bestScore = score
          bestGroup = group
          bestCombination = combination
        }
      }
    }

    if (!bestGroup) {
      return this.smartStrategy(hand)
    }

    const remainingCards = hand.filter(card => 
      !bestCombination.some(c => c.rank === card.rank && c.suit === card.suit)
    )

    return {
      single: bestGroup.single,
      twentyFourPoint: bestGroup.twentyFourPoint,
      threeCard: bestGroup.threeCard,
      remainingCards: remainingCards
    }
  }

  /**
   * 枚举6张牌的所有可能分配
   * @param {Card[]} sixCards 6张牌
   * @returns {Object} 最优分组
   */
  static enumerateSixCards(sixCards) {
    const singleCombinations = this.combinations(sixCards, 1)
    
    let bestScore = -Infinity
    let bestGroup = null

    for (const singleCard of singleCombinations) {
      const remainingFor24 = sixCards.filter(card => 
        !singleCard.some(c => c.rank === card.rank && c.suit === card.suit)
      )
      
      const twentyFourCombinations = this.combinations(remainingFor24, 2)
      
      for (const twentyFourCards of twentyFourCombinations) {
        const pokerCards = remainingFor24.filter(card => 
          !twentyFourCards.some(c => c.rank === card.rank && c.suit === card.suit)
        )

        if (pokerCards.length !== 3) continue

        const score = this.evaluateGroup(singleCard, twentyFourCards, pokerCards)
        
        if (score > bestScore) {
          bestScore = score
          bestGroup = {
            single: [singleCard[0]],
            twentyFourPoint: [twentyFourCards[0], twentyFourCards[1]],
            threeCard: [pokerCards[0], pokerCards[1], pokerCards[2]]
          }
        }
      }
    }

    return bestGroup
  }

  /**
   * 智能分组策略（高性能）
   * @param {Card[]} hand 玩家手牌（12张或6张）
   * @returns {Object} 分组结果
   */
  static smartStrategy(hand) {
    // 如果是6张牌，直接分组
    if (hand.length === 6) {
      return this._smartGroupSixCards(hand)
    }
    
    // 如果是12张牌，先选出最优的6张，再分组
    const sorted = [...hand].sort((a, b) => b.rankValue - a.rankValue)
    
    // 启发式选择：优先选择高点数牌和可能形成好牌型的牌
    const selected = this._selectBestSixCards(hand)
    
    return this._smartGroupSixCards(selected)
  }
  
  /**
   * 从12张牌中选择最优的6张
   * @param {Card[]} hand 12张手牌
   * @returns {Card[]} 选出的6张牌
   */
  static _selectBestSixCards(hand) {
    const sorted = [...hand].sort((a, b) => b.rankValue - a.rankValue)
    
    // 启发式策略：优先保留高点数牌
    // 同时考虑24点组合和比三张的牌型潜力
    const candidates = [...sorted]
    const selected = []
    
    // 1. 选一张最大的作为单张候选
    selected.push(candidates.shift())
    
    // 2. 找最佳24点组合（两张牌点数之和最大）
    const bestTwo = this._findBestTwoCards(candidates)
    selected.push(...bestTwo)
    bestTwo.forEach(c => {
      const idx = candidates.findIndex(card => card.rank === c.rank && card.suit === c.suit)
      if (idx > -1) candidates.splice(idx, 1)
    })
    
    // 3. 找最佳三张牌（比三张）
    const bestThree = this._findBestThreeCards(candidates)
    selected.push(...bestThree)
    
    // 如果选不够6张，从剩余牌中补充
    while (selected.length < 6 && candidates.length > 0) {
      selected.push(candidates.shift())
    }
    
    return selected
  }
  
  /**
   * 智能分组6张牌
   * @param {Card[]} sixCards 6张牌
   * @returns {Object} 分组结果
   */
  static _smartGroupSixCards(sixCards) {
    const cards = [...sixCards]
    
    // 1. 单张：选最大点数的
    const bestSingle = this._findBestSingleCard(cards)
    cards.splice(cards.indexOf(bestSingle), 1)
    
    // 2. 24点：从剩余牌中选点数之和最大的两张
    const bestTwo = this._findBestTwoCards(cards)
    bestTwo.forEach(c => {
      const idx = cards.findIndex(card => card.rank === c.rank && card.suit === c.suit)
      if (idx > -1) cards.splice(idx, 1)
    })
    
    // 3. 比三张：剩下的3张
    const bestThree = [...cards]
    
    return {
      single: [bestSingle],
      twentyFourPoint: bestTwo,
      threeCard: bestThree,
      remainingCards: []
    }
  }

  /**
   * 找出最佳单张牌
   * @param {Card[]} cards 可选牌
   * @returns {Card|null}
   */
  static _findBestSingleCard(cards) {
    if (!cards || cards.length === 0) return null
    return cards.reduce((best, card) => 
      card.rankValue > best.rankValue ? card : best
    )
  }

  /**
   * 找出最佳两张牌
   * @param {Card[]} cards 可选牌
   * @returns {Card[]}
   */
  static _findBestTwoCards(cards) {
    if (!cards || cards.length < 2) return []
    let bestPair = []
    let bestSum = 0

    for (let i = 0; i < cards.length; i++) {
      for (let j = i + 1; j < cards.length; j++) {
        const sum = cards[i].rankValue + cards[j].rankValue
        if (sum > bestSum) {
          bestSum = sum
          bestPair = [cards[i], cards[j]]
        }
      }
    }
    return bestPair
  }

  /**
   * 找出最佳三张牌
   * @param {Card[]} cards 可选牌
   * @returns {Card[]}
   */
  static _findBestThreeCards(cards) {
    if (!cards || cards.length < 3) return []
    let bestThree = []
    let bestType = { priority: 0 }

    for (let i = 0; i < cards.length; i++) {
      for (let j = i + 1; j < cards.length; j++) {
        for (let k = j + 1; k < cards.length; k++) {
          const type = RuleEvaluator.getThreeCardType(cards[i], cards[j], cards[k])
          const priority = RuleEvaluator.TYPE_PRIORITY[type.type]
          if (priority > bestType.priority) {
            bestType = type
            bestThree = [cards[i], cards[j], cards[k]]
          } else if (priority === bestType.priority && type.mainRank > bestType.mainRank) {
            bestThree = [cards[i], cards[j], cards[k]]
            bestType = type
          }
        }
      }
    }
    return bestThree
  }

  /**
   * 随机分组策略
   * @param {Card[]} hand 玩家手牌
   * @returns {Object} 分组结果
   */
  static randomStrategy(hand) {
    const shuffled = [...hand].sort(() => Math.random() - 0.5)
    return this._assignCards(shuffled)
  }

  /**
   * 将12张牌分配到6个组
   * @param {Card[]} cards 已排序的12张牌
   * @returns {Object} 分组结果
   */
  static _assignCards(cards) {
    const result = {
      single: [cards[0], cards[6]],
      twentyFourPoint: [cards[1], cards[2], cards[7], cards[8]],
      threeCard: [cards[3], cards[4], cards[5], cards[9], cards[10], cards[11]]
    }

    return {
      single: [result.single[0], result.single[1]],
      twentyFourPoint: [result.twentyFourPoint[0], result.twentyFourPoint[1]],
      threeCard: [result.threeCard[0], result.threeCard[1], result.threeCard[2]],
      remainingCards: [result.single[1], result.twentyFourPoint[1], result.twentyFourPoint[2], result.threeCard[2], result.threeCard[3], result.threeCard[4]]
    }
  }

  /**
   * 执行AI分组决策
   * @param {Card[]} hand 玩家手牌
   * @param {string} strategy 策略类型: 'random' | 'smart' | 'enumerate'
   * @returns {Object} 分组结果
   */
  static decide(hand, strategy = 'enumerate') {
    if (strategy === 'random') {
      return this.randomStrategy(hand)
    }
    
    if (strategy === 'enumerate') {
      if (hand.length === 6) {
        return this.enumerateSixCards(hand)
      }
      return this.enumerateBestGroup(hand)
    }
    
    // smart strategy - 使用启发式算法，性能更好
    return this.smartStrategy(hand)
  }
}

export default AIPlayer

--- src/utils/BluffAI.js ---
/**
 * 吹牛皮游戏AI
 * 实现AI的质疑策略、跟牌策略和首发策略
 */
class BluffAI {
  /**
   * AI决策
   * @param {Object} player 当前AI玩家
   * @param {Object} gameState 游戏状态
   * @returns {Object} 决策结果 { type: 'play'|'challenge'|'skip', data: {...} }
   */
  static makeDecision(player, gameState) {
    const { currentRank, pile, lastPlay, players } = gameState

    // 如果有上家出牌，决定是否质疑
    if (pile.latest.length > 0 && lastPlay.playerId !== player.id) {
      const shouldChallenge = this.decideChallenge(player, gameState)
      if (shouldChallenge) {
        return { type: 'challenge' }
      }
    }

    // 如果不是新一轮，可以选择跳过或出牌
    if (pile.latest.length > 0) {
      const shouldSkip = this.decideSkip(player, gameState)
      if (shouldSkip) {
        return { type: 'skip' }
      }
    }

    // 出牌决策
    const playDecision = this.decidePlayCards(player, gameState)
    return { type: 'play', data: playDecision }
  }

  /**
   * 跳过决策
   * @param {Object} player 当前AI玩家
   * @param {Object} gameState 游戏状态
   * @returns {boolean} 是否跳过
   */
  static decideSkip(player, gameState) {
    const { currentRank, pile, lastPlay } = gameState

    // 如果没有上家出牌，不能跳过
    if (pile.latest.length === 0) {
      return false
    }

    // 如果自己是最后出牌者，不能跳过（必须出牌或质疑）
    if (lastPlay.playerId === player.id) {
      return false
    }

    // 统计牌堆总大小
    const pileSize = pile.accumulated.length + pile.latest.length

    // 统计自己手中当前点数的真牌
    const trueCards = player.hand.filter(c => c.rank === currentRank || c.rank === 'JOKER')

    // 如果没有真牌
    if (trueCards.length === 0) {
      // 牌堆较大时更倾向于跳过（避免吹牛被质疑后收大牌堆）
      if (pileSize >= 6) {
        return Math.random() < 0.8  // 80%概率跳过
      }
      if (pileSize >= 3) {
        return Math.random() < 0.6  // 60%概率跳过
      }
      return Math.random() < 0.4  // 40%概率跳过
    }

    // 如果只有1张真牌
    if (trueCards.length === 1) {
      // 牌堆较大时更倾向于跳过
      if (pileSize >= 8) {
        return Math.random() < 0.6
      }
      // 手牌较多时，30%概率跳过
      if (player.hand.length > 5) {
        return Math.random() < 0.3
      }
    }

    return false
  }

  /**
   * 质疑决策
   * @param {Object} player 当前AI玩家
   * @param {Object} gameState 游戏状态
   * @returns {boolean} 是否质疑
   */
  static decideChallenge(player, gameState) {
    const { currentRank, lastPlay, players } = gameState
    const n = lastPlay.cardCount

    // 统计自己手中当前点数的普通牌和万能牌
    const myNormal = player.hand.filter(c => c.rank === currentRank).length
    const myJoker = player.hand.filter(c => c.rank === 'JOKER').length

    // 计算外部最多可能有多少张真牌+万能牌
    const maxTrueOutside = (4 - myNormal) + (2 - myJoker)

    // 如果上家出牌数 > 外部最多真牌数，必定质疑
    if (n > maxTrueOutside) {
      return true
    }

    // 计算质疑概率
    let P = 0

    if (n >= 3 && myNormal >= 2) {
      P = 0.7
    } else if (n === 2) {
      P = 0.3
    } else if (n === 1) {
      P = 0.1
    }

    // 手牌少时更谨慎
    if (player.hand.length <= 2) {
      P = P * 0.5
    }

    // 随机决定是否质疑
    return Math.random() < P
  }

  /**
   * 出牌决策
   * @param {Object} player 当前AI玩家
   * @param {Object} gameState 游戏状态
   * @returns {Object} { cardIndices: number[], claimedRank: string }
   */
  static decidePlayCards(player, gameState) {
    const { currentRank, pile } = gameState

    // 如果是新一轮(牌堆为空)，执行首发策略
    if (pile.accumulated.length === 0 && pile.latest.length === 0) {
      return this.firstPlayStrategy(player)
    }

    // 否则执行跟牌策略
    return this.followPlayStrategy(player, currentRank)
  }

  /**
   * 首发策略
   * @param {Object} player 当前AI玩家
   * @returns {Object} { cardIndices: number[], claimedRank: string }
   */
  static firstPlayStrategy(player) {
    // 统计各点数普通牌数量(不含万能牌)
    const rankCount = {}
    const normalCards = player.hand.filter(c => c.rank !== 'JOKER')
    const jokers = player.hand.filter(c => c.rank === 'JOKER')

    for (const card of normalCards) {
      rankCount[card.rank] = (rankCount[card.rank] || 0) + 1
    }

    // 找出数量最多的点数
    let maxCount = 0
    let bestRanks = []

    for (const [rank, count] of Object.entries(rankCount)) {
      if (count > maxCount) {
        maxCount = count
        bestRanks = [rank]
      } else if (count === maxCount) {
        bestRanks.push(rank)
      }
    }

    // 如果全是万能牌
    if (bestRanks.length === 0) {
      if (jokers.length > 0) {
        // 随机选一个点数，出1张万能牌
        const randomRank = ['A', 'K', 'Q'][Math.floor(Math.random() * 3)]
        const jokerIndex = player.hand.findIndex(c => c.rank === 'JOKER')
        return {
          cardIndices: [jokerIndex],
          claimedRank: randomRank
        }
      }
    }

    // 随机选择一个数量最多的点数
    const selectedRank = bestRanks[Math.floor(Math.random() * bestRanks.length)]

    // 找出该点数的所有牌
    const cardsOfRank = player.hand
      .map((c, i) => ({ card: c, index: i }))
      .filter(({ card }) => card.rank === selectedRank)

    // 最多出3张
    const cardsToPlay = cardsOfRank.slice(0, 3)
    let cardIndices = cardsToPlay.map(({ index }) => index)

    // 如果需要凑整，可以加入万能牌
    if (cardsToPlay.length < 3 && jokers.length > 0) {
      const jokersToAdd = Math.min(jokers.length, cardsToPlay.length, 3 - cardsToPlay.length)
      for (let i = 0; i < jokersToAdd; i++) {
        const jokerIndex = player.hand.findIndex((c, idx) => c.rank === 'JOKER' && !cardIndices.includes(idx))
        if (jokerIndex !== -1) {
          cardIndices.push(jokerIndex)
        }
      }
    }

    return {
      cardIndices: cardIndices,
      claimedRank: selectedRank
    }
  }

  /**
   * 跟牌策略
   * @param {Object} player 当前AI玩家
   * @param {string} currentRank 当前点数
   * @returns {Object} { cardIndices: number[], claimedRank: string }
   */
  static followPlayStrategy(player, currentRank) {
    // 找出当前点数的真牌(普通牌+万能牌)
    const trueCards = player.hand
      .map((c, i) => ({ card: c, index: i }))
      .filter(({ card }) => card.rank === currentRank || card.rank === 'JOKER')

    // 如果有真牌，出所有真牌(最多3张)
    if (trueCards.length > 0) {
      const cardsToPlay = trueCards.slice(0, 3)
      return {
        cardIndices: cardsToPlay.map(({ index }) => index),
        claimedRank: currentRank
      }
    }

    // 没有真牌，选择手牌中数量最多的其他点数
    const rankCount = {}
    const normalCards = player.hand.filter(c => c.rank !== 'JOKER')

    for (const card of normalCards) {
      rankCount[card.rank] = (rankCount[card.rank] || 0) + 1
    }

    let maxCount = 0
    let bestRank = null

    for (const [rank, count] of Object.entries(rankCount)) {
      if (count > maxCount) {
        maxCount = count
        bestRank = rank
      }
    }

    // 出1-2张该点数的牌(降低被质疑风险)
    if (bestRank) {
      const cardsOfRank = player.hand
        .map((c, i) => ({ card: c, index: i }))
        .filter(({ card }) => card.rank === bestRank)
        .slice(0, 1 + Math.floor(Math.random() * 2)) // 1-2张

      return {
        cardIndices: cardsOfRank.map(({ index }) => index),
        claimedRank: currentRank
      }
    }

    // 如果全是万能牌，出1张万能牌
    const jokerIndex = player.hand.findIndex(c => c.rank === 'JOKER')
    if (jokerIndex !== -1) {
      return {
        cardIndices: [jokerIndex],
        claimedRank: currentRank
      }
    }

    // 兜底：随机出1张
    return {
      cardIndices: [0],
      claimedRank: currentRank
    }
  }
}

export default BluffAI

--- src/utils/Card.js ---
import { Suit, SUIT_PRIORITY, SUIT_NAMES, RANK_PRIORITY, RANK_NAMES } from './constants.js'

/**
 * 扑克牌类
 * 表示一张扑克牌
 */
class Card {
  /**
   * @param {string} rank 点数 (2-10, J, Q, K, A)
   * @param {string} suit 花色
   */
  constructor(rank, suit) {
    this.rank = rank
    this.suit = suit
  }

  /**
   * 获取牌的点数优先级
   * @returns {number}
   */
  get rankValue() {
    return RANK_PRIORITY[this.rank] || 0
  }

  /**
   * 获取牌的花色优先级
   * @returns {number}
   */
  get suitValue() {
    return SUIT_PRIORITY[this.suit] || 0
  }

  /**
   * 获取牌的显示名称
   * @returns {string}
   */
  get displayName() {
    return RANK_NAMES[this.rank] + ' ' + SUIT_NAMES[this.suit]
  }

  /**
   * 获取牌的颜色（红或黑）
   * @returns {string}
   */
  get color() {
    return (this.suit === Suit.HEARTS || this.suit === Suit.DIAMONDS) ? 'red' : 'black'
  }

  /**
   * 比较两张牌的大小
   * @param {Card} other 另一张牌
   * @returns {number} 1:这张牌大, -1:另一张牌大, 0:相同
   */
  compareTo(other) {
    if (this.rankValue !== other.rankValue) {
      return this.rankValue > other.rankValue ? 1 : -1
    }
    if (this.suitValue !== other.suitValue) {
      return this.suitValue > other.suitValue ? 1 : -1
    }
    return 0
  }

  /**
   * 判断是否与另一张牌点数相同
   * @param {Card} other 另一张牌
   * @returns {boolean}
   */
  hasSameRank(other) {
    return this.rank === other.rank
  }

  /**
   * 判断是否与另一张牌花色相同
   * @param {Card} other 另一张牌
   * @returns {boolean}
   */
  hasSameSuit(other) {
    return this.suit === other.suit
  }

  /**
   * 创建牌的副本
   * @returns {Card}
   */
  clone() {
    return new Card(this.rank, this.suit)
  }

  /**
   * 转换为可JSON序列化的对象
   * @returns {Object}
   */
  toJSON() {
    return {
      rank: this.rank,
      suit: this.suit,
      color: this.color,
      displayName: this.displayName,
      rankValue: this.rankValue,
      suitValue: this.suitValue
    }
  }

  /**
   * 从JSON对象创建Card实例
   * @param {Object} json 
   * @returns {Card}
   */
  static fromJSON(json) {
    const card = new Card(json.rank, json.suit)
    return card
  }
}

export default Card

--- src/utils/constants.js ---
/**
 * 扑克牌花色枚举
 */
const Suit = {
  SPADES: 'spades',     // 黑桃
  HEARTS: 'hearts',     // 红桃
  CLUBS: 'clubs',       // 梅花
  DIAMONDS: 'diamonds', // 方片
  JOKER: 'joker'        // 大小王
}

/**
 * 花色优先级（从大到小）
 */
const SUIT_PRIORITY = {
  [Suit.SPADES]: 4,
  [Suit.HEARTS]: 3,
  [Suit.CLUBS]: 2,
  [Suit.DIAMONDS]: 1,
  [Suit.JOKER]: 0
}

/**
 * 花色中文名称
 */
const SUIT_NAMES = {
  [Suit.SPADES]: '♠',
  [Suit.HEARTS]: '♥',
  [Suit.CLUBS]: '♣',
  [Suit.DIAMONDS]: '♦',
  [Suit.JOKER]: 'Joker'
}

/**
 * 点数优先级（从大到小）
 */
const RANK_PRIORITY = {
  'A': 14,
  'K': 13,
  'Q': 12,
  'J': 11,
  '10': 10,
  '9': 9,
  '8': 8,
  '7': 7,
  '6': 6,
  '5': 5,
  '4': 4,
  '3': 3,
  '2': 2,
  'JOKER': 15  // 大小王优先级最高
}

/**
 * 点数中文名称
 */
const RANK_NAMES = {
  'A': 'A',
  'K': 'K',
  'Q': 'Q',
  'J': 'J',
  '10': '10',
  '9': '9',
  '8': '8',
  '7': '7',
  '6': '6',
  '5': '5',
  '4': '4',
  '3': '3',
  '2': '2',
  'JOKER': 'Joker'
}

export {
  Suit,
  SUIT_PRIORITY,
  SUIT_NAMES,
  RANK_PRIORITY,
  RANK_NAMES
}

--- src/utils/Deck.js ---
import Card from './Card.js'
import { Suit } from './constants.js'

/**
 * 牌堆类
 * 管理一副扑克牌（包含大小王）
 */
class Deck {
  constructor() {
    this.cards = []
    this.discardedJokers = 0
    this.reset()
  }

  /**
   * 重置牌堆为标准54张牌（含大小王）
   */
  reset() {
    this.cards = []
    this.discardedJokers = 0
    const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    const suits = [Suit.SPADES, Suit.HEARTS, Suit.CLUBS, Suit.DIAMONDS]
    
    for (const suit of suits) {
      for (const rank of ranks) {
        this.cards.push(new Card(rank, suit))
      }
    }
    
    this.cards.push(new Card('JOKER', Suit.JOKER))
    this.cards.push(new Card('JOKER', Suit.JOKER))
  }

  /**
   * 洗牌（Fisher-Yates算法）
   */
  shuffle() {
    for (let i = this.cards.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]]
    }
  }

  /**
   * 发一张牌（跳过大小王）
   * @returns {Card|null} 如果牌堆为空则返回null
   */
  draw() {
    while (this.cards.length > 0) {
      const card = this.cards.pop()
      if (card && card.rank === 'JOKER') {
        this.discardedJokers++
        continue
      }
      return card || null
    }
    return null
  }

  /**
   * 发指定数量的牌（跳过大小王）
   * @param {number} count 数量
   * @returns {Card[]}
   */
  drawMultiple(count) {
    const drawn = []
    for (let i = 0; i < count; i++) {
      const card = this.draw()
      if (card) {
        drawn.push(card)
      }
    }
    return drawn
  }

  /**
   * 获取牌堆剩余数量
   * @returns {number}
   */
  get remaining() {
    return this.cards.length
  }

  /**
   * 判断牌堆是否为空
   * @returns {boolean}
   */
  get isEmpty() {
    return this.cards.length === 0
  }

  /**
   * 清空牌堆
   */
  clear() {
    this.cards = []
  }

  /**
   * 创建牌的副本
   * @returns {Card[]}
   */
  getAllCards() {
    return this.cards.map(card => card.clone())
  }
}

export default Deck

--- src/utils/deviceDetector.js ---
const deviceDetector = {
  isMobile() {
    if (typeof window === 'undefined') return false
    
    const userAgent = navigator.userAgent || navigator.vendor || window.opera
    
    const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile|tablet|kindle|silk|playbook|bb10|meego/i
    
    if (mobileRegex.test(userAgent.toLowerCase())) {
      return true
    }
    
    if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform)) {
      return true
    }
    
    return window.innerWidth <= 768
  },

  isTablet() {
    if (typeof window === 'undefined') return false
    
    const userAgent = navigator.userAgent || navigator.vendor || window.opera
    
    const tabletRegex = /ipad|android(?!.*mobile)|tablet|playbook|silk/i
    
    if (tabletRegex.test(userAgent.toLowerCase())) {
      return true
    }
    
    if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform)) {
      return true
    }
    
    return window.innerWidth > 768 && window.innerWidth <= 1024
  },

  isDesktop() {
    return !this.isMobile() && !this.isTablet()
  },

  getDeviceType() {
    if (this.isTablet()) return 'tablet'
    if (this.isMobile()) return 'mobile'
    return 'desktop'
  },

  getOS() {
    if (typeof window === 'undefined') return 'unknown'
    
    const userAgent = navigator.userAgent || navigator.vendor || window.opera
    
    if (/android/i.test(userAgent)) return 'android'
    if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) return 'ios'
    if (/Win/.test(userAgent)) return 'windows'
    if (/Mac/.test(userAgent)) return 'macos'
    if (/Linux/.test(userAgent)) return 'linux'
    
    return 'unknown'
  },

  getBrowser() {
    if (typeof window === 'undefined') return 'unknown'
    
    const userAgent = navigator.userAgent
    
    if (/chrome|chromium|crios/i.test(userAgent)) return 'chrome'
    if (/firefox|fxios/i.test(userAgent)) return 'firefox'
    if (/safari/i.test(userAgent) && !/chrome|chromium|crios/i.test(userAgent)) return 'safari'
    if (/edg/i.test(userAgent)) return 'edge'
    if (/opera|opr/i.test(userAgent)) return 'opera'
    
    return 'unknown'
  },

  supportsTouch() {
    if (typeof window === 'undefined') return false
    return 'ontouchstart' in window || 
           navigator.maxTouchPoints > 0 || 
           navigator.msMaxTouchPoints > 0
  },

  getScreenInfo() {
    if (typeof window === 'undefined') {
      return { width: 0, height: 0, pixelRatio: 1 }
    }
    
    return {
      width: window.innerWidth,
      height: window.innerHeight,
      pixelRatio: window.devicePixelRatio || 1
    }
  },

  isLandscape() {
    if (typeof window === 'undefined') return false
    return window.innerWidth > window.innerHeight
  },

  isPortrait() {
    if (typeof window === 'undefined') return false
    return window.innerWidth <= window.innerHeight
  },

  onResize(callback) {
    if (typeof window === 'undefined') return () => {}
    
    const handler = () => callback(this.getDeviceType(), this.getScreenInfo())
    window.addEventListener('resize', handler)
    return () => window.removeEventListener('resize', handler)
  },

  onOrientationChange(callback) {
    if (typeof window === 'undefined') return () => {}
    
    const handler = () => callback(this.isLandscape() ? 'landscape' : 'portrait')
    
    window.addEventListener('orientationchange', handler)
    window.addEventListener('resize', handler)
    
    return () => {
      window.removeEventListener('orientationchange', handler)
      window.removeEventListener('resize', handler)
    }
  }
}

export default deviceDetector

--- src/utils/marbleGame/AIPlayer.js ---
import * as THREE from 'three'

export class AIPlayer {
  constructor(gameState, physicsManager) {
    this.gameState = gameState
    this.physicsManager = physicsManager
    this.thinkingTime = 1500
    this.accuracy = 0.7
    this.powerVariance = 0.15
  }

  async makeMove() {
    const player = this.gameState.players[this.gameState.currentPlayer]
    if (!player) return null

    this.gameState.isAIThinking = true
    
    await this.delay(this.thinkingTime)

    const targetHole = this.getTargetHole(player)
    if (!targetHole) {
      this.gameState.isAIThinking = false
      return null
    }

    const ballPos = this.physicsManager.getBallPosition(player.id)
    if (!ballPos) {
      this.gameState.isAIThinking = false
      return null
    }

    const shot = this.calculateShot(ballPos, targetHole)
    
    this.gameState.isAIThinking = false
    return shot
  }

  getTargetHole(player) {
    const nextHoleOrder = player.holesOccupied.length + 1
    return this.gameState.holes.find(h => h.order === nextHoleOrder)
  }

  calculateShot(ballPos, targetHole) {
    const targetPos = new THREE.Vector3(targetHole.x, 0, targetHole.z)
    const direction = new THREE.Vector3().subVectors(targetPos, ballPos)
    direction.y = 0
    
    const distance = direction.length()
    direction.normalize()

    const idealPower = this.calculateIdealPower(distance)
    
    const accuracyFactor = 0.5 + Math.random() * this.accuracy
    const powerVariation = 1 + (Math.random() - 0.5) * this.powerVariance * 2
    
    const angleOffset = (Math.random() - 0.5) * (1 - this.accuracy) * 0.3
    
    direction.x = direction.x * Math.cos(angleOffset) - direction.z * Math.sin(angleOffset)
    direction.z = direction.x * Math.sin(angleOffset) + direction.z * Math.cos(angleOffset)
    direction.normalize()

    const finalPower = idealPower * powerVariation * accuracyFactor

    return {
      x: direction.x * finalPower,
      y: 0,
      z: direction.z * finalPower,
      magnitude: finalPower
    }
  }

  calculateIdealPower(distance) {
    const frictionFactor = 0.8
    const basePower = distance * 1.5
    return basePower / frictionFactor
  }

  shouldAttack() {
    const player = this.gameState.players[this.gameState.currentPlayer]
    if (player.status !== 'HUNTER') return false

    const targets = this.gameState.players.filter(p => 
      p.id !== player.id && 
      p.status !== 'HUNTER' && 
      !p.finished
    )

    if (targets.length === 0) return false

    const myProgress = player.holesOccupied.length
    const maxOpponentProgress = Math.max(...targets.map(t => t.holesOccupied.length))
    
    return maxOpponentProgress >= myProgress - 1 && Math.random() > 0.3
  }

  async makeAttackMove() {
    const player = this.gameState.players[this.gameState.currentPlayer]
    const targets = this.gameState.players.filter(p => 
      p.id !== player.id && 
      p.status !== 'HUNTER' && 
      !p.finished
    )

    if (targets.length === 0) return null

    this.gameState.isAIThinking = true
    await this.delay(this.thinkingTime)

    const target = targets[Math.floor(Math.random() * targets.length)]
    const ballPos = this.physicsManager.getBallPosition(player.id)
    const targetBallPos = this.physicsManager.getBallPosition(target.id)

    if (!ballPos || !targetBallPos) {
      this.gameState.isAIThinking = false
      return null
    }

    const direction = new THREE.Vector3().subVectors(targetBallPos, ballPos)
    direction.y = 0
    const distance = direction.length()
    direction.normalize()

    const power = Math.min(distance * 2, 15)
    
    const angleOffset = (Math.random() - 0.5) * 0.2
    direction.x = direction.x * Math.cos(angleOffset) - direction.z * Math.sin(angleOffset)
    direction.z = direction.x * Math.sin(angleOffset) + direction.z * Math.cos(angleOffset)
    direction.normalize()

    this.gameState.isAIThinking = false

    return {
      x: direction.x * power,
      y: 0,
      z: direction.z * power,
      magnitude: power,
      isAttack: true,
      targetId: target.id
    }
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  setDifficulty(level) {
    switch (level) {
      case 'easy':
        this.accuracy = 0.5
        this.powerVariance = 0.25
        this.thinkingTime = 1000
        break
      case 'medium':
        this.accuracy = 0.7
        this.powerVariance = 0.15
        this.thinkingTime = 1500
        break
      case 'hard':
        this.accuracy = 0.9
        this.powerVariance = 0.08
        this.thinkingTime = 2000
        break
      default:
        this.accuracy = 0.7
        this.powerVariance = 0.15
        this.thinkingTime = 1500
    }
  }
}

--- src/utils/marbleGame/GameState.js ---
import { reactive } from 'vue'

export const GamePhase = {
  MENU: 'MENU',
  QUALIFYING: 'QUALIFYING',
  PLAYING: 'PLAYING',
  GAMEOVER: 'GAMEOVER'
}

export const TurnPhase = {
  AIMING: 'AIMING',
  MOVING: 'MOVING',
  RESOLVING: 'RESOLVING'
}

export const PlayerStatus = {
  NORMAL: 'NORMAL',
  HUNTER: 'HUNTER',
  FINISHED: 'FINISHED'
}

export function createGameState() {
  return reactive({
    phase: GamePhase.MENU,
    turnPhase: TurnPhase.AIMING,
    currentPlayer: 0,
    round: 1,
    
    players: [
      { id: 0, name: '玩家', color: 0xe74c3c, status: PlayerStatus.NORMAL, holesOccupied: [], canAttack: false, finished: false },
      { id: 1, name: '电脑', color: 0x3498db, status: PlayerStatus.NORMAL, holesOccupied: [], canAttack: false, finished: false }
    ],
    
    holes: [
      { id: 0, x: 0, z: -5, radius: 1.2, occupiedBy: null, isFinish: false, order: 1 },
      { id: 1, x: 0, z: -12, radius: 1.0, occupiedBy: null, isFinish: false, order: 2 },
      { id: 2, x: 0, z: -19, radius: 1.0, occupiedBy: null, isFinish: false, order: 3 },
      { id: 3, x: 0, z: -26, radius: 1.5, occupiedBy: null, isFinish: true, order: 4 }
    ],
    
    qualifyingResults: [],
    
    winner: null,
    
    message: '',
    messageType: 'info',
    
    isAIThinking: false
  })
}

export function initQualifying(state) {
  state.phase = GamePhase.QUALIFYING
  state.turnPhase = TurnPhase.AIMING
  state.currentPlayer = 0
  state.qualifyingResults = []
  state.message = '资格赛：将球弹向第一个坑，距离最近者获得先手权'
  state.messageType = 'info'
  
  state.players.forEach(player => {
    player.status = PlayerStatus.NORMAL
    player.holesOccupied = []
    player.canAttack = false
    player.finished = false
  })
  
  state.holes.forEach(hole => {
    hole.occupiedBy = null
  })
}

export function startGame(state) {
  state.phase = GamePhase.PLAYING
  state.turnPhase = TurnPhase.AIMING
  state.round = 1
  state.winner = null
  state.message = '游戏开始！按顺序占领所有坑位'
  state.messageType = 'success'
}

export function endQualifying(state, results) {
  state.qualifyingResults = results.sort((a, b) => a.distance - b.distance)
  const firstPlayer = state.qualifyingResults[0].playerId
  state.currentPlayer = firstPlayer
  
  setTimeout(() => {
    startGame(state)
  }, 2000)
}

export function nextTurn(state) {
  const activePlayers = state.players.filter(p => !p.finished)
  if (activePlayers.length === 0) return
  
  let nextPlayerIndex = state.currentPlayer
  do {
    nextPlayerIndex = (nextPlayerIndex + 1) % state.players.length
  } while (state.players[nextPlayerIndex].finished)
  
  state.currentPlayer = nextPlayerIndex
  state.turnPhase = TurnPhase.AIMING
  
  const player = state.players[state.currentPlayer]
  state.message = `${player.name}的回合`
  state.messageType = 'info'
}

export function occupyHole(state, playerId, holeId) {
  const player = state.players[playerId]
  const hole = state.holes.find(h => h.id === holeId)
  
  if (!hole || hole.occupiedBy !== null) return false
  
  const expectedHole = state.holes.find(h => h.order === player.holesOccupied.length + 1)
  if (hole.id !== expectedHole.id) {
    state.message = `必须先占领第${expectedHole.order}个坑！`
    state.messageType = 'error'
    return false
  }
  
  hole.occupiedBy = playerId
  player.holesOccupied.push(holeId)
  
  if (hole.isFinish) {
    player.finished = true
    player.status = PlayerStatus.FINISHED
    state.winner = playerId
    state.phase = GamePhase.GAMEOVER
    state.message = `${player.name}获胜！`
    state.messageType = 'success'
    return true
  }
  
  if (player.holesOccupied.length === 3) {
    player.status = PlayerStatus.HUNTER
    player.canAttack = true
    state.message = `${player.name}进入猎人模式！可以攻击对手了`
    state.messageType = 'warning'
  } else {
    state.message = `${player.name}成功占领第${hole.order}个坑！`
    state.messageType = 'success'
  }
  
  return true
}

export function attackPlayer(state, attackerId, targetId) {
  const attacker = state.players[attackerId]
  const target = state.players[targetId]
  
  if (attacker.status !== PlayerStatus.HUNTER || target.status === PlayerStatus.HUNTER) {
    return false
  }
  
  state.message = `${attacker.name}攻击了${target.name}！目标回到起点`
  state.messageType = 'warning'
  
  return true
}

export function resetPlayerToStart(state, playerId) {
  const player = state.players[playerId]
  player.holesOccupied = []
  player.status = PlayerStatus.NORMAL
  player.canAttack = false
  
  state.holes.forEach(hole => {
    if (hole.occupiedBy === playerId) {
      hole.occupiedBy = null
    }
  })
  
  state.message = `${player.name}被攻击，回到起点！`
  state.messageType = 'error'
}

export function getCurrentTargetHole(state, playerId) {
  const player = state.players[playerId]
  const nextHoleOrder = player.holesOccupied.length + 1
  return state.holes.find(h => h.order === nextHoleOrder)
}

export function canPlayerAttack(state, playerId) {
  const player = state.players[playerId]
  return player.status === PlayerStatus.HUNTER && player.canAttack
}

export function getTargetablePlayers(state, attackerId) {
  return state.players.filter(p => 
    p.id !== attackerId && 
    p.status !== PlayerStatus.HUNTER && 
    !p.finished
  )
}

export function resetGame(state) {
  state.phase = GamePhase.MENU
  state.turnPhase = TurnPhase.AIMING
  state.currentPlayer = 0
  state.round = 1
  state.winner = null
  state.qualifyingResults = []
  state.message = ''
  state.isAIThinking = false
  
  state.players.forEach(player => {
    player.status = PlayerStatus.NORMAL
    player.holesOccupied = []
    player.canAttack = false
    player.finished = false
  })
  
  state.holes.forEach(hole => {
    hole.occupiedBy = null
  })
}

--- src/utils/marbleGame/index.js ---
export { SceneManager } from './SceneManager.js'
export { PhysicsManager } from './PhysicsManager.js'
export { InputManager } from './InputManager.js'
export { AIPlayer } from './AIPlayer.js'
export { 
  createGameState, 
  GamePhase, 
  TurnPhase, 
  PlayerStatus,
  initQualifying,
  startGame,
  endQualifying,
  nextTurn,
  occupyHole,
  attackPlayer,
  resetPlayerToStart,
  getCurrentTargetHole,
  canPlayerAttack,
  getTargetablePlayers,
  resetGame
} from './GameState.js'

--- src/utils/marbleGame/InputManager.js ---
import * as THREE from 'three'

export class InputManager {
  constructor(container, camera, scene) {
    this.container = container
    this.camera = camera
    this.scene = scene
    
    this.raycaster = new THREE.Raycaster()
    this.mouse = new THREE.Vector2()
    this.isDragging = false
    this.dragStart = null
    this.dragCurrent = null
    this.selectedBall = null
    
    this.maxDragDistance = 150
    this.forceMultiplier = 0.15
    
    this.onDragStart = null
    this.onDragMove = null
    this.onDragEnd = null
    this.onBallSelect = null
    
    this.init()
  }

  init() {
    this.container.addEventListener('pointerdown', this.handlePointerDown.bind(this))
    this.container.addEventListener('pointermove', this.handlePointerMove.bind(this))
    this.container.addEventListener('pointerup', this.handlePointerUp.bind(this))
    this.container.addEventListener('pointerleave', this.handlePointerUp.bind(this))
    
    this.container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false })
    this.container.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false })
    this.container.addEventListener('touchend', this.handleTouchEnd.bind(this))
    
    this.container.style.touchAction = 'none'
  }

  getPointerPosition(event) {
    const rect = this.container.getBoundingClientRect()
    const clientX = event.clientX || (event.touches && event.touches[0].clientX)
    const clientY = event.clientY || (event.touches && event.touches[0].clientY)
    
    return {
      x: ((clientX - rect.left) / rect.width) * 2 - 1,
      y: -((clientY - rect.top) / rect.height) * 2 + 1,
      screenX: clientX - rect.left,
      screenY: clientY - rect.top
    }
  }

  handlePointerDown(event) {
    event.preventDefault()
    const pos = this.getPointerPosition(event)
    this.mouse.set(pos.x, pos.y)
    
    this.raycaster.setFromCamera(this.mouse, this.camera)
    const intersects = this.raycaster.intersectObjects(this.scene.children, true)
    
    const ballIntersect = intersects.find(hit => 
      hit.object.geometry && hit.object.geometry.type === 'SphereGeometry'
    )
    
    if (ballIntersect) {
      this.isDragging = true
      this.dragStart = { x: pos.screenX, y: pos.screenY }
      this.dragCurrent = { x: pos.screenX, y: pos.screenY }
      this.selectedBall = ballIntersect.object
      
      if (this.onDragStart) {
        this.onDragStart(this.getBallPosition())
      }
    }
  }

  handlePointerMove(event) {
    if (!this.isDragging) return
    event.preventDefault()
    
    const pos = this.getPointerPosition(event)
    this.dragCurrent = { x: pos.screenX, y: pos.screenY }
    
    const dx = this.dragStart.x - this.dragCurrent.x
    const dy = this.dragStart.y - this.dragCurrent.y
    const distance = Math.sqrt(dx * dx + dy * dy)
    
    if (distance > this.maxDragDistance) {
      const scale = this.maxDragDistance / distance
      this.dragCurrent.x = this.dragStart.x - dx * scale
      this.dragCurrent.y = this.dragStart.y - dy * scale
    }
    
    if (this.onDragMove) {
      this.onDragMove(
        this.getBallPosition(),
        this.getAimDirection(),
        this.getForceRatio()
      )
    }
  }

  handlePointerUp(event) {
    if (!this.isDragging) return
    event.preventDefault()
    
    const force = this.getForce()
    
    if (this.onDragEnd) {
      this.onDragEnd(force)
    }
    
    this.isDragging = false
    this.dragStart = null
    this.dragCurrent = null
    this.selectedBall = null
  }

  handleTouchStart(event) {
    event.preventDefault()
    if (event.touches.length === 1) {
      this.handlePointerDown(event)
    }
  }

  handleTouchMove(event) {
    event.preventDefault()
    if (event.touches.length === 1) {
      this.handlePointerMove(event)
    }
  }

  handleTouchEnd(event) {
    event.preventDefault()
    this.handlePointerUp(event)
  }

  getBallPosition() {
    if (!this.selectedBall) return null
    return this.selectedBall.position.clone()
  }

  getAimDirection() {
    if (!this.dragStart || !this.dragCurrent) return new THREE.Vector3(0, 0, 0)
    
    const dx = this.dragStart.x - this.dragCurrent.x
    const dy = this.dragCurrent.y - this.dragStart.y
    
    const cameraDirection = new THREE.Vector3()
    this.camera.getWorldDirection(cameraDirection)
    cameraDirection.y = 0
    cameraDirection.normalize()
    
    const cameraRight = new THREE.Vector3()
    cameraRight.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0))
    
    const direction = new THREE.Vector3()
    direction.addScaledVector(cameraRight, dx * 0.01)
    direction.addScaledVector(cameraDirection, dy * 0.01)
    direction.normalize()
    
    return direction
  }

  getForceRatio() {
    if (!this.dragStart || !this.dragCurrent) return 0
    
    const dx = this.dragStart.x - this.dragCurrent.x
    const dy = this.dragStart.y - this.dragCurrent.y
    const distance = Math.sqrt(dx * dx + dy * dy)
    
    return Math.min(distance / this.maxDragDistance, 1)
  }

  getForce() {
    const ratio = this.getForceRatio()
    const direction = this.getAimDirection()
    const magnitude = ratio * this.maxDragDistance * this.forceMultiplier
    
    return {
      x: direction.x * magnitude,
      y: 0,
      z: direction.z * magnitude,
      magnitude: magnitude,
      ratio: ratio
    }
  }

  getAimEndPoint() {
    if (!this.selectedBall) return null
    
    const startPos = this.getBallPosition()
    const direction = this.getAimDirection()
    const ratio = this.getForceRatio()
    const distance = ratio * 5
    
    return new THREE.Vector3(
      startPos.x + direction.x * distance,
      startPos.y,
      startPos.z + direction.z * distance
    )
  }

  dispose() {
    this.container.removeEventListener('pointerdown', this.handlePointerDown)
    this.container.removeEventListener('pointermove', this.handlePointerMove)
    this.container.removeEventListener('pointerup', this.handlePointerUp)
    this.container.removeEventListener('pointerleave', this.handlePointerUp)
    this.container.removeEventListener('touchstart', this.handleTouchStart)
    this.container.removeEventListener('touchmove', this.handleTouchMove)
    this.container.removeEventListener('touchend', this.handleTouchEnd)
  }
}

--- src/utils/marbleGame/PhysicsManager.js ---
import * as CANNON from 'cannon-es'

export class PhysicsManager {
  constructor() {
    this.world = null
    this.bodies = {}
    this.materials = {}
    this.contactMaterials = {}
    this.triggers = []
    this.collisionListeners = []
    
    this.init()
  }

  init() {
    this.world = new CANNON.World()
    this.world.gravity.set(0, -9.82, 0)
    this.world.broadphase = new CANNON.SAPBroadphase(this.world)
    this.world.allowSleep = true
    this.world.solver.iterations = 10

    this.initMaterials()
  }

  initMaterials() {
    const groundMat = new CANNON.Material('ground')
    const ballMat = new CANNON.Material('ball')
    const holeMat = new CANNON.Material('hole')

    this.materials.ground = groundMat
    this.materials.ball = ballMat
    this.materials.hole = holeMat

    const groundBallContact = new CANNON.ContactMaterial(groundMat, ballMat, {
      friction: 0.8,
      restitution: 0.1
    })

    const ballBallContact = new CANNON.ContactMaterial(ballMat, ballMat, {
      friction: 0.3,
      restitution: 0.7
    })

    const holeBallContact = new CANNON.ContactMaterial(holeMat, ballMat, {
      friction: 0.9,
      restitution: 0.05
    })

    this.world.addContactMaterial(groundBallContact)
    this.world.addContactMaterial(ballBallContact)
    this.world.addContactMaterial(holeBallContact)

    this.contactMaterials.groundBall = groundBallContact
    this.contactMaterials.ballBall = ballBallContact
    this.contactMaterials.holeBall = holeBallContact
  }

  createGround(width, depth, heightData = null) {
    let shape
    
    if (heightData) {
      shape = new CANNON.Heightfield(heightData, {
        elementSize: width / (heightData[0].length - 1)
      })
    } else {
      shape = new CANNON.Box(new CANNON.Vec3(width / 2, 0.1, depth / 2))
    }

    const body = new CANNON.Body({
      mass: 0,
      material: this.materials.ground,
      type: CANNON.Body.STATIC
    })

    if (heightData) {
      body.addShape(shape)
      body.position.set(-width / 2, 0, -depth / 2)
      body.quaternion.setFromEuler(-Math.PI / 2, 0, 0)
    } else {
      body.addShape(shape)
      body.position.set(0, -0.1, 0)
    }

    this.world.addBody(body)
    this.bodies.ground = body
    return body
  }

  createBall(radius, position, playerId, color) {
    const shape = new CANNON.Sphere(radius)
    const body = new CANNON.Body({
      mass: 0.5,
      material: this.materials.ball,
      shape: shape,
      linearDamping: 0.3,
      angularDamping: 0.3
    })

    body.position.set(position.x, position.y, position.z)
    body.playerId = playerId
    body.color = color
    body.radius = radius
    body.isInHole = false
    body.currentHole = null

    this.world.addBody(body)
    
    if (!this.bodies.balls) this.bodies.balls = []
    this.bodies.balls.push(body)

    body.addEventListener('collide', (e) => {
      this.handleCollision(body, e)
    })

    return body
  }

  createHoleTrigger(x, z, radius, holeId, isFinish = false) {
    const shape = new CANNON.Cylinder(radius, radius, 1, 16)
    const body = new CANNON.Body({
      mass: 0,
      material: this.materials.hole,
      type: CANNON.Body.STATIC,
      isTrigger: true
    })

    body.addShape(shape)
    body.position.set(x, 0, z)
    body.holeId = holeId
    body.isFinish = isFinish

    this.world.addBody(body)
    
    if (!this.bodies.holes) this.bodies.holes = []
    this.bodies.holes.push(body)

    this.triggers.push({
      body: body,
      type: 'hole',
      holeId: holeId,
      isFinish: isFinish
    })

    return body
  }

  handleCollision(body, event) {
    const contactBody = event.body
    
    if (contactBody.isTrigger && contactBody.holeId !== undefined) {
      this.checkHoleEntry(body, contactBody)
    }

    this.collisionListeners.forEach(listener => {
      listener(body, contactBody, event)
    })
  }

  checkHoleEntry(ballBody, holeBody) {
    const velocity = ballBody.velocity.length()
    
    if (velocity < 1.5 && !ballBody.isInHole) {
      const distance = ballBody.position.distanceTo(holeBody.position)
      const threshold = holeBody.shapes[0].radius * 0.8

      if (distance < threshold) {
        ballBody.isInHole = true
        ballBody.currentHole = holeBody.holeId
        
        ballBody.velocity.set(0, 0, 0)
        ballBody.angularVelocity.set(0, 0, 0)
        
        ballBody.position.x = holeBody.position.x
        ballBody.position.z = holeBody.position.z
        ballBody.position.y = 0.3

        if (this.onBallEnterHole) {
          this.onBallEnterHole(ballBody.playerId, holeBody.holeId, holeBody.isFinish)
        }
      }
    }
  }

  resetBallPosition(playerId, position) {
    const ball = this.bodies.balls.find(b => b.playerId === playerId)
    if (ball) {
      ball.position.set(position.x, position.y, position.z)
      ball.velocity.set(0, 0, 0)
      ball.angularVelocity.set(0, 0, 0)
      ball.isInHole = false
      ball.currentHole = null
      ball.wakeUp()
    }
  }

  applyImpulse(playerId, impulse) {
    const ball = this.bodies.balls.find(b => b.playerId === playerId)
    if (ball && !ball.isInHole) {
      ball.applyImpulse(
        new CANNON.Vec3(impulse.x, impulse.y, impulse.z),
        ball.position
      )
      ball.wakeUp()
    }
  }

  getBallPosition(playerId) {
    const ball = this.bodies.balls.find(b => b.playerId === playerId)
    return ball ? ball.position : null
  }

  getBallVelocity(playerId) {
    const ball = this.bodies.balls.find(b => b.playerId === playerId)
    return ball ? ball.velocity.length() : 0
  }

  isBallStopped(playerId, threshold = 0.1) {
    const ball = this.bodies.balls.find(b => b.playerId === playerId)
    if (!ball) return false
    return ball.velocity.length() < threshold && ball.angularVelocity.length() < threshold
  }

  addCollisionListener(callback) {
    this.collisionListeners.push(callback)
  }

  removeCollisionListener(callback) {
    const index = this.collisionListeners.indexOf(callback)
    if (index > -1) {
      this.collisionListeners.splice(index, 1)
    }
  }

  setBallInHole(playerId, inHole, holeId = null) {
    const ball = this.bodies.balls.find(b => b.playerId === playerId)
    if (ball) {
      ball.isInHole = inHole
      ball.currentHole = holeId
    }
  }

  step(dt) {
    this.world.step(1 / 60, dt, 3)
  }

  dispose() {
    Object.values(this.bodies).forEach(body => {
      if (Array.isArray(body)) {
        body.forEach(b => this.world.removeBody(b))
      } else {
        this.world.removeBody(body)
      }
    })
    this.bodies = {}
    this.triggers = []
    this.collisionListeners = []
  }
}

--- src/utils/marbleGame/SceneManager.js ---
import * as THREE from 'three'

export class SceneManager {
  constructor(container) {
    this.container = container
    this.scene = null
    this.camera = null
    this.renderer = null
    this.lights = {}
    this.meshes = {}
    this.materials = {}
    
    this.init()
  }

  init() {
    this.initScene()
    this.initCamera()
    this.initRenderer()
    this.initLights()
    this.initMaterials()
    this.handleResize()
  }

  initScene() {
    this.scene = new THREE.Scene()
    this.scene.background = new THREE.Color(0x87CEEB)
    this.scene.fog = new THREE.Fog(0x87CEEB, 50, 150)
    
    // 添加辅助网格 - 使用亮色让调试更明显
    const gridHelper = new THREE.GridHelper(50, 50, 0x000000, 0x444444)
    gridHelper.position.y = 0.01
    this.scene.add(gridHelper)
    
    // 添加测试立方体
    const testGeo = new THREE.BoxGeometry(2, 2, 2)
    const testMat = new THREE.MeshBasicMaterial({ color: 0xff0000 })
    const testCube = new THREE.Mesh(testGeo, testMat)
    testCube.position.set(0, 2, 0)
    this.scene.add(testCube)
    console.log('测试立方体添加到场景')
  }

  initCamera() {
    const width = this.container.clientWidth || 800
    const height = this.container.clientHeight || 600
    const aspect = width / height
    this.camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 200)
    this.camera.position.set(0, 20, 25)
    this.camera.lookAt(0, 0, -10)
  }

  initRenderer() {
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: false,
      powerPreference: 'high-performance'
    })
    const width = this.container.clientWidth || 800
    const height = this.container.clientHeight || 600
    this.renderer.setSize(width, height)
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    this.renderer.shadowMap.enabled = true
    this.renderer.shadowMap.type = THREE.PCFShadowMap
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping
    this.renderer.toneMappingExposure = 1.2
    this.container.appendChild(this.renderer.domElement)
  }

  initLights() {
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6)
    this.scene.add(ambientLight)
    this.lights.ambient = ambientLight

    const dirLight = new THREE.DirectionalLight(0xfffff0, 1.5)
    dirLight.position.set(15, 25, 10)
    dirLight.castShadow = true
    dirLight.shadow.mapSize.width = 2048
    dirLight.shadow.mapSize.height = 2048
    dirLight.shadow.camera.near = 0.5
    dirLight.shadow.camera.far = 60
    dirLight.shadow.camera.left = -25
    dirLight.shadow.camera.right = 25
    dirLight.shadow.camera.top = 25
    dirLight.shadow.camera.bottom = -25
    dirLight.shadow.bias = -0.0005
    this.scene.add(dirLight)
    this.lights.directional = dirLight

    const fillLight = new THREE.DirectionalLight(0xe6f3ff, 0.5)
    fillLight.position.set(-15, 15, -10)
    this.scene.add(fillLight)
    this.lights.fill = fillLight

    const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x8b7355, 0.4)
    this.scene.add(hemiLight)
    this.lights.hemi = hemiLight
  }

  initMaterials() {
    const groundTexture = this.createNoiseTexture(512, '#8b7355', '#6b5344')
    const groundMaterial = new THREE.MeshStandardMaterial({
      map: groundTexture,
      roughness: 0.85,
      metalness: 0.0,
      color: 0xc4a574
    })
    this.materials.ground = groundMaterial

    const glassMaterial = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      metalness: 0.0,
      roughness: 0.1,
      transmission: 0.9,
      thickness: 1.0,
      ior: 1.5,
      clearcoat: 1.0,
      clearcoatRoughness: 0.1,
      envMapIntensity: 1.5
    })
    this.materials.glass = glassMaterial

    const holeMaterial = new THREE.MeshStandardMaterial({
      color: 0x5c4033,
      roughness: 1.0,
      metalness: 0.0
    })
    this.materials.hole = holeMaterial

    const aimLineMaterial = new THREE.LineBasicMaterial({
      color: 0xffd700,
      linewidth: 3,
      transparent: true,
      opacity: 0.8
    })
    this.materials.aimLine = aimLineMaterial
  }

  createNoiseTexture(size, color1, color2) {
    const canvas = document.createElement('canvas')
    canvas.width = size
    canvas.height = size
    const ctx = canvas.getContext('2d')

    ctx.fillStyle = color1
    ctx.fillRect(0, 0, size, size)

    for (let i = 0; i < 5000; i++) {
      const x = Math.random() * size
      const y = Math.random() * size
      const radius = Math.random() * 2 + 0.5
      ctx.beginPath()
      ctx.arc(x, y, radius, 0, Math.PI * 2)
      ctx.fillStyle = Math.random() > 0.5 ? color2 : color1
      ctx.globalAlpha = 0.1 + Math.random() * 0.2
      ctx.fill()
    }

    const texture = new THREE.CanvasTexture(canvas)
    texture.wrapS = THREE.RepeatWrapping
    texture.wrapT = THREE.RepeatWrapping
    texture.repeat.set(4, 4)
    return texture
  }

  createGround(width, depth, heightData = null) {
    const geometry = new THREE.PlaneGeometry(width, depth, 32, 32)
    
    if (heightData) {
      const positions = geometry.attributes.position
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i)
        const z = positions.getZ(i)
        const row = Math.floor((z + depth / 2) / depth * (heightData.length - 1))
        const col = Math.floor((x + width / 2) / width * (heightData[0].length - 1))
        if (heightData[row] && heightData[row][col] !== undefined) {
          positions.setY(i, heightData[row][col] * 0.5)
        }
      }
      geometry.computeVertexNormals()
    }

    const ground = new THREE.Mesh(geometry, this.materials.ground)
    ground.rotation.x = -Math.PI / 2
    ground.position.y = 0
    ground.receiveShadow = true
    this.scene.add(ground)
    this.meshes.ground = ground
    return ground
  }

  createHole(x, z, radius) {
    const geometry = new THREE.CylinderGeometry(radius, radius * 0.8, 0.2, 32)
    const hole = new THREE.Mesh(geometry, this.materials.hole)
    hole.position.set(x, 0.05, z)
    hole.receiveShadow = true
    this.scene.add(hole)
    return hole
  }

  createBall(radius, color, position) {
    const geometry = new THREE.SphereGeometry(radius, 32, 32)
    const material = this.materials.glass.clone()
    material.color = new THREE.Color(color)
    
    const ball = new THREE.Mesh(geometry, material)
    ball.position.copy(position)
    ball.castShadow = true
    ball.receiveShadow = true
    this.scene.add(ball)
    return ball
  }

  createAimLine(start, end) {
    const points = [start, end]
    const geometry = new THREE.BufferGeometry().setFromPoints(points)
    const line = new THREE.Line(geometry, this.materials.aimLine)
    this.scene.add(line)
    return line
  }

  removeAimLine(line) {
    if (line) {
      this.scene.remove(line)
      line.geometry.dispose()
    }
  }

  updateAimLine(line, start, end) {
    if (line) {
      const positions = line.geometry.attributes.position
      positions.setXYZ(0, start.x, start.y, start.z)
      positions.setXYZ(1, end.x, end.y, end.z)
      positions.needsUpdate = true
    }
  }

  createParticleEffect(position, color = 0xffd700, count = 20) {
    const particles = []
    const geometry = new THREE.BufferGeometry()
    const positions = new Float32Array(count * 3)
    const velocities = []

    for (let i = 0; i < count; i++) {
      positions[i * 3] = position.x
      positions[i * 3 + 1] = position.y
      positions[i * 3 + 2] = position.z
      
      velocities.push({
        x: (Math.random() - 0.5) * 0.3,
        y: Math.random() * 0.3,
        z: (Math.random() - 0.5) * 0.3
      })
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
    
    const material = new THREE.PointsMaterial({
      color: color,
      size: 0.15,
      transparent: true,
      opacity: 1.0,
      blending: THREE.AdditiveBlending
    })

    const particleSystem = new THREE.Points(geometry, material)
    this.scene.add(particleSystem)

    return { mesh: particleSystem, velocities, life: 1.0 }
  }

  updateParticles(particleSystem, deltaTime) {
    if (!particleSystem || particleSystem.life <= 0) return false

    const positions = particleSystem.mesh.geometry.attributes.position
    particleSystem.life -= deltaTime * 1.5

    for (let i = 0; i < particleSystem.velocities.length; i++) {
      const v = particleSystem.velocities[i]
      positions.setXYZ(
        i,
        positions.getX(i) + v.x * deltaTime,
        positions.getY(i) + v.y * deltaTime,
        positions.getZ(i) + v.z * deltaTime
      )
      v.y -= 0.5 * deltaTime
    }

    positions.needsUpdate = true
    particleSystem.mesh.material.opacity = particleSystem.life

    if (particleSystem.life <= 0) {
      this.scene.remove(particleSystem.mesh)
      particleSystem.mesh.geometry.dispose()
      particleSystem.mesh.material.dispose()
      return false
    }
    return true
  }

  setCameraTarget(target, offset = { x: 0, y: 12, z: 15 }) {
    const desiredPosition = new THREE.Vector3(
      target.x + offset.x,
      target.y + offset.y,
      target.z + offset.z
    )
    this.camera.position.lerp(desiredPosition, 0.05)
    this.camera.lookAt(target)
  }

  handleResize() {
    const resize = () => {
      if (!this.container || !this.camera || !this.renderer) return
      
      const width = this.container.clientWidth || 800
      const height = this.container.clientHeight || 600
      
      this.camera.aspect = width / height
      this.camera.updateProjectionMatrix()
      this.renderer.setSize(width, height)
    }

    window.addEventListener('resize', resize)
    setTimeout(resize, 100)
    resize()
  }

  render() {
    if (this.renderer && this.scene && this.camera) {
      this.renderer.render(this.scene, this.camera)
    }
  }

  dispose() {
    Object.values(this.meshes).forEach(mesh => {
      if (mesh.geometry) mesh.geometry.dispose()
      if (mesh.material) {
        if (Array.isArray(mesh.material)) {
          mesh.material.forEach(m => m.dispose())
        } else {
          mesh.material.dispose()
        }
      }
    })

    Object.values(this.materials).forEach(material => {
      material.dispose()
    })

    if (this.renderer) {
      this.renderer.dispose()
      this.container.removeChild(this.renderer.domElement)
    }
  }
}

--- src/utils/RuleEvaluator.js ---
/**
 * 游戏规则评估器
 * 负责所有牌型比较和计分逻辑
 */
class RuleEvaluator {
  /**
   * 比较单张牌大小
   * @param {import('./Card.js').default} card1 第一张牌
   * @param {import('./Card.js').default} card2 第二张牌
   * @returns {number} 1:card1大, -1:card2大, 0:平局
   */
  static compareSingleCard(card1, card2) {
    if (card1.rankValue !== card2.rankValue) {
      return card1.rankValue > card2.rankValue ? 1 : -1
    }
    if (card1.suitValue !== card2.suitValue) {
      return card1.suitValue > card2.suitValue ? 1 : -1
    }
    return 0
  }

  /**
   * 比较两组24点牌型大小
   * @param {import('./Card.js').default} c1 第一组第一张牌
   * @param {import('./Card.js').default} c2 第一组第二张牌
   * @param {import('./Card.js').default} c3 第二组第一张牌
   * @param {import('./Card.js').default} c4 第二组第二张牌
   * @returns {number} 1:第一组大, -1:第二组大, 0:平局
   */
  static compare24Points(c1, c2, c3, c4) {
    const getVal = card => (card.rank === 'A' ? 1 : card.rank === 'J' ? 11 : card.rank === 'Q' ? 12 : card.rank === 'K' ? 13 : parseInt(card.rank));
    const sum1 = getVal(c1) + getVal(c2);
    const sum2 = getVal(c3) + getVal(c4);
    const valid1 = sum1 <= 24, valid2 = sum2 <= 24;

    if (valid1 && !valid2) return 1;
    if (!valid1 && valid2) return -1;
    if (!valid1 && !valid2) return 0;

    if (sum1 !== sum2) return sum1 > sum2 ? 1 : -1;

    const max1 = [c1, c2].sort((a,b) => b.rankValue - a.rankValue || b.suitValue - a.suitValue)[0];
    const max2 = [c3, c4].sort((a,b) => b.rankValue - a.rankValue || b.suitValue - a.suitValue)[0];
    if (max1.rankValue !== max2.rankValue) return max1.rankValue > max2.rankValue ? 1 : -1;
    if (max1.suitValue !== max2.suitValue) return max1.suitValue > max2.suitValue ? 1 : -1;

    const min1 = sum1 - max1.rankValue, min2 = sum2 - max2.rankValue;
    if (min1 !== min2) return min1 > min2 ? 1 : -1;
    return 0;
  }

  /**
   * 获取三张牌的牌型
   * @param {import('./Card.js').default} card1 第一张牌
   * @param {import('./Card.js').default} card2 第二张牌
   * @param {import('./Card.js').default} card3 第三张牌
   * @returns {Object} 牌型对象
   */
  static getThreeCardType(card1, card2, card3) {
    const cards = [card1, card2, card3].sort((a, b) => b.rankValue - a.rankValue)
    const ranks = cards.map(c => c.rank)
    const suits = cards.map(c => c.suit)
    const rankValues = cards.map(c => c.rankValue)
    const suitValues = cards.map(c => c.suitValue)

    const isSameSuit = suits[0] === suits[1] && suits[1] === suits[2]
    const isSequential = this._isSequential(rankValues)
    const hasThreeOfAKind = ranks[0] === ranks[1] && ranks[1] === ranks[2]
    const hasPair = this._hasPair(ranks)

    if (hasThreeOfAKind) {
      return { type: 'triplet', rankValues, suitValues, mainRank: rankValues[0], cards }
    }
    if (isSameSuit && isSequential) {
      return { type: 'straight_flush', rankValues, suitValues, mainRank: rankValues[0], cards }
    }
    if (isSameSuit) {
      return { type: 'flush', rankValues, suitValues, mainRank: rankValues[0], cards }
    }
    if (isSequential) {
      return { type: 'straight', rankValues, suitValues, mainRank: rankValues[0], cards }
    }
    if (hasPair) {
      const pairInfo = this._getPairInfo(ranks, suitValues, cards)
      return { type: 'pair', rankValues, suitValues, mainRank: pairInfo.pairRank, kicker: pairInfo.kicker, kickerSuit: pairInfo.kickerSuit, pairSuit1: pairInfo.pairSuit1, pairSuit2: pairInfo.pairSuit2, cards }
    }
    return { type: 'high_card', rankValues, suitValues, mainRank: rankValues[0], cards }
  }

  /**
   * 判断点数是否连续
   * @param {number[]} rankValues 
   * @returns {boolean}
   */
  static _isSequential(rankValues) {
    const sorted = [...rankValues].sort((a, b) => b - a)
    if (sorted[0] === 14 && sorted[1] === 3 && sorted[2] === 2) {
      return true
    }
    return sorted[0] - sorted[1] === 1 && sorted[1] - sorted[2] === 1
  }

  /**
   * 判断是否有对子
   * @param {string[]} ranks 
   * @returns {boolean}
   */
  static _hasPair(ranks) {
    return ranks[0] === ranks[1] || ranks[1] === ranks[2]
  }

  /**
   * 获取对子信息
   * @param {string[]} ranks 点数字符串数组
   * @param {number[]} suitValues 花色值数组
   * @param {import('./Card.js').default[]} cards 排序后的牌数组
   * @returns {Object}
   */
  static _getPairInfo(ranks, suitValues, cards) {
    let pairRank, kicker, kickerSuit, pairSuit1, pairSuit2
    
    if (ranks[0] === ranks[1] && ranks[1] === ranks[2]) {
      pairRank = ranks[0].rankValue || parseInt(ranks[0])
      kicker = 0
      kickerSuit = 0
      pairSuit1 = suitValues[0]
      pairSuit2 = suitValues[1]
    } else if (ranks[0] === ranks[1]) {
      pairRank = ranks[0].rankValue || parseInt(ranks[0])
      kicker = ranks[2].rankValue || parseInt(ranks[2])
      kickerSuit = suitValues[2]
      pairSuit1 = suitValues[0]
      pairSuit2 = suitValues[1]
    } else {
      pairRank = ranks[1].rankValue || parseInt(ranks[1])
      kicker = ranks[0].rankValue || parseInt(ranks[0])
      kickerSuit = suitValues[0]
      pairSuit1 = suitValues[1]
      pairSuit2 = suitValues[2]
    }
    
    return { pairRank, kicker, kickerSuit, pairSuit1, pairSuit2 }
  }

  /**
   * 牌型优先级
   */
  static get TYPE_PRIORITY() {
    return {
      'triplet': 6,
      'straight_flush': 5,
      'flush': 4,
      'straight': 3,
      'pair': 2,
      'high_card': 1
    }
  }

  /**
   * 比较两组三张牌牌型大小（按规格说明书完整实现）
   * @param {import('./Card.js').default} card1a 第一组第一张牌
   * @param {import('./Card.js').default} card1b 第一组第二张牌
   * @param {import('./Card.js').default} card1c 第一组第三张牌
   * @param {import('./Card.js').default} card2a 第二组第一张牌
   * @param {import('./Card.js').default} card2b 第二组第二张牌
   * @param {import('./Card.js').default} card2c 第二组第三张牌
   * @returns {number} 1:第一组大, -1:第二组大, 0:平局
   */
  static compareThreeCards(card1a, card1b, card1c, card2a, card2b, card2c) {
    const type1 = this.getThreeCardType(card1a, card1b, card1c);
    const type2 = this.getThreeCardType(card2a, card2b, card2c);
    const priority1 = this.TYPE_PRIORITY[type1.type];
    const priority2 = this.TYPE_PRIORITY[type2.type];

    if (priority1 !== priority2) return priority1 > priority2 ? 1 : -1;

    switch (type1.type) {
      case 'triplet':
        if (type1.mainRank !== type2.mainRank) return type1.mainRank > type2.mainRank ? 1 : -1;
        return Math.max(...type1.suitValues) - Math.max(...type2.suitValues);

      case 'straight_flush':
      case 'straight':
      case 'flush':
      case 'high_card': {
        const sorted1 = type1.rankValues.sort((a,b)=>b-a);
        const sorted2 = type2.rankValues.sort((a,b)=>b-a);
        for (let i = 0; i < 3; i++) {
          if (sorted1[i] !== sorted2[i]) return sorted1[i] > sorted2[i] ? 1 : -1;
        }
        return Math.max(...type1.suitValues) - Math.max(...type2.suitValues);
      }

      case 'pair': {
        if (type1.mainRank !== type2.mainRank) return type1.mainRank > type2.mainRank ? 1 : -1;
        if (type1.kicker !== type2.kicker) return type1.kicker > type2.kicker ? 1 : -1;
        const maxPairSuit1 = Math.max(type1.pairSuit1, type1.pairSuit2);
        const maxPairSuit2 = Math.max(type2.pairSuit1, type2.pairSuit2);
        if (maxPairSuit1 !== maxPairSuit2) return maxPairSuit1 > maxPairSuit2 ? 1 : -1;
        return type1.kickerSuit - type2.kickerSuit;
      }
    }
    return 0;
  }

  /**
   * 计算玩家在某组的排名
   * @param {Object[]} playersGroups 玩家分组数据
   * @param {string} groupType 组类型: 'single', '24point', 'threecard'
   * @returns {Object[]} 排名结果
   */
  static calculateGroupRank(playersGroups, groupType) {
    const results = playersGroups.map((pg, index) => ({
      playerId: pg.playerId,
      cards: pg.cards,
      index: index
    }))

    results.sort((a, b) => {
      let result = 0
      if (groupType === 'single') {
        result = this.compareSingleCard(a.cards[0], b.cards[0])
      } else if (groupType === '24point') {
        result = this.compare24Points(a.cards[0], a.cards[1], b.cards[0], b.cards[1])
      } else if (groupType === 'threecard') {
        result = this.compareThreeCards(a.cards[0], a.cards[1], a.cards[2], b.cards[0], b.cards[1], b.cards[2])
      }
      return -result
    })

    const ranked = []
    for (let i = 0; i < results.length; i++) {
      let rank = i
      if (i > 0) {
        const prev = results[i - 1]
        const curr = results[i]
        let isTie = false
        if (groupType === 'single') {
          isTie = this.compareSingleCard(prev.cards[0], curr.cards[0]) === 0
        } else if (groupType === '24point') {
          isTie = this.compare24Points(prev.cards[0], prev.cards[1], curr.cards[0], curr.cards[1]) === 0
        } else if (groupType === 'threecard') {
          isTie = this.compareThreeCards(prev.cards[0], prev.cards[1], prev.cards[2], curr.cards[0], curr.cards[1], curr.cards[2]) === 0
        }
        if (isTie) {
          rank = ranked[i - 1].rank
        }
      }
      ranked.push({ playerId: results[i].playerId, rank })
    }

    return ranked
  }

  /**
   * 根据排名计算得分
   * @param {number} rank 排名（0-based）
   * @param {number} playerCount 玩家总数
   * @param {boolean} isDoubleScore 是否翻倍
   * @returns {number}
   */
  static calculateScore(rank, playerCount, isDoubleScore = false) {
    const baseScore = playerCount - 1 - rank
    return isDoubleScore ? baseScore * 2 : baseScore
  }

  /**
   * 计算单张牌强度分数（用于AI评估）
   * @param {import('./Card.js').default} card 
   * @returns {number}
   */
  static scoreSingle(card) {
    return card.rankValue * 10 + card.suitValue
  }

  /**
   * 计算24点牌强度分数（用于AI评估）
   * @param {import('./Card.js').default} c1 
   * @param {import('./Card.js').default} c2 
   * @returns {number}
   */
  static score24(c1, c2) {
    const get24PointValue = (card) => {
      if (card.rank === 'A') return 1
      if (card.rank === 'J') return 11
      if (card.rank === 'Q') return 12
      if (card.rank === 'K') return 13
      return parseInt(card.rank)
    }
    
    const sum = get24PointValue(c1) + get24PointValue(c2)
    if (sum > 24) return 0
    
    const val1 = get24PointValue(c1)
    const val2 = get24PointValue(c2)
    
    let maxCard, minCard
    if (val1 > val2) {
      maxCard = c1
      minCard = c2
    } else if (val2 > val1) {
      maxCard = c2
      minCard = c1
    } else {
      maxCard = c1.suitValue >= c2.suitValue ? c1 : c2
      minCard = c1.suitValue >= c2.suitValue ? c2 : c1
    }
    
    const maxVal = get24PointValue(maxCard)
    const minVal = get24PointValue(minCard)
    const maxSuit = maxCard.suitValue
    const minSuit = minCard.suitValue
    
    return sum * 10000 + maxVal * 1000 + maxSuit * 100 + minVal * 10 + minSuit
  }

  /**
   * 计算炸金花牌强度分数（用于AI评估）
   * @param {import('./Card.js').default} c1 
   * @param {import('./Card.js').default} c2 
   * @param {import('./Card.js').default} c3 
   * @returns {number}
   */
  static scorePoker(c1, c2, c3) {
    const type = this.getThreeCardType(c1, c2, c3)
    const priority = this.TYPE_PRIORITY[type.type]
    
    const sorted = [...type.rankValues].sort((a, b) => b - a)
    const maxSuit = Math.max(...type.suitValues)
    
    if (type.type === 'triplet') {
      return priority * 1000000 + type.mainRank * 1000 + maxSuit
    }
    
    if (type.type === 'straight_flush' || type.type === 'straight') {
      return priority * 1000000 + sorted[0] * 10000 + sorted[1] * 100 + sorted[2] + maxSuit
    }
    
    if (type.type === 'flush' || type.type === 'high_card') {
      return priority * 1000000 + sorted[0] * 10000 + sorted[1] * 100 + sorted[2] + maxSuit
    }
    
    if (type.type === 'pair') {
      const pairRank = type.mainRank
      const kicker = type.kicker
      const maxPairSuit = Math.max(type.pairSuit1, type.pairSuit2)
      return priority * 1000000 + pairRank * 10000 + kicker * 100 + maxPairSuit * 10 + type.kickerSuit
    }
    
    return priority * 1000000
  }
}

export default RuleEvaluator

--- src/utils/setCardRenderer.js ---
const COLOR_MAP = {
  red: '#e74c3c',
  green: '#27ae60',
  purple: '#8e44ad',
}

function drawOval(ctx, x, y, width, height) {
  ctx.beginPath()
  ctx.ellipse(
    x + width / 2,
    y + height / 2,
    width / 2 - 1,
    height / 2 - 1,
    0,
    0,
    Math.PI * 2,
  )
}

function drawSquare(ctx, x, y, width, height) {
  ctx.beginPath()
  ctx.rect(x + 1, y + 1, width - 2, height - 2)
}

function drawDiamond(ctx, x, y, width, height) {
  ctx.beginPath()
  ctx.moveTo(x + width / 2, y + 1)
  ctx.lineTo(x + width - 1, y + height / 2)
  ctx.lineTo(x + width / 2, y + height - 1)
  ctx.lineTo(x + 1, y + height / 2)
  ctx.closePath()
}

function drawShape(ctx, shape, x, y, width, height) {
  switch (shape) {
    case 'oval':
      drawOval(ctx, x, y, width, height)
      break
    case 'square':
      drawSquare(ctx, x, y, width, height)
      break
    case 'diamond':
      drawDiamond(ctx, x, y, width, height)
      break
    default:
      drawOval(ctx, x, y, width, height)
  }
}

function drawStripedFill(ctx, x, y, width, height, color) {
  ctx.save()
  ctx.clip()

  ctx.fillStyle = color
  ctx.fillRect(x, y, width, height)

  ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'
  ctx.lineWidth = 2.5

  const spacing = 5
  for (let i = -height; i < width + height; i += spacing) {
    ctx.beginPath()
    ctx.moveTo(x + i, y)
    ctx.lineTo(x + i + height, y + height)
    ctx.stroke()
  }

  ctx.restore()
}

export function drawCard(
  ctx,
  card,
  x,
  y,
  cardWidth,
  cardHeight,
  isSelected = false,
  isHint = false,
  isFoundSet = false,
) {
  const color = COLOR_MAP[card.color] || '#333'
  const { shape, shading, number } = card

  ctx.save()

  if (isSelected) {
    // 玩家选中：金色边框 + 内部光晕
    ctx.strokeStyle = '#c4a77d'
    ctx.lineWidth = 4
    ctx.fillStyle = 'rgba(196, 167, 125, 0.2)'
    ctx.beginPath()
    ctx.roundRect(x - 4, y - 4, cardWidth + 8, cardHeight + 8, 8)
    ctx.fill()
    ctx.stroke()
  } else if (isHint) {
    // 提示效果：橙色发光边框（与选中区分）
    ctx.strokeStyle = '#e89c3a'
    ctx.lineWidth = 3
    ctx.fillStyle = 'rgba(232, 156, 58, 0.15)'
    ctx.beginPath()
    ctx.roundRect(x - 3, y - 3, cardWidth + 6, cardHeight + 6, 6)
    ctx.fill()
    ctx.stroke()

    // 添加虚线边框效果
    ctx.strokeStyle = 'rgba(232, 156, 58, 0.6)'
    ctx.lineWidth = 2
    ctx.setLineDash([5, 3])
    ctx.beginPath()
    ctx.roundRect(x - 6, y - 6, cardWidth + 12, cardHeight + 12, 10)
    ctx.stroke()
    ctx.setLineDash([])
  } else if (isFoundSet) {
    ctx.strokeStyle = '#8b9a6d'
    ctx.lineWidth = 4
    ctx.fillStyle = 'rgba(139, 154, 109, 0.1)'
    ctx.beginPath()
    ctx.roundRect(x - 4, y - 4, cardWidth + 8, cardHeight + 8, 8)
    ctx.fill()
    ctx.stroke()

    ctx.fillStyle = 'rgba(139, 154, 109, 0.2)'
    ctx.beginPath()
    ctx.arc(
      x + cardWidth / 2,
      y + cardHeight / 2,
      Math.min(cardWidth, cardHeight) / 2,
      0,
      Math.PI * 2,
    )
    ctx.fill()
  }

  ctx.fillStyle = '#f5f0e6'
  ctx.strokeStyle = 'rgba(180, 170, 160, 0.3)'
  ctx.lineWidth = 1
  ctx.beginPath()
  ctx.roundRect(x, y, cardWidth, cardHeight, 6)
  ctx.fill()
  ctx.stroke()

  const shapeWidth = cardWidth * 0.7
  const shapeHeight = cardHeight * 0.18
  const spacing = cardHeight / (number + 1)

  for (let i = 0; i < number; i++) {
    const shapeY = y + spacing * (i + 1) - shapeHeight / 2
    const shapeX = x + (cardWidth - shapeWidth) / 2

    if (shading === 'solid') {
      ctx.fillStyle = color
      drawShape(ctx, shape, shapeX, shapeY, shapeWidth, shapeHeight)
      ctx.fill()
    } else if (shading === 'striped') {
      drawShape(ctx, shape, shapeX, shapeY, shapeWidth, shapeHeight)
      drawStripedFill(ctx, shapeX, shapeY, shapeWidth, shapeHeight, color)
    } else if (shading === 'open') {
      ctx.strokeStyle = color
      ctx.lineWidth = 3
      ctx.lineCap = 'round'
      ctx.lineJoin = 'round'
      drawShape(ctx, shape, shapeX, shapeY, shapeWidth, shapeHeight)
      ctx.stroke()
    }
  }

  ctx.restore()
}

export function drawCardBackground(
  ctx,
  x,
  y,
  width,
  height,
  isSelected = false,
) {
  ctx.save()

  if (isSelected) {
    ctx.fillStyle = 'rgba(142, 68, 173, 0.15)'
    ctx.strokeStyle = '#8e44ad'
    ctx.lineWidth = 3
  } else {
    ctx.fillStyle = 'white'
    ctx.strokeStyle = '#ccc'
    ctx.lineWidth = 1
  }

  ctx.beginPath()
  ctx.roundRect(x, y, width, height, 8)
  ctx.fill()
  ctx.stroke()

  ctx.restore()
}

export function drawScoreAnimation(ctx, canvasWidth, canvasHeight, scoreValue) {
  const centerX = canvasWidth / 2
  const centerY = 80

  ctx.save()

  ctx.font = 'bold 48px Arial'
  ctx.textAlign = 'center'
  ctx.textBaseline = 'middle'

  ctx.fillStyle = '#f1c40f'
  ctx.shadowColor = '#f39c12'
  ctx.shadowBlur = 20
  ctx.fillText(`+${scoreValue}`, centerX, centerY)

  ctx.restore()
}

--- vite.config.js ---
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  server: {
    port: 3000
  }
})

--- 说明书/吹牛皮游戏需求规格说明书.txt ---
吹牛皮扑克游戏 需求规格说明书（更新版）
1. 引言
1.1 目的
本文档旨在明确“吹牛皮扑克游戏”的功能性、非功能性及界面需求，为开发团队（包括前端开发、AI算法设计及测试人员）提供清晰、完整的设计依据。游戏为单人娱乐产品，玩家与三个电脑对手进行对战，采用GODOT框架实现。

1.2 范围
本项目是一个基于GODOT引擎开发的单人扑克游戏，玩家通过鼠标操作手牌，与电脑AI进行“吹牛皮”玩法对战。主要功能包括：游戏初始化、回合控制、手牌管理、出牌与质疑、AI决策、胜负判定及界面交互。

1.3 定义与缩写
吹牛皮：一种扑克游戏，玩家可虚报所出牌的点数，其他玩家可质疑。

点数：扑克牌的等级，包括A、2、3、4、5、6、7、8、9、10、J、Q、K，以及大小王（万能牌）。

万能牌：大小王，可当作任何点数使用。

牌堆：当前轮次中所有已打出但未被质疑的牌集合，细分为累积牌区和最新出牌区。

累积牌区：当前轮次中除最新一轮出牌外的所有牌（即之前的出牌）。

最新出牌区：上一家刚打出的牌（等待被质疑或跟牌）。

弃牌区：全部跳过时，牌堆中的牌进入弃牌区，这些牌永久退出游戏，不再属于任何玩家。

出牌权：当前轮到哪位玩家行动。

AI：人工智能，控制电脑玩家的行为。

1.4 参考资料
游戏玩法描述（用户提供）
GODOT

扑克通用规则

2. 总体描述
2.1 产品视角
“吹牛皮扑克游戏”是一款休闲益智类网页游戏，玩家通过浏览器即可开始对局。游戏界面简洁明了，突出手牌区域、牌堆状态及玩家信息。电脑对手的行为具备一定智能，能根据游戏局势做出合理决策，提供适中的挑战性。

2.2 用户特征
目标用户为熟悉或希望了解“吹牛皮”玩法的扑克爱好者，年龄不限，具备基本计算机操作能力。单人游戏模式适合碎片化时间娱乐。

2.3 假设与依赖
游戏运行环境为支持HTML5、CSS3及JavaScript的现代浏览器（如Chrome、Firefox、Edge）。

无需后端服务，所有游戏逻辑均在客户端运行。

屏幕分辨率至少为1024×768，以保证界面布局正常。

2.4 设计与实现约束
使用GODOT4.5 + GD SCRIPT进行开发。

AI策略需具备可调整性，便于后续难度分级。

3. 功能需求
3.1 游戏初始化
需求编号	需求描述
FR1.1	系统应能生成一副标准的54张扑克牌（包括大小王）。
FR1.2	系统应将牌随机打乱，并发给4名玩家（1人+3电脑），每人13张，剩余2张弃置不用。
FR1.3	系统应随机决定首位出牌玩家（可为人类或任意电脑）。
FR1.4	游戏初始状态：牌堆为空（累积牌区与最新出牌区均为空），无当前点数，首轮由首位玩家选择点数出牌。
3.2 回合控制
需求编号	需求描述
FR2.1	系统应维护当前轮到哪位玩家行动，并明确标识。
FR2.2	当轮到人类玩家时，界面应激活操作控件（出牌、质疑按钮及点数选择器），并允许点击手牌。
FR2.3	当轮到电脑玩家时，系统应自动调用AI决策模块，执行相应操作（出牌或质疑），并暂停人类操作。
FR2.4	每执行一次操作后，系统应更新牌堆、玩家手牌，并切换到下一玩家。
FR2.5	当某玩家手牌数为0时，游戏立即结束，宣布该玩家获胜。
3.3 出牌操作
需求编号	需求描述
FR3.1	若当前为某轮首次出牌（牌堆为空），出牌玩家必须选择一个点数（A~K），并打出至少1张手牌（可混入万能牌）。打出的牌直接放入最新出牌区。
FR3.2	若非首次出牌（已有当前点数），出牌玩家只能打出至少1张手牌，并宣称其为当前点数（不可更改点数）。打牌前，上一家的出牌（当前最新出牌区）将自动移入累积牌区，然后本次打出的牌放入最新出牌区。
FR3.3	出牌时，玩家从手牌中选中若干张，点击“出牌”按钮完成操作。
FR3.4	出牌后，所选牌从手牌移除，并按上述规则放入相应牌区，同时记录最后出牌玩家、出牌张数及宣称点数。
FR3.5	系统应禁止玩家在不合法情况下出牌（如未选牌、所选牌超出持有数等）。
3.4 质疑操作
需求编号	需求描述
FR4.1	当上一家出牌后（即最新出牌区有牌），当前玩家可选择"质疑"。
FR4.2	点击"质疑"后，系统翻开最新出牌区的所有牌，验证是否全部为宣称点数或万能牌。
FR4.3	若全部为真，质疑失败，质疑者收回整个牌堆（包括累积牌区和最新出牌区的所有牌），最后出牌的玩家获得下一轮的首发出牌权。
FR4.4	若存在假牌，质疑成功，上一家收回整个牌堆（包括累积牌区和最新出牌区的所有牌），质疑者获得下一轮的首发出牌权。
FR4.5	质疑结束后，牌堆清空（累积牌区和最新出牌区均清空），当前点数重置。

3.5 跳过与轮空规则
需求编号	需求描述
FR5.1	当上一家出牌后，当前玩家可选择"跳过"，即不质疑也不跟牌，轮到下一位玩家行动。
FR5.2	若连续所有玩家（包括人类和AI）都选择跳过，则形成"全部跳过"局面。
FR5.3	全部跳过处理：当一轮中除最后出牌者外的其他所有玩家都选择跳过时，最后出牌者自动获得下一轮的首发出牌权。
FR5.4	弃牌规则：全部跳过时，当前牌堆（累积牌区和最新出牌区的所有牌）进入弃牌区，不再属于任何玩家。
FR5.5	弃牌后状态：牌堆清空，当前点数重置，由最后出牌者选择新的点数开始新一轮。
3.6 电脑AI需求
需求编号	需求描述
FR6.1	AI应能根据自身手牌和当前局势决定是否质疑。质疑决策应基于概率模型，考虑上一家出牌数量、自身持有真牌数量等因素。
FR6.2	AI在跟牌时应尽量消耗手牌，优先出真牌（当前点数的普通牌或万能牌），若无真牌则出数量最多的其他点数牌，数量控制在1~2张以降低被质疑风险。
FR6.3	AI获得首发权时，应选择自己手中数量最多的普通点数（不含万能牌）作为新轮点数，并出掉该点数的所有普通牌（可混入万能牌），最多不超过3张。
FR6.4	AI决策过程应有随机性，避免行为完全可预测。
FR6.5	AI操作应在人类可见的延迟（如1秒）后执行，提升交互体验。
FR6.6	AI在决定是否跳过时，应考虑手牌中真牌数量、牌堆大小等因素。若手牌中无真牌且牌堆较大，AI应倾向于跳过而非吹牛。
4. 非功能需求
4.1 性能需求
需求编号	需求描述
NFR1.1	游戏初始化应在2秒内完成。
NFR1.2	玩家点击操作后，界面响应时间不超过0.5秒。
NFR1.3	AI决策时间应控制在1秒以内（不包括延迟）。
4.2 可用性需求
需求编号	需求描述
NFR2.1	界面应简洁清晰，手牌图标易于识别点数和花色。
NFR2.2	当前玩家、当前点数、牌堆张数等关键信息应在显著位置显示。
NFR2.3	所有操作按钮应有明确的标签和状态提示（如禁用原因）。
NFR2.4	游戏过程中应显示简要操作日志，帮助玩家了解历史行动。
4.3 可靠性需求
需求编号	需求描述
NFR3.1	游戏状态应持久保存在内存中，刷新页面将导致重新开始。
NFR3.2	任何非法操作（如未按规则选牌）应被阻止，并给出提示，不影响游戏状态。
4.4 兼容性需求
需求编号	需求描述
NFR4.1	游戏应兼容Chrome、Firefox、Edge、Safari的最新版本。
NFR4.2	界面应适配不同尺寸的桌面显示器，支持最小宽度1024px。
5. 界面需求
5.1 布局设计
顶部区域：显示游戏标题、当前轮次信息（当前点数、牌堆总张数）。

中部区域：显示其他三名电脑玩家的信息（名称、手牌张数、是否当前回合）。

底部区域：显示人类玩家的手牌（可横向滚动或缩小显示），以及操作按钮（出牌、质疑）和点数选择下拉框（仅在需要时出现）。

中央核心区域：显示牌堆，牌堆分为累积牌区和最新出牌区，两者并排放置或上下排列，并配有标签说明。

右侧边栏（可选）：显示操作日志。

5.2 牌堆视觉设计
需求编号	需求描述
UI5.2.1	累积牌区：展示当前轮次中除最新一轮出牌外的所有牌。牌以层叠方式摆放，每张牌只露出顶部约20%的区域（例如左上方区域），形成厚度感。牌叠方向可统一（如向右下偏移）。累积牌区的牌全部背面朝上（因不可见具体牌面）。
UI5.2.2	最新出牌区：展示上一家刚打出的牌（等待被质疑或下一家跟牌）。这些牌同样以层叠方式摆放，每张牌只露出顶部20%，但最上面一张牌可部分显示牌面（如露出点数/花色的一角），以提示玩家最新出牌的情况。也可选择所有牌背面朝上，仅通过标签提示张数，具体由产品设计决定。建议：为了增加策略性，可将最新出牌区的牌全部背面朝上，但显示“最新出牌：X张”的文字信息。
UI5.2.3	两个牌区上方或下方应显示各自包含的牌数（例如“累积：12张”、“最新：3张”）。
UI5.2.4	当累积牌区为空时，显示空白区域或占位符；当最新出牌区为空时，同样显示空白。
UI5.2.5	出牌时，动画效果将新牌从玩家手牌区域飞入最新出牌区；同时，若存在上一家出牌，则上一家的最新出牌区牌叠平滑移动到累积牌区（合并）。质疑时，所有牌从两个牌区飞向收回的玩家手牌区域。
5.3 视觉元素
扑克牌设计：使用矢量或图片表示，正面显示点数与花色，背面统一图案。

选中状态：被选中的手牌应高亮边框或放大。

当前玩家指示：用发光边框或箭头标识。

牌堆：用叠放的扑克图标表示，并显示张数。

5.4 交互细节
鼠标悬停于手牌时，可轻微放大显示。

点击手牌切换选中状态，支持多选。

当轮到人类玩家时，按钮可用；否则禁用并置灰。

电脑行动时，屏幕中央可显示“电脑X正在思考...”提示。

悬停在最新出牌区时，可弹出提示框显示该轮出牌的具体信息（如“电脑2宣称出了3张A”），方便玩家回忆。

6. AI策略详细设计
6.1 质疑策略
AI计算：

myNormal = 自己手中当前点数的普通牌数量

myJoker = 自己手中万能牌数量

maxTrueOutside = (4 - myNormal) + (2 - myJoker) // 外部最多真牌+万能牌
若上家出牌张数 n > maxTrueOutside，则必定质疑。
否则，质疑概率 P 计算如下：

若 n >= 3 且 myNormal >= 2，P = 0.7

若 n == 2，P = 0.3

若 n == 1，P = 0.1

若 n == 0（不可能，但保留）

若手牌数量 ≤ 2，P = P * 0.5（谨慎）

6.2 跟牌策略
AI按优先级选择出牌组合：

若存在当前点数的普通牌或万能牌，出所有真牌（最多3张，以免过度暴露）。若真牌数量为0，转2。

选择手牌中数量最多的其他点数（如手中有3张K），出1~2张该点数的牌。

若无重复点数，随机选1~2张牌（非万能牌，除非只有万能牌）。

若手牌全为万能牌，出1张万能牌。

6.3 首发策略
AI遍历自己所有普通牌的点数，找出出现次数最多的点数（若并列随机选一个）。然后：

打出该点数的所有普通牌（数量记为cnt），若cnt > 3，只出3张。

若需要凑整，可加入万能牌，但万能牌数量不超过普通牌数量。
若没有普通牌（全是万能牌），则随机选一个点数（如A），出1张万能牌。

6.4 随机性实现
在每个决策点，生成随机数与概率阈值比较，决定是否执行特定行动。例如，质疑时生成0~1随机数，若小于P则质疑。

7. 验收标准
初始化：游戏开始后，四名玩家各获得13张牌，界面显示正确，首位玩家随机。

人类出牌：

新轮时，未选点数时出牌按钮禁用；选点数并选牌后可用。

跟牌时，点数自动锁定，出牌按钮随选牌启用。

非法选牌（如选中超出）给出提示。

人类质疑：上一家出牌后，质疑按钮可用；点击后正确验证并执行收牌逻辑。

牌堆显示：

首次出牌后，最新出牌区显示刚打出的牌（层叠样式），累积牌区为空。

第二次出牌后，上一家的牌移入累积牌区，最新出牌区显示新牌。

质疑后，两区清空。

牌叠只显示顶部20%，视觉上符合层叠效果。

AI行动：AI在轮到其回合时自动操作，操作延迟1秒，质疑/出牌符合策略。

全部跳过：当所有其他玩家都选择跳过时，最后出牌者获得下一轮出牌权，牌堆进入弃牌区。

游戏结束：当任意玩家手牌为0时，弹出获胜者提示，不再允许操作。

状态持久：刷新页面后游戏重置。

兼容性：在指定浏览器上打开，布局正常，功能可用。

8. 附录
8.1 点数顺序
A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K （无大小顺序，仅用于标识）

8.2 万能牌处理
大小王在验证时视为任何点数，但在跟牌时AI可将其当作真牌使用。

--- 说明书/弹珠游戏开发计划.txt ---
### USER
要想用vue3+js 开发一款 弹珠小游戏，能很好的设置地面摩檫力，地面凸起和小坑，玻璃球碰撞效果，该引入什么库，制定计划

### ASSISTANT
开发一款具备物理特性（摩擦力、地形起伏）和高质量视觉效果（玻璃质感）的 3D 弹珠游戏，单纯靠 Vue 的 DOM 操作是无法实现的，必须引入 **WebGL 渲染引擎** 和 **物理引擎**。

以下是针对 Vue 3 + JavaScript 技术栈的库选型推荐及详细开发计划。

### 一、核心库选型推荐

| 需求 | 推荐库 | 理由 |
| :--- | :--- | :--- |
| **3D 渲染** | **Three.js** | 行业标准，生态最丰富。能完美实现玻璃材质（PBR）、光照、阴影和后处理效果。 |
| **物理引擎** | **Cannon-es** | Cannon.js 的维护分支，轻量级 3D 物理引擎。与 Three.js 配合极佳，支持刚体、摩擦力、反弹系数及**高度场（Heightfield）地形**。 |
| **Vue 集成** | **VueUse** | 提供 `useRafFn` (requestAnimationFrame) 等工具，方便在 Vue 中管理游戏循环。 |
| **(可选) 简化层** | **TresJS** | 如果你希望用 Vue 组件的写法来写 Three.js (类似 React Three Fiber)，可以使用 `@tresjs/core` 和 `@tresjs/cannon`。但为了对物理地形有更深控制，**建议直接使用 Three.js + Cannon-es**。 |

**最终推荐技术栈：**
`Vue 3` + `Three.js` + `Cannon-es` + `VueUse`

---

### 二、开发计划 (Roadmap)

#### 第一阶段：环境搭建与基础场景 (Day 1-2)
1.  **初始化项目**：使用 `npm create vue@latest` 创建项目。
2.  **安装依赖**：
    ```bash
    npm install three cannon-es @vueuse/core
    ```
3.  **创建游戏容器**：在 Vue 组件中创建一个 `<div ref="canvasContainer">`。
4.  **初始化 Three.js**：设置 Scene, Camera, Renderer，并处理窗口 resize。
5.  **初始化 Cannon-es**：创建 `World`，设置重力 (`gravity`)。
6.  **同步循环**：使用 `requestAnimationFrame` 同时更新物理世界 (`world.step`) 和渲染世界 (`renderer.render`)，并将物理物体的位置同步给 Three.js 网格。

#### 第二阶段：核心物理特性实现 (Day 3-5)
1.  **玻璃弹珠 (Player)**：
    *   **物理**：创建 `Sphere` 刚体，设置质量 (mass)。
    *   **视觉**：使用 `MeshPhysicalMaterial`。关键属性：`transmission: 1` (透光), `roughness: 0` (光滑), `metalness: 0`, `thickness: 1` (玻璃厚度), `envMap` (环境贴图，这对玻璃质感至关重要)。
2.  **地面摩擦力**：
    *   创建 `PhysicsMaterial`。
    *   设置 `friction` (摩擦系数，0-1) 和 `restitution` (弹性，0-1)。
    *   将该材质赋予地面和弹珠。
3.  **地形起伏 (凸起与小坑)**：
    *   **方案 A (简单)**：使用多个静态 Box 或 Sphere 刚体拼接成障碍物。
    *   **方案 B (推荐)**：使用 Cannon-es 的 **`Heightfield`**。
        *   生成一个二维数组代表高度图（例如：0 代表平地，1 代表凸起，-1 代表坑）。
        *   Cannon-es 会自动根据数组生成对应的碰撞体。
        *   Three.js 端使用 `PlaneGeometry` 并根据同样的高度数据修改顶点 (`vertices`) 以匹配视觉。

#### 第三阶段：控制与游戏逻辑 (Day 6-8)
1.  **操控方式**：
    *   **重力感应/倾斜**：监听 `deviceorientation` 或 鼠标拖拽，改变世界的重力方向或给球施加力 (`body.applyForce`)。
    *   **点击发射**：给球施加瞬间冲量 (`body.applyImpulse`)。
2.  **游戏状态管理**：
    *   使用 Vue 的 `ref` 或 `reactive` 管理分数、生命值、游戏结束状态。
    *   **注意**：游戏循环内的数据（如球的位置）不要直接触发 Vue 响应式更新，否则会导致卡顿。只在需要更新 UI（如分数变化）时同步到 Vue 状态。
3.  **碰撞检测**：
    *   监听 Cannon 的 `collide` 事件。
    *   判断球是否掉出地图（Y 轴过低）-> 游戏结束。
    *   判断球是否碰到得分点 -> 加分。

#### 第四阶段：视觉 polish 与 优化 (Day 9-10)
1.  **光影效果**：添加 `AmbientLight` 和 `DirectionalLight` (开启 shadowMap)。
2.  **后处理 (Post-processing)**：
    *   引入 `EffectComposer`, `RenderPass`, `BloomPass`。
    *   为玻璃球添加 **Bloom (泛光)** 效果，使其看起来更晶莹剔透。
3.  **粒子效果**：当球碰撞或得分时，使用 Three.js 粒子系统产生火花。
4.  **性能优化**：
    *   限制物理步长。
    *   使用 `InstancedMesh` 如果有很多相同的障碍物。
    *   确保 Vue 的 DOM 更新不与 WebGL 渲染争抢主线程。

---

### 三、关键代码实现思路

#### 1. 玻璃球材质 (Three.js)
要实现真实的玻璃效果，必须使用 `MeshPhysicalMaterial` 并配合环境贴图。

```javascript
import { MeshPhysicalMaterial, SphereGeometry, Mesh } from 'three';

// 创建几何体
const geometry = new SphereGeometry(0.5, 32, 32);

// 创建玻璃材质
const material = new MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0.1,
  roughness: 0.05,
  transmission: 1,  // 透光率，关键！
  thickness: 1.5,   // 玻璃厚度，产生折射
  envMapIntensity: 1,
  clearcoat: 1,     // 清漆层，增加光泽
  clearcoatRoughness: 0.1,
});

const ballMesh = new Mesh(geometry, material);
```
*提示：你需要加载一个 HDRI 环境贴图 (`RGBELoader`) 到 scene.environment，否则玻璃看起来是黑的。*

#### 2. 带起伏的地形 (Cannon-es Heightfield)
这是实现“小坑和凸起”最高效的方法。

```javascript
import * as CANNON from 'cannon-es';

// 1. 生成高度数据 (例如 50x50 的网格)
const matrix = [];
const size = 50;
for (let i = 0; i < size; i++) {
  matrix[i] = [];
  for (let j = 0; j < size; j++) {
    // 使用正弦波或噪声函数生成起伏
    const x = i / size;
    const y = j / size;
    // 模拟一个小坑和一个凸起
    matrix[i][j] = Math.sin(x * Math.PI) * Math.cos(y * Math.PI) * 2; 
  }
}

// 2. 创建物理高度场
const heightfieldShape = new CANNON.Heightfield(matrix, {
  elementSize: 1, // 每个网格单元的宽度
});

const body = new CANNON.Body({
  mass: 0, // 0 表示静态物体
  material: groundMaterial // 之前定义的摩擦材质
});

body.addShape(heightfieldShape);
// 调整位置，让高度场中心对齐
body.position.set(-size / 2, -1, -size / 2); 
body.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // 旋转 90 度放平

world.addBody(body);
```

#### 3. Vue 中的游戏循环管理
不要在 `template` 里直接驱动动画，使用 `useRafFn`。

```javascript
// Game.vue
<script setup>
import { onMounted, onUnmounted, ref } from 'vue';
import { useRafFn } from '@vueuse/core';
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

const containerRef = ref(null);
let world, scene, camera, renderer, ballBody, ballMesh;
const score = ref(0); // Vue 响应式，用于 UI

// 初始化函数
const init = () => {
  // ... 初始化 Three 和 Cannon 代码 ...
};

// 游戏循环
const { pause, resume } = useRafFn(() => {
  if (!world || !scene) return;

  // 1. 更新物理 (固定步长 1/60)
  world.step(1 / 60);

  // 2. 同步物理位置到渲染网格
  if (ballBody && ballMesh) {
    ballMesh.position.copy(ballBody.position);
    ballMesh.quaternion.copy(ballBody.quaternion);
    
    // 检测是否掉出地图
    if (ballBody.position.y < -10) {
      gameOver();
    }
  }

  // 3. 渲染
  renderer.render(scene, camera);
});

const gameOver = () => {
  pause(); // 停止循环
  // 触发 Vue UI 显示游戏结束
};

onMounted(() => {
  init();
  resume(); // 开始循环
});

onUnmounted(() => {
  pause();
  // 清理资源
});
</script>
```

### 四、难点与解决方案

1.  **玻璃球看起来不像玻璃？**
    *   **原因**：缺少环境反射。
    *   **解决**：必须加载 HDRI 环境贴图 (`.hdr` 文件)，设置 `scene.environment = hdriTexture`。没有环境光，折射和反射无法计算。

2.  **地形碰撞穿模？**
    *   **原因**：物理步长太大或球速度太快（隧道效应）。
    *   **解决**：减小 `world.step` 的时间步长，或在 Cannon 的 Body 上开启 `collisionFilterGroup` 和 `collisionResponse` 优化。对于高速物体，Cannon-es 支持 CCD (连续碰撞检测) 的简化版，确保球体半径不要小于地形网格大小。

3.  **Vue 响应式导致卡顿？**
    *   **原因**：在 `requestAnimationFrame` 里频繁修改 `ref` 变量。
    *   **解决**：游戏内部状态（球坐标、速度）用普通 JS 变量存储。只有分数、关卡、UI 状态才用 Vue `ref`。

4.  **地面摩擦力不生效？**
    *   **原因**：没有正确配置 `ContactMaterial`。
    *   **解决**：在 Cannon `World` 中，需要添加 `ContactMaterial` 来定义两种不同材质接触时的摩擦表现，而不仅仅是给物体赋予材质。
    ```javascript
    const groundMat = new CANNON.Material();
    const ballMat = new CANNON.Material();
    const contactMat = new CANNON.ContactMaterial(groundMat, ballMat, {
      friction: 0.5, // 摩擦力
      restitution: 0.7 // 弹性
    });
    world.addContactMaterial(contactMat);
    ```

### 五、总结建议

1.  **先跑通 Demo**：不要一开始就追求完美的玻璃效果。先用一个白色球体和平面，把物理运动调顺。
2.  **地形生成**：可以使用简单的噪声库（如 `simplex-noise`）来生成随机的起伏地面数据，比手动写数组更自然。
3.  **UI 分离**：游戏画面是 Canvas，UI（分数、开始按钮）是 HTML/CSS。利用 Vue 的优势做好 UI 层，Canvas 层保持独立。

按照这个计划，你可以利用 Vue 3 管理游戏状态，利用 Three.js + Cannon-es 处理核心的 3D 交互，实现一款高质量的弹珠游戏。

### USER
补充玩法为：
1.挖坑玩法(基础版)
1.场地准备:在泥土地面挖3-4个小坑(直径约3-5厘米)，呈直线排列
2.开局顺序:
参与者从起点线将球弹出
离首个坑最近者获得优先权
3.进阶规则:
依次将球弹入三个坑中
完成三坑占领后可攻击对手的球
最终以先进入终点坑者为胜

### ASSISTANT
加上具体的“挖坑弹珠”玩法规则后，项目的重心从单纯的**物理演示**转向了**游戏逻辑与交互设计**。这需要更严谨的状态管理、更精准的碰撞检测（判断进坑）以及特定的操作手感（弹射）。

以下是针对该玩法的**技术栈调整**、**核心逻辑架构**及**详细开发计划**。

---

### 一、技术栈调整与补充

| 模块 | 推荐库/方案 | 针对玩法的调整理由 |
| :--- | :--- | :--- |
| **状态管理** | **Vue 3 `reactive` / Pinia** | 游戏需要明确的状态机（资格赛 -> 游戏开始 -> 玩家回合 -> 攻击模式 -> 结算），Vue 的响应式系统非常适合管理这些 UI 状态。 |
| **交互操作** | **VueUse `usePointerSwipe`** 或 **原生 Pointer Events** | 实现“拉弓弹射”手感。需要计算 2D 屏幕拖拽距离映射为 3D 物理冲量。 |
| **物理检测** | **Cannon-es `isTrigger`** | **关键点**：单纯靠物理凹陷判断“进坑”容易出 Bug（球滚出来）。建议**视觉上做凹陷，物理上用触发器**判断是否捕获。 |
| **相机控制** | **Three.js `OrbitControls`** (限制版) | 需要限制相机角度，保证玩家能看清直线排列的坑，且不能穿地。 |
| **AI 对手** | **自定义逻辑** | 如果是单机游戏，需要编写简单的 AI 逻辑（计算角度、力度）来模拟对手。 |

---

### 二、核心游戏逻辑架构 (State Machine)

在 Vue 组件中，你需要维护一个游戏状态对象：

```javascript
const gameState = reactive({
  phase: 'qualifying', // 'qualifying'(资格赛), 'playing'(正式游戏), 'gameover'(结束)
  currentPlayer: 1,    // 1 或 2 (或 AI)
  turn: 'move',        // 'move'(移动), 'attack'(攻击状态)
  holes: [             // 坑的状态
    { id: 1, occupiedBy: null, position: {x:0, z:-5} },
    { id: 2, occupiedBy: null, position: {x:0, z:-10} },
    { id: 3, occupiedBy: null, position: {x:0, z:-15} },
    { id: 4, occupiedBy: null, position: {x:0, z:-20}, isFinish: true } // 终点坑
  ],
  players: [
    { id: 1, color: 0xff0000, status: 'normal', finished: false }, // status: 'normal' | 'hunter'(可攻击)
    { id: 2, color: 0x0000ff, status: 'normal', finished: false }
  ]
});
```

---

### 三、详细开发计划 (针对新玩法)

#### 第一阶段：场地与“坑”的实现 (Day 1-3)
1.  **泥土地面材质**：
    *   加载泥土纹理贴图 (`Diffuse`, `Normal`, `Roughness`)。
    *   物理材质设置高摩擦力 (`friction: 0.8`)，低弹性 (`restitution: 0.1`)，模拟泥土感。
2.  **实现“坑” (视觉 + 逻辑)**：
    *   **视觉**：使用 `Heightfield` 或在 `PlaneGeometry` 上修改顶点，制造 3-4 个圆形的浅凹陷。
    *   **逻辑 (关键)**：在每个坑的中心放置一个不可见的 **Cannon Trigger (触发器)** 球体或圆柱体。
    *   **进坑判定**：当弹珠 `collide` 事件触发且碰撞对象是 Trigger，且弹珠速度 `< 阈值` 时，判定为“进坑成功”，将弹珠位置吸附到坑中心，并更新 Vue 状态。
3.  **终点线**：
    *   在最后一个坑后方设置终点区域。

#### 第二阶段：弹射操控系统 (Day 4-6)
1.  **射线检测 (Raycasting)**：
    *   监听鼠标/触摸 `down` 和 `up` 事件。
    *   使用 `THREE.Raycaster` 将屏幕坐标转换为 3D 地面坐标。
2.  **力度与方向计算**：
    *   绘制一条从球指向鼠标反方向的“力度线” (Three.js `Line`)。
    *   力度 = 拖拽距离 * 系数。
    *   方向 = 拖拽向量的反方向。
3.  **物理施加**：
    *   松开鼠标时，对当前玩家控制的弹珠刚体应用 `applyImpulse`。
    *   添加最大力度限制，防止球直接飞出地图。

#### 第三阶段：游戏规则引擎 (Day 7-10)
1.  **资格赛逻辑**：
    *   所有球从起点发射。
    *   计算球停止后与“第一个坑”的距离 (`distanceTo`)。
    *   距离最近者设为 `currentPlayer`。
2.  **回合制流程**：
    *   **移动阶段**：玩家尝试将球弹入下一个未占领的坑。
    *   **判定**：
        *   成功进坑 -> 更新 `holes` 状态，若完成 3 坑，玩家状态变为 `'hunter'` (可攻击)。
        *   未进坑 -> 回合结束，切换玩家。
    *   **攻击阶段** (当玩家状态为 `'hunter'`)：
        *   允许玩家直接撞击对手球。
        *   **碰撞监听**：在 Cannon `collide` 事件中，检测碰撞双方是否为不同玩家的球。
        *   **攻击效果**：若 Hunter 撞击 Normal，Normal 球被弹回起点或暂停一回合。
3.  **胜利判定**：
    *   监听终点坑 Trigger。
    *   若有玩家进坑且已完成前置条件，触发 `gameState.phase = 'gameover'`，弹出 Vue UI 胜利界面。

#### 第四阶段：AI 与 体验优化 (Day 11-14)
1.  **简单 AI**：
    *   计算 AI 球到目标坑的向量。
    *   添加随机误差 (Random Noise) 模拟人类失误。
    *   若处于攻击模式，计算撞击对手球的角度。
2.  **相机跟随**：
    *   相机平滑移动 (`lerp`) 到当前操作球的上方。
3.  **特效**：
    *   进坑时：粒子爆炸特效 + 音效。
    *   攻击时：屏幕轻微震动。

---

### 四、关键代码实现思路

#### 1. 坑的触发器逻辑 (Cannon-es + Three.js)
不要完全依赖物理凹陷，用 Trigger 更稳定。

```javascript
// 创建坑的逻辑 (在初始化场地时)
function createHole(x, z, holeId) {
  // 1. 视觉凹陷 (简化版：用一个小圆柱体嵌入地面，颜色深一点)
  const geo = new CylinderGeometry(1.5, 1.5, 0.2, 32);
  const mat = new MeshStandardMaterial({ color: 0x332211 }); // 深色泥土
  const mesh = new Mesh(geo, mat);
  mesh.position.set(x, -0.1, z); // 稍微低于地面
  scene.add(mesh);

  // 2. 物理触发器 (用于判断进坑)
  const shape = new CANNON.Cylinder(1.5, 1.5, 1, 16);
  const body = new CANNON.Body({
    mass: 0,
    isTrigger: true, // 关键：设为触发器，不产生物理碰撞，只触发事件
    type: CANNON.Body.STATIC
  });
  body.addShape(shape);
  body.position.set(x, 0, z);
  
  // 绑定坑 ID
  body.holeId = holeId; 
  world.addBody(body);

  // 3. 监听碰撞
  body.addEventListener('collide', (e) => {
    const ballBody = e.body;
    // 检查碰撞的是否是玩家的球
    if (ballBody.playerId) {
      checkHoleEntry(ballBody, holeId);
    }
  });
}

// 进坑判定函数
function checkHoleEntry(ballBody, holeId) {
  // 只有速度足够慢才算“停进坑里”，否则只是滚过
  if (ballBody.velocity.length() < 0.5) {
    // 触发 Vue 状态更新
    gameLogic.enterHole(ballBody.playerId, holeId);
    
    // 物理吸附：防止球滚出来
    ballBody.position.set(holePositions[holeId].x, 0.5, holePositions[holeId].z);
    ballBody.velocity.set(0,0,0);
    ballBody.angularVelocity.set(0,0,0);
  }
}
```

#### 2. 弹射控制 (Vue + Raycaster)

```javascript
// 使用 VueUse 处理指针事件
import { usePointer } from '@vueuse/core';

const { x, y, pressed } = usePointer();
const dragStart = ref(null);
const dragCurrent = ref(null);

// 在 mousedown/touchstart 时
if (pressed.value && !dragStart.value) {
  dragStart.value = { x: x.value, y: y.value };
}

// 在 mousemove/touchmove 时
if (pressed.value && dragStart.value) {
  dragCurrent.value = { x: x.value, y: y.value };
  // 更新 UI 上的力度线
  updateAimLine(dragStart.value, dragCurrent.value);
}

// 在 mouseup/touchend 时
if (dragStart.value && dragCurrent.value) {
  const dx = dragStart.value.x - dragCurrent.value.x;
  const dy = dragStart.value.y - dragCurrent.value.y;
  
  // 将 2D 屏幕向量转换为 3D 世界向量 (需考虑相机角度)
  const forceVector = screenToWorldVector(dx, dy); 
  
  // 施加冲量
  currentBallBody.applyImpulse(
    new CANNON.Vec3(forceVector.x * 10, 0, forceVector.z * 10),
    currentBallBody.position
  );
  
  // 重置
  dragStart.value = null;
  dragCurrent.value = null;
  endTurn(); // 结束当前操作，切换回合
}
```

#### 3. 攻击逻辑 (碰撞检测)

```javascript
// 在全局碰撞监听中
world.addEventListener('collide', (e) => {
  const bodyA = e.body;
  const bodyB = e.contact.bi; // 碰撞的另一方

  // 确保两个都是球
  if (bodyA.playerId && bodyB.playerId) {
    const playerA = gameState.players.find(p => p.id === bodyA.playerId);
    const playerB = gameState.players.find(p => p.id === bodyB.playerId);

    // 攻击判定：A 是猎人，B 是普通人
    if (playerA.status === 'hunter' && playerB.status === 'normal') {
      // 触发攻击特效
      playHitEffect(e.contact.equation.contactPoint);
      // 可选：增加 B 被击退的惩罚逻辑
      console.log("Player A attacked Player B!");
    }
  }
});
```

### 五、针对玩法的特别注意事项

1.  **摩擦力调优**：
    *   泥土地面的摩擦力要大，否则球停不下来，无法判定“进坑”。
    *   在 Cannon 的 `ContactMaterial` 中，将 `friction` 设为 `0.6 - 0.9` 之间，`restitution` (弹性) 设为 `0.1` (泥土不弹)。
2.  **防作弊/防卡死**：
    *   如果球卡在两个坑之间怎么办？设置一个“重置球”按钮，或者当球速度接近 0 且不在坑内超过 5 秒，自动重置到起点。
3.  **视觉引导**：
    *   用虚线在地面画出 3 个坑的连线，让玩家明确路线。
    *   当前目标坑高亮显示（例如发光）。
4.  **移动端适配**：
    *   弹珠游戏很适合手机玩。确保 `touch-action: none` 防止浏览器默认滚动。
    *   力度线要粗一点，方便手指操作。

### 六、总结

这个玩法的核心在于**“状态机管理”**（Vue 负责）与**“精准碰撞判定”**（Cannon 负责）。
*   **Vue 3** 用来管理谁回合、谁赢了、哪个坑被占了。
*   **Three.js** 用来表现泥土质感和玻璃球的通透感。
*   **Cannon-es** 用来计算滚动、摩擦和碰撞，但**进坑判定建议混合使用 Trigger 和速度阈值**，以保证游戏体验的流畅性，避免物理引擎的微小抖动导致球滚出坑外。

按照这个计划，你可以开发出一款既有复古手感，又有现代视觉效果的手机/网页端弹珠游戏。

--- 说明书/弹珠游戏需求规格说明书.md ---
# 3D 弹珠小游戏（挖坑玩法）需求规格说明书 (SRS)

| 文档版本 | V1.0 |
| :--- | :--- |
| **项目名称** | Vue3 3D Marbles: Pit Master (弹珠大师) |
| **技术栈** | Vue 3 + Three.js + Cannon-es + JavaScript |
| **文档状态** | 草稿 / 评审中 |
| **最后更新** | 2023-10-27 |

---

## 1. 引言 (Introduction)

### 1.1 编写目的
本文档旨在明确"Vue3 3D 弹珠小游戏”的功能需求、非功能需求及技术架构，为开发团队提供统一的执行标准。重点在于实现基于物理引擎的拟真弹珠体验，并完整还原“挖坑”传统玩法规则。

### 1.2 项目背景
利用现代 Web 技术（WebGL）在浏览器端重现传统弹珠游戏。通过 Vue 3 管理游戏状态，Three.js 负责渲染，Cannon-es 负责物理模拟，实现无需下载、即开即玩的 3D 休闲游戏。

### 1.3 适用范围
*   **前端开发**：负责游戏逻辑、UI 交互、3D 场景搭建。
*   **测试人员**：依据本文档进行功能验收和性能测试。
*   **UI/UX 设计**：依据界面需求设计视觉资源。

---

## 2. 总体描述 (Overall Description)

### 2.1 用户特征
*   **目标用户**：休闲游戏玩家，覆盖移动端（手机浏览器）和桌面端。
*   **操作习惯**：习惯触摸屏拖拽或鼠标拖拽操作。

### 2.2 产品视角
本产品为独立运行的 H5 游戏，不依赖后端服务器（单机或本地多人），所有逻辑在客户端运行。

### 2.3 一般约束
*   必须兼容主流现代浏览器（Chrome 90+, Safari 14+）。
*   首屏加载时间不超过 3 秒（资源需压缩）。
*   游戏帧率需稳定在 50FPS 以上（移动端）/ 60FPS（桌面端）。

---

## 3. 功能需求 (Functional Requirements)

### 3.1 游戏核心玩法 (Gameplay)

| 需求 ID | 功能名称 | 详细描述 | 优先级 |
| :--- | :--- | :--- | :--- |
| **FR-01** | **资格赛机制** | 开局所有玩家从起点线弹球。系统计算球静止后距离“第一个坑”的欧几里得距离，最近者获得先手权。 | P0 |
| **FR-02** | **挖坑占领** | 场地设有 3-4 个目标坑（呈直线排列）。玩家需按顺序将球弹入坑中。每占领一个坑，状态更新。 | P0 |
| **FR-03** | **猎人模式** | 当玩家成功占领前 3 个坑后，进入“猎人 (Hunter)"状态。此时该玩家可攻击对手球。 | P0 |
| **FR-04** | **攻击判定** | 猎人状态的球撞击普通状态对手球时，触发攻击效果（对手球重置或暂停一回合）。需通过物理碰撞事件检测。 | P1 |
| **FR-05** | **胜利条件** | 玩家完成所有坑占领，并成功弹入“终点坑”后，游戏结束，显示胜利 UI。 | P0 |
| **FR-06** | **回合切换** | 若玩家未进坑或操作失误，回合自动切换至下一位玩家（或 AI）。 | P0 |

### 3.2 物理与环境 (Physics & Environment)

| 需求 ID | 功能名称 | 详细描述 | 优先级 |
| :--- | :--- | :--- | :--- |
| **FR-07** | **地面摩擦力** | 泥土地面需具备高摩擦力 (`friction > 0.6`) 和低弹性 (`restitution < 0.2`)，确保球能自然停止。 | P0 |
| **FR-08** | **地形起伏** | 地面需包含随机或预设的凸起与小坑（非目标坑），通过 `Heightfield` 实现，影响球的滚动轨迹。 | P1 |
| **FR-09** | **进坑判定** | 目标坑需使用**物理触发器 (Trigger)** 结合速度阈值判定。球速低于阈值且进入触发区视为“进坑成功”，并吸附位置。 | P0 |
| **FR-10** | **碰撞效果** | 球与球、球与地面碰撞需有真实的动量交换。玻璃球之间碰撞需有清脆的音效（可选）。 | P1 |

### 3.3 控制系统 (Controls)

| 需求 ID | 功能名称 | 详细描述 | 优先级 |
| :--- | :--- | :--- | :--- |
| **FR-11** | **拖拽弹射** | 支持鼠标/触摸拖拽。从球体位置向反方向拖拽，显示力度指示线，松手发射。 | P0 |
| **FR-12** | **力度限制** | 设置最大拖拽距离，防止力度过大导致球飞出地图或穿模。 | P1 |
| **FR-13** | **相机跟随** | 相机需平滑跟随当前操作玩家的球，但需限制角度，防止看到地图外或穿地。 | P1 |

---

## 4. 非功能需求 (Non-Functional Requirements)

### 4.1 视觉表现 (Visuals)
*   **NFR-01 玻璃材质**：弹珠必须使用 `MeshPhysicalMaterial`。
    *   `transmission`: 1.0 (透光)
    *   `roughness`: 0.0 (光滑)
    *   `thickness`: 1.5 (折射厚度)
    *   必须加载 HDRI 环境贴图以体现玻璃反射。
*   **NFR-02 光影效果**：开启阴影映射 (`shadowMap`)，主光源模拟太阳光，环境光模拟天光。
*   **NFR-03 视觉反馈**：
    *   目标坑需高亮显示（如发光边缘）。
    *   拖拽时需显示预测轨迹线或力度条。
    *   进坑时需有粒子特效。

### 4.2 性能要求 (Performance)
*   **NFR-04 渲染性能**：Draw Calls 尽量控制在 100 以内。
*   **NFR-05 物理步长**：物理引擎步长固定为 `1/60` 秒，防止高速运动穿模。
*   **NFR-06 内存管理**：游戏结束或重置时，需彻底销毁 Three.js 几何体、材质和 Cannon 刚体，防止内存泄漏。

### 4.3 兼容性 (Compatibility)
*   **NFR-07 响应式布局**：UI 界面需适配手机竖屏、横屏及桌面浏览器。
*   **NFR-08 触摸支持**：必须阻止浏览器默认的触摸滚动行为 (`touch-action: none`)。

---

## 5. 技术架构 (Technical Architecture)

### 5.1 技术栈选型
*   **核心框架**: Vue 3 (Composition API)
*   **3D 渲染**: Three.js (r150+)
*   **物理引擎**: Cannon-es (轻量级，支持 Heightfield)
*   **工具库**: @vueuse/core (处理 RAF 循环、Pointer 事件)
*   **构建工具**: Vite

### 5.2 模块划分
1.  **GameLoop 模块**: 管理 `requestAnimationFrame`，同步物理世界与渲染世界。
2.  **SceneManager 模块**: 负责加载模型、纹理、HDRI，创建地面、坑、弹珠。
3.  **PhysicsManager 模块**: 封装 Cannon-es，管理刚体创建、碰撞事件监听、触发器逻辑。
4.  **InputManager 模块**: 处理拖拽输入，计算发射向量。
5.  **GameState 模块 (Vue Reactive)**: 管理游戏状态机、分数、回合、玩家状态。
6.  **UI 层**: 基于 Vue 的 DOM 组件，覆盖在 Canvas 之上。

### 5.3 关键实现策略
*   **进坑逻辑**：不单纯依赖物理凹陷。在坑位创建 `isTrigger: true` 的 Cannon 刚体。当球体 `collide` 触发器且 `velocity.length < 0.5` 时，强制将球 `position` 设置为坑中心，并锁定速度。
*   **玻璃渲染**：使用 `RGBELoader` 加载 `.hdr` 贴图赋值给 `scene.environment`。
*   **状态同步**：物理计算在 JS 线程，Vue 仅用于存储游戏逻辑状态（如“谁赢了”），避免在渲染循环中频繁触发 Vue 响应式更新。

---

## 6. 数据逻辑与状态机 (Data & State Machine)

### 6.1 游戏状态枚举
```typescript
type GamePhase = 'QUALIFYING' | 'PLAYING' | 'GAMEOVER';
type PlayerStatus = 'NORMAL' | 'HUNTER' | 'FINISHED';
type TurnPhase = 'AIMING' | 'MOVING' | 'RESOLVING';
```

### 6.2 坑位数据结构
```javascript
const holes = [
  { id: 1, pos: {x:0, z:-5}, occupiedBy: null, isFinish: false },
  { id: 2, pos: {x:0, z:-10}, occupiedBy: null, isFinish: false },
  { id: 3, pos: {x:0, z:-15}, occupiedBy: null, isFinish: false },
  { id: 4, pos: {x:0, z:-20}, occupiedBy: null, isFinish: true }  // 终点
];
```

### 6.3 玩家数据结构
```javascript
const players = [
  { id: 1, color: 0xff0000, ballBody: null, status: 'NORMAL', finished: false },
  { id: 2, color: 0x0000ff, ballBody: null, status: 'NORMAL', finished: false } // 或 AI
];
```

---

## 7. 界面与交互设计 (UI/UX)

### 7.1 游戏内 HUD
*   **顶部**：当前回合指示器（显示玩家头像/颜色）、剩余坑位数。
*   **底部**：操作提示（“拖拽发射”）、重置按钮。
*   **场景内**：
    *   力度指示线（拖拽时显示）。
    *   目标坑高亮圈（当前需要进入的坑）。

### 7.2 弹窗界面
*   **开局弹窗**：显示“资格赛”规则，点击开始。
*   **结算弹窗**：显示胜利者，提供“再来一局”按钮。
*   **攻击提示**：当玩家进入“猎人”状态时，弹出短暂提示“可以攻击对手了！”。

---

## 8. 验收标准 (Acceptance Criteria)

1.  **物理验收**：
    *   球在泥土地面滚动应在 3-5 秒内自然停止。
    *   球进入坑位后不会因物理抖动自动滚出。
    *   玻璃球在光照下有明显的折射和反射效果。
2.  **玩法验收**：
    *   资格赛能准确判断谁离坑最近。
    *   必须按顺序进坑，不能跳过中间坑直接进终点。
    *   只有占领 3 坑后才能触发攻击逻辑。
3.  **性能验收**：
    *   移动端连续游玩 5 分钟无明显发热卡顿。
    *   切换场景/重置游戏后内存无明显增长。

---

## 9. 风险评估与对策 (Risks & Mitigation)

| 风险点 | 描述 | 应对策略 |
| :--- | :--- | :--- |
| **物理穿模** | 高速运动下球穿过地面或坑壁 | 限制最大发射力度；开启 Cannon 的 CCD (连续碰撞检测) 或减小物理步长。 |
| **进坑误判** | 球滚过坑上方被判定为进坑 | 增加速度阈值判定；触发器高度略低于地面平面。 |
| **移动端兼容** | iOS Safari WebGL 性能差 | 降低阴影分辨率；简化玻璃材质（减少折射计算）；提供“低画质”选项。 |
| **状态不同步** | 物理停止判断与 UI 状态不一致 | 以物理引擎的 `sleep` 事件或速度阈值为准，统一由 GameLoop 调度状态更新。 |

---

**批准人签字**: ____________________
**日期**: ____________________

--- 说明书/形色牌说明书.md ---
《形色牌 (Set)》Web 版 - 完整卡牌清单与规格说明
文档版本
V1.1 (Asset Supplement)
项目名称
形色牌 Web 版 (Set Online)
关联文档
需求规格说明书 (PRD) V1.0
卡牌总数
81 张 (唯一组合)
设计风格
纸质桌游模拟 / 胶片颗粒 / 低饱和色彩
1. 卡牌总数与构成逻辑 (Total Count & Logic)
本游戏卡牌 deck 由 81 张 独一无二的卡牌组成。每张卡牌由 4 个属性 定义，每个属性有 3 种变体。
计算公式：
3
(
数量
)
×
3
(
形状
)
×
3
(
颜色
)
×
3
(
填充
)
=
81
 张
3(数量)×3(形状)×3(颜色)×3(填充)=81 张
核心规则：
Deck 中包含所有可能的组合，每张组合仅出现一次。
2. 属性定义与设计规格 (Attribute Definitions)
2.1 颜色 (Color) - 3 种
设计注：所有颜色均需叠加全局噪点层，禁止使用纯色填充。
编号
名称
色值 (Hex)
视觉描述
C1
砖红 (Brick Red)
#a86b5e
类似旧印泥，低饱和暖红
C2
鼠尾草绿 (Sage Green)
#7a8c73
类似干燥植物，灰调绿
C3
灰紫 (Grey Purple)
#6b5b7a
类似褪色布料，冷调紫
2.2 形状 (Shape) - 3 种
设计注：SVG 路径需经过轻微手绘化处理，避免完美几何感。
编号
名称
视觉描述
S1
椭圆 (Oval)
圆润的椭圆形，类似鹅卵石
S2
波浪 (Squiggle)
类似变形虫或波浪线闭合形状，有机感强
S3
菱形 (Diamond)
四边菱形，角部略微圆滑，非锐利直角
2.3 填充 (Shading) - 3 种
设计注：这是质感表现的核心区域，需严格区分纹理。
编号
名称
视觉实现方案
H1
实心 (Solid)
使用属性颜色填充，内部叠加 opacity: 0.15 的噪点纹理，混合模式 multiply
H2
条纹 (Striped)
使用属性颜色绘制平行斜线 (45°)，线条上覆盖噪点，线条间隙透明露出卡牌底色
H3
空心 (Open)
仅绘制属性颜色的轮廓线 (Stroke 2px)，内部填充卡牌底色 #f4f1ea，内部噪点透明度降至 0.05
2.4 数量 (Number) - 3 种
设计注：同一张卡牌上的多个图形需排列整齐，间距均等。
编号
名称
视觉描述
N1
1 个
图形居中显示
N2
2 个
图形左右或上下并列排列
N3
3 个
图形呈三角形或直线排列
3. 完整卡牌清单 (Complete Card List)
为确保开发无误，以下按 颜色 分组列出全部 81 张卡牌的逻辑组合。
(注：每张卡牌 = 颜色 + 形状 + 填充 + 数量)
🟥 第一组：砖红色系 (Brick Red) - 共 27 张
颜色代码：#a86b5e
形状
填充
数量变体 (每张均为独立卡牌)
小计
椭圆
实心
1 个、2 个、3 个
3 张
椭圆
条纹
1 个、2 个、3 个
3 张
椭圆
空心
1 个、2 个、3 个
3 张
波浪
实心
1 个、2 个、3 个
3 张
波浪
条纹
1 个、2 个、3 个
3 张
波浪
空心
1 个、2 个、3 个
3 张
菱形
实心
1 个、2 个、3 个
3 张
菱形
条纹
1 个、2 个、3 个
3 张
菱形
空心
1 个、2 个、3 个
3 张
红色系合计
27 张
🟩 第二组：鼠尾草绿色系 (Sage Green) - 共 27 张
颜色代码：#7a8c73
形状
填充
数量变体 (每张均为独立卡牌)
小计
椭圆
实心
1 个、2 个、3 个
3 张
椭圆
条纹
1 个、2 个、3 个
3 张
椭圆
空心
1 个、2 个、3 个
3 张
波浪
实心
1 个、2 个、3 个
3 张
波浪
条纹
1 个、2 个、3 个
3 张
波浪
空心
1 个、2 个、3 个
3 张
菱形
实心
1 个、2 个、3 个
3 张
菱形
条纹
1 个、2 个、3 个
3 张
菱形
空心
1 个、2 个、3 个
3 张
绿色系合计
27 张
🟪 第三组：灰紫色系 (Grey Purple) - 共 27 张
颜色代码：#6b5b7a
形状
填充
数量变体 (每张均为独立卡牌)
小计
椭圆
实心
1 个、2 个、3 个
3 张
椭圆
条纹
1 个、2 个、3 个
3 张
椭圆
空心
1 个、2 个、3 个
3 张
波浪
实心
1 个、2 个、3 个
3 张
波浪
条纹
1 个、2 个、3 个
3 张
波浪
空心
1 个、2 个、3 个
3 张
菱形
实心
1 个、2 个、3 个
3 张
菱形
条纹
1 个、2 个、3 个
3 张
菱形
空心
1 个、2 个、3 个
3 张
紫色系合计
27 张
4. 视觉质感细节规范 (Texture Details)
为保证 81 张卡牌在视觉上统一且具有“胶片/纸张”感，需严格遵守以下渲染规则：
4.1 卡牌基底 (Card Base)
所有 81 张卡牌 共用同一背景纹理。
背景色：#f4f1ea (暖灰白)
背景噪点：opacity: 0.15 的细密噪点，模拟纸张纤维。
边缘：border-radius: 8px，外加 1px solid rgba(0,0,0,0.05) 细边框。
4.2 填充纹理差异 (Shading Texture)
这是区分卡牌的关键，需通过噪点密度和混合模式体现：
实心 (Solid)
颜色层：属性色 (红/绿/紫)。
噪点层：颜色层之上叠加 opacity: 0.2 噪点，混合模式 multiply。
效果：颜色深沉，有颗粒沉淀感。
条纹 (Striped)
颜色层：属性色绘制斜线 (线宽 4px，间距 4px)。
噪点层：仅覆盖在颜色线条上，不覆盖间隙。
效果：线条边缘略有毛刺感，非矢量平滑边缘。
空心 (Open)
颜色层：仅描边 (Stroke 2px)，无填充。
噪点层：内部区域噪点 opacity: 0.05 (比背景略明显)，描边上噪点 opacity: 0.2。
效果：类似铅笔勾勒的轮廓，内部微微泛黄。
4.3 数量排列 (Number Arrangement)
1 个：垂直居中，水平居中。
2 个：左右并列，间距 10px，整体居中。
3 个：
方案 A (推荐)：品字形排列 (上 1 下 2)，整体居中。
方案 B：垂直排列 (上中下)，整体居中。
注：全 Deck 需统一使用同一种排列逻辑，建议方案 A 更具美感。
5. 资源命名规范 (Asset Naming Convention)
为方便开发管理 81 张卡牌素材，建议采用以下命名结构：
set_[color]_[shape]_[shading]_[number].svg
示例：
set_red_oval_solid_1.svg (红色 - 椭圆 - 实心 -1 个)
set_green_squiggle_striped_2.svg (绿色 - 波浪 - 条纹 -2 个)
set_purple_diamond_open_3.svg (紫色 - 菱形 - 空心 -3 个)
颜色代码映射：
red = #a86b5e
green = #7a8c73
purple = #6b5b7a
形状代码映射：
oval = 椭圆
squiggle = 波浪
diamond = 菱形
填充代码映射：
solid = 实心
striped = 条纹
open = 空心
数量代码映射：
1, 2, 3
6. 验收检查表 (QC Checklist)
总数核对：确认资源文件夹内恰好有 81 个 SVG 文件。
唯一性核对：确认没有重复的组合 (例如不存在两张“红色椭圆实心 1 个”)。
色彩核对：确认红色非纯红，绿色非纯绿，紫色非纯紫，符合低饱和规范。
噪点核对：确认所有卡牌内部均带有噪点纹理，且噪点密度符合填充类型规范。
清晰度核对：确认在 Retina 屏幕下，条纹填充的线条不模糊，空心轮廓不锯齿。
排列核对：确认 2 个和 3 个图形的卡牌，其排列间距在所有颜色/形状中保持一致。

--- 说明书/打包代码.md ---
python d:\4-softworkspace\java\CardKing\.trae\scripts\dump_project.py d:\4-softworkspace\java\CardKing -o output.txt

--- 说明书/游戏需求规格说明书.txt ---
游戏需求规格说明书（更新版）
1. 引言
1.1 编写目的
本文档旨在明确描述一款融合了“比大小”、“24点”和“炸金花”三种玩法的复合扑克牌游戏的需求。游戏为单机人机对战模式，支持1名人类玩家与1~3名电脑玩家同台竞技。文档详细规定了游戏规则、交互方式、计分逻辑、系统行为及AI设计，为开发、测试和验收提供依据。

1.2 适用范围
本文档适用于游戏开发团队、测试人员及项目管理人员。

1.3 定义与缩略语
术语	解释
一局游戏	由多轮比赛组成，所有轮次结束后根据总分决出胜者。
一轮游戏	每轮中每位玩家获得12张牌，并分为上下两个回合进行出牌和计分。
回合	每回合玩家从手中6张牌中分成三堆（1张、2张、3张），分别参与三种比试。
比大小堆	第一堆，每人出一张牌，按点数大小比较，点数相同则比花色。
24点堆	第二堆，每人出两张牌，计算点数之和，比较与24的关系及最大牌。
炸金花堆	第三堆，每人出三张牌，按炸金花牌型规则比较。
豹子	三张点数相同的牌。
顺金	同花顺，即花色相同且点数连续。
金花	同花，即花色相同但点数不连续。
顺子	点数连续但花色不全相同。
对子	两张点数相同，另一张不同。
单张	三张牌无特殊组合。
底分	每堆比赛的名次对应得分，第一名得（玩家人数-1）分，第二名得（玩家人数-2）分，依此类推，最后一名得0分。炸金花堆得分翻倍。
AI	人工智能，电脑玩家。
2. 总体描述
2.1 产品视角
本产品是一款创新型扑克牌游戏，将三种经典玩法融合于同一轮次中，考验玩家的策略分配能力。玩家需将手中12张牌合理分配到两个回合的三个堆中，争取在每个小项中获得高分。游戏提供直观的图形界面，支持鼠标拖拽出牌，电脑玩家采用基于枚举优化的智能策略进行自动分配。

2.2 用户特征
主要用户：喜欢棋牌类游戏的玩家，对策略组合感兴趣。

次要用户：希望通过人机对战熟悉炸金花、24点等规则的初学者。

用户需具备基本的扑克牌认知，无需专业数学知识。

2.3 假设与依赖
游戏使用一副标准54张扑克牌（含大小王），但大小王在发牌时被剔除，实际有效牌为52张（无大小王）。

图形界面需支持拖拽操作，若采用控制台版本则需提供数字选择方式。



3. 具体需求
3.1 游戏初始化
功能编号	FR-001
名称	开始新游戏
描述	玩家启动游戏后，可设置电脑玩家数量（1~3）和一轮游戏包含的轮次数（3~7）。
输入	通过界面滑动条或下拉框选择电脑人数和轮数。
处理	系统创建指定数量的AI玩家和一个人类玩家，每位玩家初始总分为0。
输出	进入牌桌界面，显示所有玩家信息（玩家1、电脑2等）及当前轮次/回合提示。
3.2 发牌规则
功能编号	FR-002
名称	每轮发牌
描述	每轮开始时，系统从洗好的牌堆中为每位玩家发放12张有效牌。
处理	1. 使用一副54张牌（含大小王），洗牌。
2. 依次为每位玩家发牌，每次发一张。若发到大小王，则将该牌丢弃（不发给任何玩家），并继续从牌堆中发下一张，直至每位玩家拥有12张非大小王的牌。
3. 发牌过程中丢弃的大小王不再使用，且不计入任何玩家手中。
4. 发完12张后，剩余牌弃用（不进入后续轮次）。
输出	每位玩家获得12张手牌，在界面中以背面或正面显示（玩家可见自己的牌，AI的牌对玩家保密）。
3.3 回合流程
每轮包含两个回合：上半回合和下半回合。每个回合玩家需从当前手牌中选出6张牌，并分成三堆（分别用于比大小、24点、炸金花），然后同时亮牌比较计分。

3.3.1 上半回合出牌
功能编号	FR-003
名称	上半回合出牌
描述	玩家从12张手牌中选出6张，并分配至三个堆，剩余6张留待下半回合使用。
操作方式	人类玩家通过鼠标拖拽牌张到指定区域（第一堆区域、第二堆区域、第三堆区域），每堆需放满指定张数（1、2、3）后才可确认。AI玩家由系统自动分配。
约束	每堆牌必须恰好为指定张数，且每张牌只能使用一次。玩家可随时调整分配，确认后进入等待状态。
确认机制	所有玩家完成分配后，系统自动进入亮牌比较阶段。若某玩家未确认，系统可设置超时机制（如30秒未操作则随机分配）。
3.3.2 亮牌与比较
功能编号	FR-004
名称	三堆同时比较
描述	所有玩家确认出牌后，系统同时显示每堆的牌，并按规则计算每堆的名次和得分。
处理	1. 先分别计算每堆的排名（第一名、第二名……最后一名）。
2. 根据排名计算每堆得分：第一名得（玩家数-1）分，第二名得（玩家数-2）分，……最后一名得0分。炸金花堆得分乘以2。
3. 将三堆得分累加，计入每位玩家的本回合得分，并累加到总分。
输出	界面展示各玩家每堆的牌、每堆排名及得分，并更新总分。
3.3.3 下半回合出牌
功能编号	FR-005
名称	下半回合出牌
描述	使用上半回合剩余的6张牌，重复出牌、比较、计分过程。
处理	同上半回合，玩家需将剩余6张牌重新分配至三堆。
3.3.4 轮次结束
功能编号	FR-006
名称	轮次结算
描述	两个回合结束后，本轮完成。显示本轮各玩家总分，并准备进入下一轮。
处理	若已完成预设轮次数，则跳转到游戏结束结算；否则重新洗牌，开始新一轮发牌。
3.4 各堆详细比较规则
3.4.1 比大小堆（1张牌）
点数顺序：A > K > Q > J > 10 > 9 > 8 > 7 > 6 > 5 > 4 > 3 > 2（A最大，2最小）。

花色顺序：黑桃 > 红心 > 梅花 > 方块。

比较方法：先比点数，点数大者胜；若点数相同，则比花色，花色大者胜。

排名：按上述规则从大到小排序，确定唯一第一名、第二名等（由于点数花色组合唯一，不会出现平局）。

3.4.2 24点堆（2张牌）
牌面点数：A=1，K=13，Q=12，J=11，10=10，…，2=2。大小王不出现。

计算规则：计算两张牌的点数之和（记为S）。

比较步骤：

若S > 24，则该玩家得分为0，且排名在所有S≤24的玩家之后。
若S ≤ 24，则比较S的大小，S越大者排名越靠前。
若S相同，则比较这两张牌中最大的那张牌的点数，点数大者排名靠前。
若最大牌点数也相同，则比较该最大牌的花色（花色大者胜）。
注意：由于每张牌点数花色唯一，上述比较可保证排名唯一。

3.4.3 炸金花堆（3张牌）
牌型大小顺序（从大到小）：
豹子 > 顺金 > 金花 > 顺子 > 对子 > 单张

牌型定义：

豹子：三张点数相同。

顺金：花色相同且点数连续（A可作为最大或最小，但必须连续，如A、2、3或Q、K、A）。

金花：花色相同但点数不连续。

顺子：点数连续但花色不全相同。

对子：两张点数相同，另一张不同。

单张：三张牌无上述组合。

同牌型比较规则：

豹子：比较点数，点数大者胜。

顺金/顺子：比较最大牌的点数，若相同则比较次大牌的点数，若还相同则比较最小牌的点数。若所有点数相同，则比较最大牌的花色。

金花/单张：按点数从大到小排序，先比较最大牌点数，若相同则比较次大牌，再相同则比较最小牌。若所有点数相同，则比较最大牌的花色。

对子：先比较对子的点数，大者胜；若相同则比较单张的点数；若单张也相同，则比较对子中最大花色（即对子中花色较大的那张），若还相同则比较单张的花色。

排名：上述规则保证唯一排名，不会出现平局。

3.5 计分规则
每堆比赛，根据排名获得分数：
第1名：得（玩家总数 - 1）分
第2名：得（玩家总数 - 2）分
...
最后一名：得0分
例如，4人游戏，第一名得3分，第二名得2分，第三名得1分，第四名得0分。

炸金花堆的得分在上述基础上乘以2。即第一名得2*(n-1)分，第二名得2*(n-2)分，以此类推。

每回合结束后，将三堆得分相加，得到该回合得分，并累加到玩家总分。

一轮结束后，显示本轮各玩家总分，然后进入下一轮。

3.6 游戏结束与胜负判定
完成预设轮次数（3~7轮）后，游戏结束。

比较所有玩家的累计总分，总分最高者获胜。若出现同分，则并列第一（显示并列冠军）。

3.7 AI设计
3.7.1 设计目标
AI玩家需具备一定的出牌智能，能够根据当前手牌合理分配至三个堆，以争取本回合最高得分。AI不依赖对其他玩家手牌的预测，仅基于自身手牌的绝对强度进行优化。

3.7.2 牌力评估函数
为量化每堆牌的强度，定义以下评估函数（分数越高表示该堆在比较中越强）：

比大小堆强度 score_single(card)：
score = 点数 * 10 + 花色值，其中花色值：黑桃=4，红心=3，梅花=2，方块=1；点数：A=14，K=13，Q=12，J=11，10=10，...，2=2。

24点堆强度 score_24(card1, card2)：
计算点数和S。若S > 24，则强度 = 0；否则强度 = S * 100 + 最大牌点数 * 10 + 最大牌花色值（最大牌点数若相同，取花色值大的那张）。

炸金花堆强度 score_poker(card1, card2, card3)：
根据游戏比较规则，构造一个整数分数，使得分数大小与牌型强弱完全一致。构造方法如下：

确定牌型等级：豹子=6，顺金=5，金花=4，顺子=3，对子=2，单张=1。
对三张牌按比较规则提取关键特征，生成分数：
豹子：等级*1000000 + 点数*1000 + 最大花色
顺金/顺子：将三张牌按点数从大到小排序（注意顺子中A可能为1，但排序时按实际比较值，例如A23顺子排序后为3,2,1），分数 = 等级*1000000 + 最大牌点数*10000 + 次大牌点数*100 + 最小牌点数*1 + 最大牌花色
金花/单张：排序后，分数 = 等级*1000000 + 点数1*10000 + 点数2*100 + 点数3*1 + 最大牌花色
对子：设对子点数为P，单张点数为S，排序时P可能大于或小于S，但分数构造为：等级*1000000 + P*10000 + S*100 + 对子中较大花色*10 + 单张花色（保证比较顺序）
该函数确保任何两手牌，若甲大于乙，则score_poker(甲) > score_poker(乙)。
3.7.3 回合内最优分配算法
在每一回合开始时，AI手中有固定张数的牌（上半回合12张，下半回合6张）。AI通过枚举所有可能的分配方案，选择使目标函数最大化的方案。

目标函数：
total = score_single(比大小牌) + score_24(24点牌1, 24点牌2) + 2 * score_poker(炸金花牌1, 炸金花牌2, 炸金花牌3)

枚举步骤：

从当前手牌中选出6张牌的所有组合（上半回合C(12,6)，下半回合仅1种）。
对每个6张牌组合，枚举所有分配方式：
从6张中选1张给比大小堆：C(6,1)
从剩余5张中选2张给24点堆：C(5,2)
剩余3张给炸金花堆
共 6 * 10 = 60 种分配。
计算每种分配的total值，记录最大值对应的分配方案。
若多个方案并列最大，随机选择其一。
输出：该回合的6张牌及其归属（三堆的具体牌张）。

3.7.4 上下半回合的协同
上半回合：AI从12张牌中按上述算法选出最优的6张及分配，剩余6张自动进入下半回合。

下半回合：AI将剩余6张牌作为手牌，再次调用上述算法（此时6张牌的组合唯一，只需枚举60种分配），选出最优分配。

3.7.5 性能要求
AI决策时间 ≤ 1秒，确保游戏流畅。

枚举算法在Python中实现应满足性能要求，必要时可预先计算牌力值或采用缓存优化。

3.8 用户界面
主界面：开始游戏设置（电脑人数、轮数）、帮助、退出。

牌桌界面：

显示所有玩家的头像、名称、当前总分。

中央显示当前回合及倒计时（可选）。

人类玩家手牌区域，牌面朝上，可拖拽。

三个目标区域（比大小堆、24点堆、炸金花堆），每个区域有对应图标和数字（1、2、3）提示张数。

确认按钮：玩家完成分配后点击确认。

电脑玩家的牌背面朝上，但出牌后亮牌时显示正面。

亮牌阶段，展示所有玩家各堆的牌，并显示排名和得分。

下一回合/下一轮按钮（自动跳转）。

操作方式：鼠标拖拽牌张到目标区域，也可双击自动放置。支持撤销。

3.9 异常处理
玩家超时未确认：系统自动为玩家随机分配剩余牌，并提示。

发牌时若因大小王丢弃导致有效牌不足，重新洗牌并提示（概率极低）。

4. 非功能需求
4.1 性能
游戏启动时间 ≤ 3秒。

每回合操作响应时间 ≤ 0.5秒。

AI决策时间 ≤ 1秒（单AI）。

4.2 可用性
界面简洁，操作直观，新手可在10分钟内掌握。

提供规则说明帮助文档。

支持键盘快捷键（如回车确认、ESC退出等）。
