### USER
要想用vue3+js 开发一款 弹珠小游戏，能很好的设置地面摩檫力，地面凸起和小坑，玻璃球碰撞效果，该引入什么库，制定计划

### ASSISTANT
开发一款具备物理特性（摩擦力、地形起伏）和高质量视觉效果（玻璃质感）的 3D 弹珠游戏，单纯靠 Vue 的 DOM 操作是无法实现的，必须引入 **WebGL 渲染引擎** 和 **物理引擎**。

以下是针对 Vue 3 + JavaScript 技术栈的库选型推荐及详细开发计划。

### 一、核心库选型推荐

| 需求 | 推荐库 | 理由 |
| :--- | :--- | :--- |
| **3D 渲染** | **Three.js** | 行业标准，生态最丰富。能完美实现玻璃材质（PBR）、光照、阴影和后处理效果。 |
| **物理引擎** | **Cannon-es** | Cannon.js 的维护分支，轻量级 3D 物理引擎。与 Three.js 配合极佳，支持刚体、摩擦力、反弹系数及**高度场（Heightfield）地形**。 |
| **Vue 集成** | **VueUse** | 提供 `useRafFn` (requestAnimationFrame) 等工具，方便在 Vue 中管理游戏循环。 |
| **(可选) 简化层** | **TresJS** | 如果你希望用 Vue 组件的写法来写 Three.js (类似 React Three Fiber)，可以使用 `@tresjs/core` 和 `@tresjs/cannon`。但为了对物理地形有更深控制，**建议直接使用 Three.js + Cannon-es**。 |

**最终推荐技术栈：**
`Vue 3` + `Three.js` + `Cannon-es` + `VueUse`

---

### 二、开发计划 (Roadmap)

#### 第一阶段：环境搭建与基础场景 (Day 1-2)
1.  **初始化项目**：使用 `npm create vue@latest` 创建项目。
2.  **安装依赖**：
    ```bash
    npm install three cannon-es @vueuse/core
    ```
3.  **创建游戏容器**：在 Vue 组件中创建一个 `<div ref="canvasContainer">`。
4.  **初始化 Three.js**：设置 Scene, Camera, Renderer，并处理窗口 resize。
5.  **初始化 Cannon-es**：创建 `World`，设置重力 (`gravity`)。
6.  **同步循环**：使用 `requestAnimationFrame` 同时更新物理世界 (`world.step`) 和渲染世界 (`renderer.render`)，并将物理物体的位置同步给 Three.js 网格。

#### 第二阶段：核心物理特性实现 (Day 3-5)
1.  **玻璃弹珠 (Player)**：
    *   **物理**：创建 `Sphere` 刚体，设置质量 (mass)。
    *   **视觉**：使用 `MeshPhysicalMaterial`。关键属性：`transmission: 1` (透光), `roughness: 0` (光滑), `metalness: 0`, `thickness: 1` (玻璃厚度), `envMap` (环境贴图，这对玻璃质感至关重要)。
2.  **地面摩擦力**：
    *   创建 `PhysicsMaterial`。
    *   设置 `friction` (摩擦系数，0-1) 和 `restitution` (弹性，0-1)。
    *   将该材质赋予地面和弹珠。
3.  **地形起伏 (凸起与小坑)**：
    *   **方案 A (简单)**：使用多个静态 Box 或 Sphere 刚体拼接成障碍物。
    *   **方案 B (推荐)**：使用 Cannon-es 的 **`Heightfield`**。
        *   生成一个二维数组代表高度图（例如：0 代表平地，1 代表凸起，-1 代表坑）。
        *   Cannon-es 会自动根据数组生成对应的碰撞体。
        *   Three.js 端使用 `PlaneGeometry` 并根据同样的高度数据修改顶点 (`vertices`) 以匹配视觉。

#### 第三阶段：控制与游戏逻辑 (Day 6-8)
1.  **操控方式**：
    *   **重力感应/倾斜**：监听 `deviceorientation` 或 鼠标拖拽，改变世界的重力方向或给球施加力 (`body.applyForce`)。
    *   **点击发射**：给球施加瞬间冲量 (`body.applyImpulse`)。
2.  **游戏状态管理**：
    *   使用 Vue 的 `ref` 或 `reactive` 管理分数、生命值、游戏结束状态。
    *   **注意**：游戏循环内的数据（如球的位置）不要直接触发 Vue 响应式更新，否则会导致卡顿。只在需要更新 UI（如分数变化）时同步到 Vue 状态。
3.  **碰撞检测**：
    *   监听 Cannon 的 `collide` 事件。
    *   判断球是否掉出地图（Y 轴过低）-> 游戏结束。
    *   判断球是否碰到得分点 -> 加分。

#### 第四阶段：视觉 polish 与 优化 (Day 9-10)
1.  **光影效果**：添加 `AmbientLight` 和 `DirectionalLight` (开启 shadowMap)。
2.  **后处理 (Post-processing)**：
    *   引入 `EffectComposer`, `RenderPass`, `BloomPass`。
    *   为玻璃球添加 **Bloom (泛光)** 效果，使其看起来更晶莹剔透。
3.  **粒子效果**：当球碰撞或得分时，使用 Three.js 粒子系统产生火花。
4.  **性能优化**：
    *   限制物理步长。
    *   使用 `InstancedMesh` 如果有很多相同的障碍物。
    *   确保 Vue 的 DOM 更新不与 WebGL 渲染争抢主线程。

---

### 三、关键代码实现思路

#### 1. 玻璃球材质 (Three.js)
要实现真实的玻璃效果，必须使用 `MeshPhysicalMaterial` 并配合环境贴图。

```javascript
import { MeshPhysicalMaterial, SphereGeometry, Mesh } from 'three';

// 创建几何体
const geometry = new SphereGeometry(0.5, 32, 32);

// 创建玻璃材质
const material = new MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0.1,
  roughness: 0.05,
  transmission: 1,  // 透光率，关键！
  thickness: 1.5,   // 玻璃厚度，产生折射
  envMapIntensity: 1,
  clearcoat: 1,     // 清漆层，增加光泽
  clearcoatRoughness: 0.1,
});

const ballMesh = new Mesh(geometry, material);
```
*提示：你需要加载一个 HDRI 环境贴图 (`RGBELoader`) 到 scene.environment，否则玻璃看起来是黑的。*

#### 2. 带起伏的地形 (Cannon-es Heightfield)
这是实现“小坑和凸起”最高效的方法。

```javascript
import * as CANNON from 'cannon-es';

// 1. 生成高度数据 (例如 50x50 的网格)
const matrix = [];
const size = 50;
for (let i = 0; i < size; i++) {
  matrix[i] = [];
  for (let j = 0; j < size; j++) {
    // 使用正弦波或噪声函数生成起伏
    const x = i / size;
    const y = j / size;
    // 模拟一个小坑和一个凸起
    matrix[i][j] = Math.sin(x * Math.PI) * Math.cos(y * Math.PI) * 2; 
  }
}

// 2. 创建物理高度场
const heightfieldShape = new CANNON.Heightfield(matrix, {
  elementSize: 1, // 每个网格单元的宽度
});

const body = new CANNON.Body({
  mass: 0, // 0 表示静态物体
  material: groundMaterial // 之前定义的摩擦材质
});

body.addShape(heightfieldShape);
// 调整位置，让高度场中心对齐
body.position.set(-size / 2, -1, -size / 2); 
body.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // 旋转 90 度放平

world.addBody(body);
```

#### 3. Vue 中的游戏循环管理
不要在 `template` 里直接驱动动画，使用 `useRafFn`。

```javascript
// Game.vue
<script setup>
import { onMounted, onUnmounted, ref } from 'vue';
import { useRafFn } from '@vueuse/core';
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

const containerRef = ref(null);
let world, scene, camera, renderer, ballBody, ballMesh;
const score = ref(0); // Vue 响应式，用于 UI

// 初始化函数
const init = () => {
  // ... 初始化 Three 和 Cannon 代码 ...
};

// 游戏循环
const { pause, resume } = useRafFn(() => {
  if (!world || !scene) return;

  // 1. 更新物理 (固定步长 1/60)
  world.step(1 / 60);

  // 2. 同步物理位置到渲染网格
  if (ballBody && ballMesh) {
    ballMesh.position.copy(ballBody.position);
    ballMesh.quaternion.copy(ballBody.quaternion);
    
    // 检测是否掉出地图
    if (ballBody.position.y < -10) {
      gameOver();
    }
  }

  // 3. 渲染
  renderer.render(scene, camera);
});

const gameOver = () => {
  pause(); // 停止循环
  // 触发 Vue UI 显示游戏结束
};

onMounted(() => {
  init();
  resume(); // 开始循环
});

onUnmounted(() => {
  pause();
  // 清理资源
});
</script>
```

### 四、难点与解决方案

1.  **玻璃球看起来不像玻璃？**
    *   **原因**：缺少环境反射。
    *   **解决**：必须加载 HDRI 环境贴图 (`.hdr` 文件)，设置 `scene.environment = hdriTexture`。没有环境光，折射和反射无法计算。

2.  **地形碰撞穿模？**
    *   **原因**：物理步长太大或球速度太快（隧道效应）。
    *   **解决**：减小 `world.step` 的时间步长，或在 Cannon 的 Body 上开启 `collisionFilterGroup` 和 `collisionResponse` 优化。对于高速物体，Cannon-es 支持 CCD (连续碰撞检测) 的简化版，确保球体半径不要小于地形网格大小。

3.  **Vue 响应式导致卡顿？**
    *   **原因**：在 `requestAnimationFrame` 里频繁修改 `ref` 变量。
    *   **解决**：游戏内部状态（球坐标、速度）用普通 JS 变量存储。只有分数、关卡、UI 状态才用 Vue `ref`。

4.  **地面摩擦力不生效？**
    *   **原因**：没有正确配置 `ContactMaterial`。
    *   **解决**：在 Cannon `World` 中，需要添加 `ContactMaterial` 来定义两种不同材质接触时的摩擦表现，而不仅仅是给物体赋予材质。
    ```javascript
    const groundMat = new CANNON.Material();
    const ballMat = new CANNON.Material();
    const contactMat = new CANNON.ContactMaterial(groundMat, ballMat, {
      friction: 0.5, // 摩擦力
      restitution: 0.7 // 弹性
    });
    world.addContactMaterial(contactMat);
    ```

### 五、总结建议

1.  **先跑通 Demo**：不要一开始就追求完美的玻璃效果。先用一个白色球体和平面，把物理运动调顺。
2.  **地形生成**：可以使用简单的噪声库（如 `simplex-noise`）来生成随机的起伏地面数据，比手动写数组更自然。
3.  **UI 分离**：游戏画面是 Canvas，UI（分数、开始按钮）是 HTML/CSS。利用 Vue 的优势做好 UI 层，Canvas 层保持独立。

按照这个计划，你可以利用 Vue 3 管理游戏状态，利用 Three.js + Cannon-es 处理核心的 3D 交互，实现一款高质量的弹珠游戏。

### USER
补充玩法为：
1.挖坑玩法(基础版)
1.场地准备:在泥土地面挖3-4个小坑(直径约3-5厘米)，呈直线排列
2.开局顺序:
参与者从起点线将球弹出
离首个坑最近者获得优先权
3.进阶规则:
依次将球弹入三个坑中
完成三坑占领后可攻击对手的球
最终以先进入终点坑者为胜

### ASSISTANT
加上具体的“挖坑弹珠”玩法规则后，项目的重心从单纯的**物理演示**转向了**游戏逻辑与交互设计**。这需要更严谨的状态管理、更精准的碰撞检测（判断进坑）以及特定的操作手感（弹射）。

以下是针对该玩法的**技术栈调整**、**核心逻辑架构**及**详细开发计划**。

---

### 一、技术栈调整与补充

| 模块 | 推荐库/方案 | 针对玩法的调整理由 |
| :--- | :--- | :--- |
| **状态管理** | **Vue 3 `reactive` / Pinia** | 游戏需要明确的状态机（资格赛 -> 游戏开始 -> 玩家回合 -> 攻击模式 -> 结算），Vue 的响应式系统非常适合管理这些 UI 状态。 |
| **交互操作** | **VueUse `usePointerSwipe`** 或 **原生 Pointer Events** | 实现“拉弓弹射”手感。需要计算 2D 屏幕拖拽距离映射为 3D 物理冲量。 |
| **物理检测** | **Cannon-es `isTrigger`** | **关键点**：单纯靠物理凹陷判断“进坑”容易出 Bug（球滚出来）。建议**视觉上做凹陷，物理上用触发器**判断是否捕获。 |
| **相机控制** | **Three.js `OrbitControls`** (限制版) | 需要限制相机角度，保证玩家能看清直线排列的坑，且不能穿地。 |
| **AI 对手** | **自定义逻辑** | 如果是单机游戏，需要编写简单的 AI 逻辑（计算角度、力度）来模拟对手。 |

---

### 二、核心游戏逻辑架构 (State Machine)

在 Vue 组件中，你需要维护一个游戏状态对象：

```javascript
const gameState = reactive({
  phase: 'qualifying', // 'qualifying'(资格赛), 'playing'(正式游戏), 'gameover'(结束)
  currentPlayer: 1,    // 1 或 2 (或 AI)
  turn: 'move',        // 'move'(移动), 'attack'(攻击状态)
  holes: [             // 坑的状态
    { id: 1, occupiedBy: null, position: {x:0, z:-5} },
    { id: 2, occupiedBy: null, position: {x:0, z:-10} },
    { id: 3, occupiedBy: null, position: {x:0, z:-15} },
    { id: 4, occupiedBy: null, position: {x:0, z:-20}, isFinish: true } // 终点坑
  ],
  players: [
    { id: 1, color: 0xff0000, status: 'normal', finished: false }, // status: 'normal' | 'hunter'(可攻击)
    { id: 2, color: 0x0000ff, status: 'normal', finished: false }
  ]
});
```

---

### 三、详细开发计划 (针对新玩法)

#### 第一阶段：场地与“坑”的实现 (Day 1-3)
1.  **泥土地面材质**：
    *   加载泥土纹理贴图 (`Diffuse`, `Normal`, `Roughness`)。
    *   物理材质设置高摩擦力 (`friction: 0.8`)，低弹性 (`restitution: 0.1`)，模拟泥土感。
2.  **实现“坑” (视觉 + 逻辑)**：
    *   **视觉**：使用 `Heightfield` 或在 `PlaneGeometry` 上修改顶点，制造 3-4 个圆形的浅凹陷。
    *   **逻辑 (关键)**：在每个坑的中心放置一个不可见的 **Cannon Trigger (触发器)** 球体或圆柱体。
    *   **进坑判定**：当弹珠 `collide` 事件触发且碰撞对象是 Trigger，且弹珠速度 `< 阈值` 时，判定为“进坑成功”，将弹珠位置吸附到坑中心，并更新 Vue 状态。
3.  **终点线**：
    *   在最后一个坑后方设置终点区域。

#### 第二阶段：弹射操控系统 (Day 4-6)
1.  **射线检测 (Raycasting)**：
    *   监听鼠标/触摸 `down` 和 `up` 事件。
    *   使用 `THREE.Raycaster` 将屏幕坐标转换为 3D 地面坐标。
2.  **力度与方向计算**：
    *   绘制一条从球指向鼠标反方向的“力度线” (Three.js `Line`)。
    *   力度 = 拖拽距离 * 系数。
    *   方向 = 拖拽向量的反方向。
3.  **物理施加**：
    *   松开鼠标时，对当前玩家控制的弹珠刚体应用 `applyImpulse`。
    *   添加最大力度限制，防止球直接飞出地图。

#### 第三阶段：游戏规则引擎 (Day 7-10)
1.  **资格赛逻辑**：
    *   所有球从起点发射。
    *   计算球停止后与“第一个坑”的距离 (`distanceTo`)。
    *   距离最近者设为 `currentPlayer`。
2.  **回合制流程**：
    *   **移动阶段**：玩家尝试将球弹入下一个未占领的坑。
    *   **判定**：
        *   成功进坑 -> 更新 `holes` 状态，若完成 3 坑，玩家状态变为 `'hunter'` (可攻击)。
        *   未进坑 -> 回合结束，切换玩家。
    *   **攻击阶段** (当玩家状态为 `'hunter'`)：
        *   允许玩家直接撞击对手球。
        *   **碰撞监听**：在 Cannon `collide` 事件中，检测碰撞双方是否为不同玩家的球。
        *   **攻击效果**：若 Hunter 撞击 Normal，Normal 球被弹回起点或暂停一回合。
3.  **胜利判定**：
    *   监听终点坑 Trigger。
    *   若有玩家进坑且已完成前置条件，触发 `gameState.phase = 'gameover'`，弹出 Vue UI 胜利界面。

#### 第四阶段：AI 与 体验优化 (Day 11-14)
1.  **简单 AI**：
    *   计算 AI 球到目标坑的向量。
    *   添加随机误差 (Random Noise) 模拟人类失误。
    *   若处于攻击模式，计算撞击对手球的角度。
2.  **相机跟随**：
    *   相机平滑移动 (`lerp`) 到当前操作球的上方。
3.  **特效**：
    *   进坑时：粒子爆炸特效 + 音效。
    *   攻击时：屏幕轻微震动。

---

### 四、关键代码实现思路

#### 1. 坑的触发器逻辑 (Cannon-es + Three.js)
不要完全依赖物理凹陷，用 Trigger 更稳定。

```javascript
// 创建坑的逻辑 (在初始化场地时)
function createHole(x, z, holeId) {
  // 1. 视觉凹陷 (简化版：用一个小圆柱体嵌入地面，颜色深一点)
  const geo = new CylinderGeometry(1.5, 1.5, 0.2, 32);
  const mat = new MeshStandardMaterial({ color: 0x332211 }); // 深色泥土
  const mesh = new Mesh(geo, mat);
  mesh.position.set(x, -0.1, z); // 稍微低于地面
  scene.add(mesh);

  // 2. 物理触发器 (用于判断进坑)
  const shape = new CANNON.Cylinder(1.5, 1.5, 1, 16);
  const body = new CANNON.Body({
    mass: 0,
    isTrigger: true, // 关键：设为触发器，不产生物理碰撞，只触发事件
    type: CANNON.Body.STATIC
  });
  body.addShape(shape);
  body.position.set(x, 0, z);
  
  // 绑定坑 ID
  body.holeId = holeId; 
  world.addBody(body);

  // 3. 监听碰撞
  body.addEventListener('collide', (e) => {
    const ballBody = e.body;
    // 检查碰撞的是否是玩家的球
    if (ballBody.playerId) {
      checkHoleEntry(ballBody, holeId);
    }
  });
}

// 进坑判定函数
function checkHoleEntry(ballBody, holeId) {
  // 只有速度足够慢才算“停进坑里”，否则只是滚过
  if (ballBody.velocity.length() < 0.5) {
    // 触发 Vue 状态更新
    gameLogic.enterHole(ballBody.playerId, holeId);
    
    // 物理吸附：防止球滚出来
    ballBody.position.set(holePositions[holeId].x, 0.5, holePositions[holeId].z);
    ballBody.velocity.set(0,0,0);
    ballBody.angularVelocity.set(0,0,0);
  }
}
```

#### 2. 弹射控制 (Vue + Raycaster)

```javascript
// 使用 VueUse 处理指针事件
import { usePointer } from '@vueuse/core';

const { x, y, pressed } = usePointer();
const dragStart = ref(null);
const dragCurrent = ref(null);

// 在 mousedown/touchstart 时
if (pressed.value && !dragStart.value) {
  dragStart.value = { x: x.value, y: y.value };
}

// 在 mousemove/touchmove 时
if (pressed.value && dragStart.value) {
  dragCurrent.value = { x: x.value, y: y.value };
  // 更新 UI 上的力度线
  updateAimLine(dragStart.value, dragCurrent.value);
}

// 在 mouseup/touchend 时
if (dragStart.value && dragCurrent.value) {
  const dx = dragStart.value.x - dragCurrent.value.x;
  const dy = dragStart.value.y - dragCurrent.value.y;
  
  // 将 2D 屏幕向量转换为 3D 世界向量 (需考虑相机角度)
  const forceVector = screenToWorldVector(dx, dy); 
  
  // 施加冲量
  currentBallBody.applyImpulse(
    new CANNON.Vec3(forceVector.x * 10, 0, forceVector.z * 10),
    currentBallBody.position
  );
  
  // 重置
  dragStart.value = null;
  dragCurrent.value = null;
  endTurn(); // 结束当前操作，切换回合
}
```

#### 3. 攻击逻辑 (碰撞检测)

```javascript
// 在全局碰撞监听中
world.addEventListener('collide', (e) => {
  const bodyA = e.body;
  const bodyB = e.contact.bi; // 碰撞的另一方

  // 确保两个都是球
  if (bodyA.playerId && bodyB.playerId) {
    const playerA = gameState.players.find(p => p.id === bodyA.playerId);
    const playerB = gameState.players.find(p => p.id === bodyB.playerId);

    // 攻击判定：A 是猎人，B 是普通人
    if (playerA.status === 'hunter' && playerB.status === 'normal') {
      // 触发攻击特效
      playHitEffect(e.contact.equation.contactPoint);
      // 可选：增加 B 被击退的惩罚逻辑
      console.log("Player A attacked Player B!");
    }
  }
});
```

### 五、针对玩法的特别注意事项

1.  **摩擦力调优**：
    *   泥土地面的摩擦力要大，否则球停不下来，无法判定“进坑”。
    *   在 Cannon 的 `ContactMaterial` 中，将 `friction` 设为 `0.6 - 0.9` 之间，`restitution` (弹性) 设为 `0.1` (泥土不弹)。
2.  **防作弊/防卡死**：
    *   如果球卡在两个坑之间怎么办？设置一个“重置球”按钮，或者当球速度接近 0 且不在坑内超过 5 秒，自动重置到起点。
3.  **视觉引导**：
    *   用虚线在地面画出 3 个坑的连线，让玩家明确路线。
    *   当前目标坑高亮显示（例如发光）。
4.  **移动端适配**：
    *   弹珠游戏很适合手机玩。确保 `touch-action: none` 防止浏览器默认滚动。
    *   力度线要粗一点，方便手指操作。

### 六、总结

这个玩法的核心在于**“状态机管理”**（Vue 负责）与**“精准碰撞判定”**（Cannon 负责）。
*   **Vue 3** 用来管理谁回合、谁赢了、哪个坑被占了。
*   **Three.js** 用来表现泥土质感和玻璃球的通透感。
*   **Cannon-es** 用来计算滚动、摩擦和碰撞，但**进坑判定建议混合使用 Trigger 和速度阈值**，以保证游戏体验的流畅性，避免物理引擎的微小抖动导致球滚出坑外。

按照这个计划，你可以开发出一款既有复古手感，又有现代视觉效果的手机/网页端弹珠游戏。